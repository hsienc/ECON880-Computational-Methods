%% ---------------------------------------------------------------------------
%% Copyright 2023 by Benjamin Bernard
%%
%% Thanks to the excellent community on tex.stackexchange.com that has taught
%% me much of my more advanced Latex skills. I have used some snippets of code
%% from tex.stackexchange.com, which are under the same license. The links to 
%% those threads are provided before the macro in question.
%%
%% Note that this package makes use of my fikz package for compatibility with
%% non-beamer documetn classes, available at https://github.com/Slyrk/fikz.
%% 
%% This work is licensed under a Creative Commons Attribution-ShareAlike 4.0
%% International License (https://creativecommons.org/licenses/by-sa/4.0/).
%% ---------------------------------------------------------------------------
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{xgames}[2023/01/12 v0.9]
%
\RequirePackage{xcolor, tikz, listofitems, fikz, xfp}
% listofitems.sty allows processing of comma- (and other delimiter)-separated lists
\RequirePackage[outline]{contour}
% For continuous tree branches
\usetikzlibrary{calc, fpu}
% for computation of coordinates
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        0. Auxiliary macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\makeatletter
\long\def\comment#1{}
%
\@ifclassloaded{beamer}{}{
	\long\def\alt{\@ifnextchar<{\beamer@alt}{\beamer@alttwo}}
	\long\def\beamer@alttwo#1#2{#1}
	\long\def\beamer@alt<#1>#2#3{#2}
	\long\def\visible{\@ifnextchar<{\beamer@visible}{\beamer@visibletwo}}
	\long\def\beamer@visibletwo#1{#1}
	\long\def\beamer@visible<#1>#2{#2}
}
% does not require protection of the argument
\let\contour\@contour@outline
\setlength\con@length{0.15em}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	 	0.1 Case distinctions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\ifempty@bgt#1{%
	\ifx\relax#1\relax%
		\expandafter\@firstoftwo%
	\else%
		\expandafter\@secondoftwo%
	\fi%
}
%
\def\ifstrempty@bgt#1{%
	\edef\first@bgt{\expandonce@bgt{#1}}%
	\def\second@bgt{}%
	\ifx\first@bgt\second@bgt%
		\expandafter\@firstoftwo%
	\else%
		\expandafter\@secondoftwo%
	\fi%
}
%
\def\ifstreq@bgt#1#2{%
	\edef\first@bgt{#1}%
	\edef\second@bgt{#2}%
	\ifx\first@bgt\second@bgt%
		\expandafter\@firstoftwo%
	\else%
		\expandafter\@secondoftwo%
	\fi%
}
% Taken from Yannis Lazarides and egreg's contributions to https://tex.stackexchange.com/a/17119/203616
\def\ifisnum@bgt#1{%
% only works for comparison of non-negative integers vs letters
	\sbox\z@{\pgfinterruptpicture\@tempcnta=0#1\relax\endpgfinterruptpicture}%
	\ifdim\wd0>\z@\relax%
   		\expandafter\@secondoftwo%
   	\else%
		\expandafter\@firstoftwo%
   	\fi%
}
%
\def\ifcmd@bgt#1{%
	\expandafter\if\expandafter\firsttoken@bgt\expandafter{\string#1}\@backslashchar%
		\expandafter\@firstoftwo%
	\else%
		\expandafter\@secondoftwo%
	\fi%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		0.2 Expansion at end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\ResetStorage@bgt{\gdef\EnvStored@bgt{}\gdef\LateEnvStored@bgt{}}
% Taken from etoolbox
\def\expandonce@bgt#1{\unexpanded\expandafter{#1}}
\def\AtEndEnv@bgt#1{\xdef\EnvStored@bgt{\expandonce@bgt\EnvStored@bgt#1}}
\def\AtEndEnvNoExpand@bgt#1{\expandafter\gdef\expandafter\EnvStored@bgt\expandafter{\EnvStored@bgt#1}}
\def\LateEndEnv@bgt#1{\xdef\LateEnvStored@bgt{\expandonce@bgt\LateEnvStored@bgt#1}}
\def\LateEndEnvNoExpand@bgt#1{\expandafter\gdef\expandafter\LateEnvStored@bgt\expandafter{\LateEnvStored@bgt#1}}
\BeforeBeginEnvironment{tikzpicture}{\matrixreset\ifwithin@matrix@bgt\else\ResetStorage@bgt\fi\reset@strategy@bgt}
\AtEndEnvironment{tikzpicture}{\ifwithin@matrix@bgt\else\EnvStored@bgt\LateEnvStored@bgt\fi}
\AfterEndEnvironment{tikzpicture}{\setcounter{activeplayer@bgt}{0}}
\def\append@bgt#1#2{\ifstreq@bgt{#1}{}{\xdef#1{#2}}{\xdef#1{\expandonce@bgt#1, #2}}} % why does it expand?
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	 	0.3 Adding overlay
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Usage: 
% - define \newcommand{\macro@bgt}[n]{} as usual, adding \overlay@bgt where an overlay specification would go, i.e., writing \expandafter\draw\overlay@bgt instead of \draw
% - \addoverlay@bgt{macro} defines \macro[n]{} that is identical to \macro@bgt but overlay aware
%
\def\gobbleoverlay@bgt#1<#2>{%
	\def\overlay@bgt{<#2>}%
	\expandafter#1%
}
\def\addoverlay@bgt#1{%
	\expandafter\def\csname#1Check@Overlay@bgt\endcsname{%
		\ifx\nextChar@bgt<%
			\def\temp{\expandafter\gobbleoverlay@bgt\expandafter{\csname#1@bgt\endcsname}}%
			\expandafter\temp%
		\else%
			\def\overlay@bgt{}%
			\expandafter\expandafter\csname#1@bgt\endcsname%
		\fi%
	}%
	\def\temp{\expandafter\def\csname#1\endcsname}%
	\expandafter\temp\expandafter{\expandafter\futurelet\expandafter\nextChar@bgt\csname#1Check@Overlay@bgt\endcsname}%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	   0.4 Optional Argument of \def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Usage: 
% - define command via \def\macro@opt#1... as usual, accessing the optional argument via \option@bgt
% - \addoptions@bgt{macro} defines \macro@bgt[n][]{} that is identical to \macro@opt but has an optional argument.
% - The resulting \macro@bgt can be further processed by \addoverlay
%
\def\gobbleoption@bgt#1[#2]{%
	\def\option@bgt{#2}%
	\expandafter#1%
}
\def\addoptions@bgt#1{%
	\expandafter\def\csname#1Check@Option@bgt\endcsname{%
		\ifx\nextChar@bgt[%
			\def\temp{\expandafter\gobbleoption@bgt\expandafter{\csname#1@opt\endcsname}}%
			\expandafter\temp%
		\else%
			\def\option@bgt{}%
			\expandafter\expandafter\csname#1@opt\endcsname%
		\fi%
	}%
	\def\temp{\expandafter\def\csname#1@bgt\endcsname}%
	\expandafter\temp\expandafter{\expandafter\futurelet\expandafter\nextChar@bgt\csname#1Check@Option@bgt\endcsname}%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     0.5 Two-Layer Key-Value System
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This macro is due to David Carlisle, taken from https://tex.stackexchange.com/a/87510/203616
\def\RemoveSpaces#1{\zap@space#1 \@empty}
\def\define@bgt@key#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: macroname
	% #4: default value
	{\globaldefs=1%
		\define@key{#1@bgt}{#2}{\expandafter\def\csname#3@bgt\endcsname{##1}}%
		\define@key{#1@def}{#2}{\expandafter\def\csname#3@def\endcsname{##1}}%
		\def\temp{\expandafter\def\csname#3@def\endcsname}%
		\expandafter\temp\expandafter{#4}%
	}%
}
\def\define@bgt@length#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: length name
	% #4: default value
	{\globaldefs=1%
		\expandafter\newlength\expandafter{\csname#3@bgt\endcsname}%
		\expandafter\newlength\expandafter{\csname#3@def\endcsname}%
		\define@key{#1@bgt}{#2}{\expandafter\setlength\expandafter{\csname#3@bgt\endcsname}{##1}}%
		\define@key{#1@def}{#2}{\expandafter\setlength\expandafter{\csname#3@def\endcsname}{##1}}%
		\expandafter\setlength\expandafter{\csname#3@def\endcsname}{#4}%
	}%
}
\def\define@bgt@counter#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: counter name
	% #4: default value
	{\globaldefs=1%
		\newcounter{#3@bgt}%
		\newcounter{#3@def}%
		\define@key{#1@bgt}{#2}{\setcounter{#3@bgt}{##1}}%
		\define@key{#1@def}{#2}{\setcounter{#3@def}{##1}}%
		\setcounter{#3@def}{#4}%
	}%
}
\def\define@bgt@if#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: if name
	% #4: default value
	{\globaldefs=1%
		\expandafter\newif\csname if#3@bgt\endcsname%
		\expandafter\newif\csname if#3@def\endcsname%
		\define@key{#1@bgt}{#2}[true]{\ifstreq@bgt{##1}{true}{\csname#3@bgttrue\endcsname}{\csname#3@bgtfalse\endcsname}}%
		\define@key{#1@def}{#2}[true]{\ifstreq@bgt{##1}{true}{\csname#3@deftrue\endcsname}{\csname#3@deffalse\endcsname}}%
		\ifstreq@bgt{#4}{true}{\csname#3@deftrue\endcsname}{\csname#3@deffalse\endcsname}%
	}%
}
\def\define@bgt@switch#1#2#3#4{
	% #1: key family
	% #2: key name
	% #3: color name
	% #4: default value and other options
	\setsepchar{:}
	\expandafter\greadlist\expandafter*\csname#3@options@bgt\endcsname{#4}
	\foreach \j@bgt in {2, ..., \csname#3@options@bgtlen\endcsname}{
		\expandafter\itemtomacro\csname#3@options@bgt\endcsname[\j@bgt]\curr@option@bgt
		\globaldefs=1
		\expandafter\newif\csname if#3@\curr@option@bgt @bgt\endcsname
		\expandafter\newif\csname if#3@\curr@option@bgt @def\endcsname
	}
	{\globaldefs=1
	\define@key{#1@bgt}{#2}{%
		\setswitchtodefault@bgt{#3}%
		\ifstreq@bgt{\switch@default@bgt}{}{}{\csname\switch@default@bgt @bgtfalse\endcsname}%
		\csname #3@##1@bgttrue\endcsname%
	}
	\define@key{#1@def}{#2}{\setdefaultswitch@bgt{#3}{##1}}%\setswitchtodefault@bgt{#3}}
	}
}
\def\define@bgt@color#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: color name
	% #4: default value
	{\globaldefs=1%
		\define@key{#1@bgt}{#2}{\colorlet{#3@bgt}{##1}}%
		\define@key{#1@def}{#2}{\colorlet{#3@def}{##1}}%
	}%
	\xglobal\colorlet{#3@def}{#4}%
}
%
\def\define@key@scale#1{%
	\expandafter\def\csname#1@xscale@def\endcsname{1}%
	\expandafter\def\csname#1@yscale@def\endcsname{1}%
	{\globaldefs=1%
		\define@key{#1@def}{scale}{\expandafter\def\csname#1@xscale@def\endcsname{##1}\expandafter\def\csname#1@yscale@def\endcsname{##1}}%
		\define@key{#1@def}{xscale}{\expandafter\def\csname#1@xscale@def\endcsname{##1}}%
		\define@key{#1@def}{yscale}{\expandafter\def\csname#1@yscale@def\endcsname{##1}}%
	}%
}
%
\def\define@key@thickness#1#2#3{%
	{\globaldefs=1%
		\define@key{#1@#2}{ultra thin}[true]{#3{0.1pt}}%
		\define@key{#1@#2}{very thin}[true]{#3{0.2pt}}%
		\define@key{#1@#2}{thin}[true]{#3{0.4pt}}%
		\define@key{#1@#2}{semithick}[true]{#3{0.6pt}}%
		\define@key{#1@#2}{thick}[true]{#3{0.8pt}}%
		\define@key{#1@#2}{very thick}[true]{#3{1.2pt}}%
		\define@key{#1@#2}{ultra thick}[true]{#3{1.6pt}}%
	}%
}
\def\define@key@thickness@bgt#1{%
	\define@key@thickness{#1}{bgt}{\expandafter\setlength\expandafter{\csname#1@linewidth@bgt\endcsname}}%
	\define@key@thickness{#1}{def}{\expandafter\setlength\expandafter{\csname#1@linewidth@def\endcsname}}%
}%
\def\define@key@thickness@bgts#1{\define@key@thickness{#1}{bgt}{\expandafter\setlength\expandafter{\csname#1@linewidth@bgt\endcsname}}}%
%
\def\append@key@bgt#1#2{%
	\ifstrempty@bgt{#1}{\def#1{#2}}{\expandafter\def\expandafter#1\expandafter{#1, #2}}%
}
%
\def\pass@bgt@key#1#2#3#4{%
	% #1: key family
	% #2: top key name
	% #3: bottom keys
	% #4: default value
	\setsepchar{,/:}
	\expandafter\greadlist\expandafter*\csname#1@#2@keys@bgt\endcsname{#3}
	\ifstreq@bgt{#3}{}{\def\defval@bgt{}}{\def\defval@bgt{[#4]}}
	{\globaldefs=1%
		% setting #2 key of #1@bgt to ##1 will append \bottomkey@bgt=##1 to \#1@\family@bgt @bgt
		\def\temp{\define@key{#1@bgt}{#2}}
		\expandafter\temp\defval@bgt{%
			% two things: \aftergroup and not expanding ##1
			\foreach \j@bgt in {1, ..., \csname#1@#2@keys@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@#2@keys@bgt\endcsname[\j@bgt,1]\family@bgt
				% read bottom key
				\edef\m@bgt{\expandafter\listlen\csname#1@#2@keys@bgt\endcsname[\j@bgt]}
				\ifnum\m@bgt>1
					\expandafter\itemtomacro\csname#1@#2@keys@bgt\endcsname[\j@bgt,2]\bottomkey@bgt
				\else
					\def\bottomkey@bgt{#2}
				\fi
				% set keys
				\expandafter\gdef\csname#1@\family@bgt @aft\expandafter\endcsname\expandafter{\expandafter\append@key@bgt\expandafter{\csname#1@\family@bgt @bgt\expandafter\endcsname\expandafter}\expandafter{\bottomkey@bgt=##1}}
				\aftergroup\aftergroup\expandafter\aftergroup\csname#1@\family@bgt @aft\endcsname
			}%
		}%
		\def\temp{\define@key{#1@def}{#2}}
		\expandafter\temp\defval@bgt{%
			\foreach \j@bgt in {1, ..., \csname#1@#2@keys@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@#2@keys@bgt\endcsname[\j@bgt,1]\family@bgt
				% read bottom key
				\edef\m@bgt{\expandafter\listlen\csname#1@#2@keys@bgt\endcsname[\j@bgt]}
				\ifnum\m@bgt>1
					\expandafter\itemtomacro\csname#1@#2@keys@bgt\endcsname[\j@bgt,2]\bottomkey@bgt
				\else
					\def\bottomkey@bgt{#2}
				\fi
				% set keys
				\expandafter\xdef\csname#1@\family@bgt @aft\endcsname{\noexpand\append@key@bgt{\expandafter\noexpand\csname#1@\family@bgt @def\endcsname}{\bottomkey@bgt=\protect##1}}
%				
				\expandafter\gdef\csname#1@\family@bgt @aft\expandafter\endcsname\expandafter{\expandafter\append@key@bgt\expandafter{\csname#1@\family@bgt @def\expandafter\endcsname\expandafter}\expandafter{\bottomkey@bgt=\noexpand##1}}
				\aftergroup\aftergroup\expandafter\aftergroup\csname#1@\family@bgt @aft\endcsname
			}%
		}%
	}%
}
%
\newif\ifinside@switch@bgt
\def\setiftodefault@bgt#1{%
	\csname if#1@def\endcsname%
		\global\csname#1@bgttrue\endcsname%
		\ifinside@switch@bgt\xdef\switch@default@bgt{#1}\fi%
	\else%
		\global\csname#1@bgtfalse\endcsname%
	\fi%
}
\def\setswitchtodefault@bgt#1{%
	\xdef\switch@default@bgt{}%
	\inside@switch@bgttrue%
	\foreach \i@bgt in {2, ..., \csname#1@options@bgtlen\endcsname}{%
		\expandafter\itemtomacro\csname#1@options@bgt\endcsname[\i@bgt]\curr@option@bgt%
		\setiftodefault@bgt{#1@\curr@option@bgt}%
	}%
	\inside@switch@bgtfalse%
}
\def\setdefaultswitch@bgt#1#2{%
	\foreach \i@bgt in {2, ..., \csname#1@options@bgtlen\endcsname}{%
		\expandafter\itemtomacro\csname#1@options@bgt\endcsname[\i@bgt]\curr@option@bgt%
		\ifstreq@bgt{#2}{\curr@option@bgt}{%
			\expandafter\xdef\csname aftergroup\romannumeral\i@bgt @def\endcsname{\noexpand\csname#1@\curr@option@bgt @deftrue\noexpand\endcsname}%
			\aftergroup\aftergroup\expandafter\aftergroup\csname aftergroup\romannumeral\i@bgt @def\endcsname%
		}{%
			\expandafter\xdef\csname aftergroup\romannumeral\i@bgt @def\endcsname{\noexpand\csname#1@\curr@option@bgt @deffalse\noexpand\endcsname}%
			\aftergroup\aftergroup\expandafter\aftergroup\csname aftergroup\romannumeral\i@bgt @def\endcsname%
		}%
	}%
}
%
\newif\ifpass@contained@bgt
\def\define@bgt@family#1#2#3#4#5#6#7#8#9{
	% #1: key family
	% #2: list of def keys
	% #3: list of length keys
	% #4: list of counter keys
	% #5: list of if keys
	% #6: list of if keys
	% #7: list of color keys
	% #8: list of pass-through keys
	% #9: list of statements to be added to default
	\setsepchar{;/,}
	\ifempty@bgt{#2}{
		\expandafter\def\csname#1@keylist@bgtlen\endcsname{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@keylist@bgt\endcsname{#2}
	}
	\ifempty@bgt{#3}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@lengthlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@lengthlist@bgt\endcsname{#3}
	}
	\ifempty@bgt{#4}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@counterlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@counterlist@bgt\endcsname{#4}
	}
	\ifempty@bgt{#5}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@iflist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@iflist@bgt\endcsname{#5}
	}
	\ifempty@bgt{#6}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@switchlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@switchlist@bgt\endcsname{#6}
	}
	\ifempty@bgt{#7}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@colorlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@colorlist@bgt\endcsname{#7}
	}
	\ifempty@bgt{#8}{
		\expandafter\def\csname#1@passlist@bgtlen\endcsname{0}
	}{
		\setsepchar{;/->/,/:}
		\expandafter\readlist\expandafter*\csname#1@passlist@bgt\endcsname{#8}
	}
	% define the keys globally
	\expandafter\ifnum\csname#1@keylist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@keylist@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname#1@keylist@bgt\endcsname[\i,1]\keyname@bgt
			\expandafter\itemtomacro\csname#1@keylist@bgt\endcsname[\i,2]\defval@bgt
			\edef\defname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
			\def\temp{\define@bgt@key{#1}}
			\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\defname@bgt}{\defval@bgt} %\keyname must be expanded
		}
	\fi
	\expandafter\ifnum\csname#1@lengthlist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@lengthlist@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname#1@lengthlist@bgt\endcsname[\i,1]\keyname@bgt%
			\expandafter\itemtomacro\csname#1@lengthlist@bgt\endcsname[\i,2]\defval@bgt%
			\edef\lengthname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
			\def\temp{\define@bgt@length{#1}}
			\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\lengthname@bgt}{\defval@bgt} %\keyname must be expanded
		}
	\fi
	\expandafter\ifnum\csname#1@counterlist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@counterlist@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname#1@counterlist@bgt\endcsname[\i,1]\keyname@bgt
			\expandafter\itemtomacro\csname#1@counterlist@bgt\endcsname[\i,2]\defval@bgt
			\edef\countername@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
			\def\temp{\define@bgt@counter{#1}}
			\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\countername@bgt}{\defval@bgt}
		}
	\fi
	\expandafter\ifnum\csname#1@iflist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@iflist@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname#1@iflist@bgt\endcsname[\i,1]\keyname@bgt
			\expandafter\itemtomacro\csname#1@iflist@bgt\endcsname[\i,2]\defval@bgt
			\edef\ifname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
			\def\temp{\define@bgt@if{#1}}
			\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\ifname@bgt}{\defval@bgt} %\keyname must be expanded
		}
	\fi
	\expandafter\ifnum\csname#1@switchlist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@switchlist@bgtlen\endcsname}{%
			\expandafter\itemtomacro\csname#1@switchlist@bgt\endcsname[\i,1]\keyname%
			\expandafter\itemtomacro\csname#1@switchlist@bgt\endcsname[\i,2]\keyval%
			\edef\switchname{#1@\expandafter\RemoveSpaces\expandafter{\keyname}}%
			\def\temp{\define@bgt@switch{#1}{\keyname}}%
			\expandafter\temp\expandafter{\switchname}{\keyval}%
		}%
	\fi
	\expandafter\ifnum\csname#1@colorlist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@colorlist@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname#1@colorlist@bgt\endcsname[\i,1]\keyname@bgt
			\expandafter\itemtomacro\csname#1@colorlist@bgt\endcsname[\i,2]\defval@bgt
			\edef\colorname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
			\def\temp{\define@bgt@color{#1}}
			\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\colorname@bgt}{\defval@bgt} %\keyname must be expanded
		}
	\fi
	% initialize the list of families, to which a key has been passed, to the empty list
	\expandafter\def\csname#1@passfam@bgt\endcsname{}
	\expandafter\ifnum\csname#1@passlist@bgtlen\endcsname>0
		\foreach \i in {1, ..., \csname#1@passlist@bgtlen\endcsname} {
			% key to be passed is \topkey@bgt
			\expandafter\itemtomacro\csname#1@passlist@bgt\endcsname[\i,1,1,1]\topkey@bgt
			% store default value of \topkey@bgt in \defval@bgt
			\edef\hasdef@bgt{\expandafter\listlen\csname#1@passlist@bgt\endcsname[\i,1,1]}
			\ifnum\hasdef@bgt>1
				\expandafter\itemtomacro\csname#1@passlist@bgt\endcsname[\i,1,1,2]\defval@bgt
			\else
				\def\defval@bgt{}
			\fi
			% list of bottom keys in \bottomkeys@bgt
			\expandafter\itemtomacro\csname#1@passlist@bgt\endcsname[\i,2]\bottomkeys@bgt
			\edef\nkeys@bgt{\expandafter\listlen\csname#1@passlist@bgt\endcsname[\i,2]}
			% the entire for loop simply resets the inheritance
			\foreach \j@bgt in {1, ..., \nkeys@bgt} {
				\expandafter\itemtomacro\csname#1@passlist@bgt\endcsname[\i,2,\j@bgt,1]\family@bgt
				\expandafter\ifstreq@bgt\expandafter{\csname#1@passfam@bgt\endcsname}{}{
					% if the list is still empty, we add the family to the list
					\expandafter\xdef\csname#1@passfam@bgt\endcsname{\family@bgt}
					% initialize defaults: reset
					\expandafter\gdef\csname#1@\family@bgt @def\endcsname{}
				}{
					% if the list is not empty, we search the list for the current family and add it if needed
					\pass@contained@bgtfalse
					\edef\temp{\csname#1@passfam@bgt\endcsname}
					\expandafter\foreach\expandafter\fam@bgt\expandafter i\expandafter n\expandafter{\temp}{
						\ifstreq@bgt{\fam@bgt}{\family@bgt}{\global\pass@contained@bgttrue}{}
					}
					\ifpass@contained@bgt\else
						\expandafter\xdef\csname#1@passfam@bgt\endcsname{\csname#1@passfam@bgt\endcsname, \family@bgt}
						% initialize defaults: reset
						\expandafter\gdef\csname#1@\family@bgt @def\endcsname{}
					\fi
				}
			}
			% The following line initializes the transfer
			\edef\call@pass@key{\noexpand\pass@bgt@key{#1}{\topkey@bgt}{\bottomkeys@bgt}{\defval@bgt}}
			\call@pass@key
		}
	\fi
	{\globaldefs=1%
		% define sticky option
		\expandafter\newif\expandafter{\csname if#1@sticky@bgt\endcsname}
		\define@key{#1@bgt}{sticky}[true]{\ifstreq@bgt{##1}{true}{\csname#1@sticky@bgttrue\endcsname}{\csname#1@sticky@bgtfalse\endcsname}}%
	}%
	% Process key-value pairs
	\expandafter\def\csname#1setoptions@bgt\endcsname##1{%
		\csname if#1@sticky@bgt\endcsname%
			%\relax%
		\else%
			\expandafter\ifnum\csname#1@keylist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@keylist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@keylist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\defname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\def\temp{\expandafter\global\expandafter\let\csname\defname@bgt @bgt\endcsname}%
					\expandafter\temp\csname\defname@bgt @def\endcsname%
				}%
			\fi%
			\expandafter\ifnum\csname#1@lengthlist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@lengthlist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@lengthlist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\lengthname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\def\temp{\expandafter\global\csname\lengthname@bgt @bgt\endcsname}%
					\expandafter\temp\csname\lengthname@bgt @def\endcsname%
				}%
			\fi%
			\expandafter\ifnum\csname#1@counterlist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@counterlist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@counterlist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\countername@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\global\setcounter{\countername@bgt @bgt}{\value{\countername@bgt @def}}%
				}%
			\fi%
			\expandafter\ifnum\csname#1@iflist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@iflist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@iflist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\ifname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\setiftodefault@bgt{\ifname@bgt}%
				}%
			\fi%
			\expandafter\ifnum\csname#1@switchlist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@switchlist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@switchlist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\switchname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\setswitchtodefault@bgt{\switchname@bgt}%
				}%
			\fi%
			\expandafter\ifnum\csname#1@colorlist@bgtlen\endcsname>0%
				\foreach \i in {1, ..., \csname#1@colorlist@bgtlen\endcsname} {%
					\expandafter\itemtomacro\csname#1@colorlist@bgt\endcsname[\i,1]\keyname@bgt%
					\edef\colorname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}%
					\def\temp{\expandafter\xglobal\expandafter\colorlet\expandafter{\colorname@bgt @bgt}}%
					\expandafter\temp\expandafter{\colorname@bgt @def}%
				}%
			\fi%
			\expandafter\ifstreq@bgt\expandafter{\csname#1@passfam@bgt\endcsname}{}{}{
				\edef\temp{\csname#1@passfam@bgt\endcsname}
				\expandafter\foreach\expandafter\fam@bgt\expandafter i\expandafter n\expandafter{\temp}{
					\edef\macroname@bgt{#1@\fam@bgt}
					\def\temp{\expandafter\global\expandafter\let\csname\macroname@bgt @bgt\endcsname}%
					\expandafter\temp\csname\macroname@bgt @def\endcsname%
				}
			}
			%
			#9%
		\fi%
		\setkeys{#1@bgt}{##1}%
	}%
	% Define global options
	\expandafter\def\csname#1setoptions\endcsname##1{%
		\setkeys{#1@def}{##1}%
		\csname#1@sticky@bgtfalse\endcsname
		\csname#1setoptions@bgt\endcsname{}
	}
	% Set to default initially
	\csname#1setoptions@bgt\endcsname{}
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     0.6 Single-Layer Key-Value System
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\RemoveSpaces#1{\zap@space#1 \@empty}
\def\define@bgts@key#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: macroname
	% #4: default value
	\define@key{#1@bgt}{#2}{\expandafter\def\csname#3@bgt\endcsname{##1}}%
	\def\temp{\expandafter\def\csname#3@bgt\endcsname}%
	\expandafter\temp\expandafter{#4}%
}
\def\define@bgts@length#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: length name
	% #4: default value
	\expandafter\newlength\expandafter{\csname#3@bgt\endcsname}%
	\define@key{#1@bgt}{#2}{\expandafter\setlength\expandafter{\csname#3@bgt\endcsname}{##1}}%
	\expandafter\setlength\expandafter{\csname#3@bgt\endcsname}{#4}%
}
\def\define@bgts@counter#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: counter name
	% #4: default value
	\newcounter{#3@bgt}%
	\define@key{#1@bgt}{#2}{\setcounter{#3@bgt}{##1}}%
	\setcounter{#3@bgt}{#4}%
}
\def\define@bgts@if#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: if name
	% #4: default value
	\expandafter\newif\csname if#3@bgt\endcsname%
	\define@key{#1@bgt}{#2}[true]{\ifstreq@bgt{##1}{true}{\csname#3@bgttrue\endcsname}{\csname#3@bgtfalse\endcsname}}%
	\ifstreq@bgt{#4}{true}{\csname#3@bgttrue\endcsname}{\csname#3@bgtfalse\endcsname}%
}
\def\define@bgts@switch#1#2#3#4{
	% #1: key family
	% #2: key name
	% #3: color name
	% #4: default value and other options
	\setsepchar{:}
	\expandafter\greadlist\expandafter*\csname#3@options@bgt\endcsname{#4}
	\foreach \i@bgt in {2, ..., \csname#3@options@bgtlen\endcsname}{
		\expandafter\itemtomacro\csname#3@options@bgt\endcsname[\i@bgt]\curr@option@bgt
		\expandafter\newif\csname if#3@\curr@option@bgt @bgt\endcsname
	}
	\define@key{#1@bgt}{#2}{\setswitch@bgt{#3}{##1}}
}
\def\define@bgts@color#1#2#3#4{%
	% #1: key family
	% #2: key name
	% #3: color name
	% #4: default value
	\define@key{#1@bgt}{#2}{\colorlet{#3@bgt}{##1}}%
	\xglobal\colorlet{#3@bgt}{#4}%
}
\def\setswitch@bgt#1#2{%
	% Problem: sets keys globally
	\foreach \i@bgt in {2, ..., \csname#1@options@bgtlen\endcsname}{%
		\expandafter\itemtomacro\csname#1@options@bgt\endcsname[\i@bgt]\curr@option@bgt%
		\ifstreq@bgt{#2}{\curr@option@bgt}{%
			\expandafter\xdef\csname aftergroup\romannumeral\i@bgt @bgt\endcsname{\expandafter\noexpand\csname#1@\curr@option@bgt @bgttrue\endcsname}%
			\aftergroup\aftergroup\expandafter\aftergroup\csname aftergroup\romannumeral\i@bgt @bgt\endcsname%
		}{%
			\expandafter\xdef\csname aftergroup\romannumeral\i@bgt @bgt\endcsname{\expandafter\noexpand\csname#1@\curr@option@bgt @bgtfalse\endcsname}%
			\aftergroup\aftergroup\expandafter\aftergroup\csname aftergroup\romannumeral\i@bgt @bgt\endcsname
		}%
	}%
}
%
% BB: remove space should probably go into the define key, though this way is easier with expansions
%
\def\define@bgts@family#1#2#3#4#5#6#7#8{
	% #1: key family
	% #2: list of def keys
	% #3: list of length keys
	% #4: list of counter keys
	% #5: list of if keys
	% #6: list of if keys
	% #7: list of color keys
	% #8: list of statements to be added to default
	\setsepchar{;/,}
	\ifempty@bgt{#2}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@keylist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@keylist@bgt\endcsname{#2}
	}
	\ifempty@bgt{#3}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@lengthlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@lengthlist@bgt\endcsname{#3}
	}
	\ifempty@bgt{#4}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@counterlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@counterlist@bgt\endcsname{#4}
	}
	\ifempty@bgt{#5}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@iflist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@iflist@bgt\endcsname{#5}
	}
	\ifempty@bgt{#6}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@switchlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@switchlist@bgt\endcsname{#6}
	}
	\ifempty@bgt{#7}{
		\expandafter\pgfmathtruncatemacro\expandafter{\csname#1@colorlist@bgtlen\endcsname}{0}
	}{
		\expandafter\readlist\expandafter*\csname#1@colorlist@bgt\endcsname{#7}
	}
	% define the keys globally
	{\globaldefs=1\relax
		\expandafter\ifnum\csname#1@keylist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@keylist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@keylist@bgt\endcsname[\i,1]\keyname@bgt
				\expandafter\itemtomacro\csname#1@keylist@bgt\endcsname[\i,2]\defval@bgt
				\edef\defname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@key{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\defname@bgt}{\defval@bgt}
			}
		\fi
		\expandafter\ifnum\csname#1@lengthlist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@lengthlist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@lengthlist@bgt\endcsname[\i,1]\keyname@bgt%
				\expandafter\itemtomacro\csname#1@lengthlist@bgt\endcsname[\i,2]\defval@bgt%
				\edef\lengthname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@length{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\lengthname@bgt}{\defval@bgt}
			}
		\fi
		\expandafter\ifnum\csname#1@counterlist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@counterlist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@counterlist@bgt\endcsname[\i,1]\keyname@bgt
				\expandafter\itemtomacro\csname#1@counterlist@bgt\endcsname[\i,2]\defval@bgt
				\edef\countername@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@counter{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\countername@bgt}{\defval@bgt}
			}
		\fi
		\expandafter\ifnum\csname#1@iflist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@iflist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@iflist@bgt\endcsname[\i,1]\keyname@bgt
				\expandafter\itemtomacro\csname#1@iflist@bgt\endcsname[\i,2]\defval@bgt
				\edef\ifname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@if{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\ifname@bgt}{\defval@bgt}
			}
		\fi
		\expandafter\ifnum\csname#1@switchlist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@switchlist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@switchlist@bgt\endcsname[\i,1]\keyname@bgt
				\expandafter\itemtomacro\csname#1@switchlist@bgt\endcsname[\i,2]\defval@bgt
				\edef\switchname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@switch{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\switchname@bgt}{\defval@bgt}
			}
		\fi
		\expandafter\ifnum\csname#1@colorlist@bgtlen\endcsname>0
			\foreach \i in {1, ..., \csname#1@colorlist@bgtlen\endcsname} {
				\expandafter\itemtomacro\csname#1@colorlist@bgt\endcsname[\i,1]\keyname@bgt
				\expandafter\itemtomacro\csname#1@colorlist@bgt\endcsname[\i,2]\defval@bgt
				\edef\colorname@bgt{#1@\expandafter\RemoveSpaces\expandafter{\keyname@bgt}}
				\def\temp{\define@bgts@color{#1}}
				\expandafter\expandafter\expandafter\temp\expandafter\expandafter\expandafter{\expandafter\keyname@bgt\expandafter}\expandafter{\colorname@bgt}{\defval@bgt}
			}
		\fi
		% define sticky option
		\expandafter\newif\expandafter{\csname if#1@sticky@bgt\endcsname}
		\define@key{#1@bgt}{sticky}[true]{\ifstreq@bgt{##1}{true}{\csname#1@sticky@bgttrue\endcsname}{\csname#1@sticky@bgtfalse\endcsname}}%
	}
	% Process key-value pairs
	\expandafter\def\csname#1setoptions\endcsname##1{%
		\setkeys{#1@bgt}{##1}
	}
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     0.7 Passing on Key-Value Pairs to TikZ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\parsekeyvalue@bgt#1#2{% BB: I think this should be done with \CurrOption instead
% #1: key family
% #2: keys
	\gdef\ownkeys@bgt{}%
	\gdef\passtotikz@bgt{}%
	\ifstreq@bgt{#2}{}{}{%
   		\setsepchar{,/=}%
		\readlist*\keyvalue@bgt{#2}%
		%
		\foreach \i in {1, ..., \keyvalue@bgtlen} {%
			\itemtomacro\keyvalue@bgt[\i,1]\keyname@bgt%
			\edef\tmp{KV@#1@bgt@\keyname@bgt}%
			\@ifundefined{\tmp}{%
				\ifstreq@bgt{\passtotikz@bgt}{}{%
					\xdef\passtotikz@bgt{\keyvalue@bgt[\i]}%
				}{%
					\xdef\passtotikz@bgt{\passtotikz@bgt, \keyvalue@bgt[\i]}%
				}%
			}{%
				\ifstreq@bgt{\ownkeys@bgt}{}{%
					\xdef\ownkeys@bgt{\keyvalue@bgt[\i]}%
				}{%
					\xdef\ownkeys@bgt{\ownkeys@bgt, \keyvalue@bgt[\i]}%
	}}}}%
	%
	\def\temp{\csname#1setoptions@bgt\endcsname}%
	\expandafter\temp\expandafter{\ownkeys@bgt}%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		0.8 PGF commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% I found this command thanks to Circumscribe's answer at https://tex.stackexchange.com/a/474035/203616
\def\getscale@bgt{%
	\pgfgettransformentries{\xscale@bgt}{\@temp}{\@temp}{\yscale@bgt}{\@temp}{\@temp}%
	\pgfmathparse{1/\xscale@bgt}%
	\global\let\invx@bgt\pgfmathresult%
	\pgfmathparse{1/\yscale@bgt}%
	\global\let\invy@bgt\pgfmathresult%
}
% transforms a coordinate into a scale-invariant version
\def\scale@invariant@bgt#1#2{
	% #1: name of control sequence for the coordinate to be stored into. \#1 contains the coordinate and \@#1 contains the coordinate if used in a coordinate computation
	% get current pgf transformation
	\getscale@bgt%
	%
	\setsepchar{,}
	\readlist*\coord@input@bgt{#2}
	\ifnum\coord@input@bgtlen>1
		% cartesian coordinates
		\expandafter\xdef\csname @#1\endcsname{\invx@bgt*(\coord@input@bgt[1], 0) + \invy@bgt*(0, \coord@input@bgt[2])}
		\expandafter\xdef\csname #1\endcsname{($\invx@bgt*(\coord@input@bgt[1], 0) + \invy@bgt*(0, \coord@input@bgt[2])$)};
	\else
		% polar coordinates
		\setsepchar{:}
		\readlist*\coord@input@bgt{#2}
		\expandafter\xdef\csname @#1\endcsname{(\coord@input@bgt[1]:\invx@bgt*\coord@input@bgt[2] and \invy@bgt*\coord@input@bgt[2])}
		\expandafter\xdef\csname #1\endcsname{(\coord@input@bgt[1]:\invx@bgt*\coord@input@bgt[2] and \invy@bgt*\coord@input@bgt[2])}
	\fi
}
\def\length@invariant@bgt#1#2{
	% #1: name of control sequence for the coordinate to be stored into. \#1 contains the coordinate and \@#1 contains the coordinate if used in a coordinate computation
	% get current pgf transformation
	\getscale@bgt%
	%
	\setsepchar{,}
	\readlist*\coord@input@bgt{#2}
	\ifnum\coord@input@bgtlen>1
		% cartesian coordinates
		\pgfmathsetmacro{\factor@bgt}{1}
		\pgfmathsetmacro{\factor@bgt}{sqrt((0.01*\coord@input@bgt[1])^2 + (0.01*\coord@input@bgt[2])^2)/sqrt((0.01*\xscale@bgt*\coord@input@bgt[1])^2 + (0.01*\yscale@bgt*\coord@input@bgt[2])^2)}
		\expandafter\xdef\csname @#1\endcsname{\factor@bgt*(\coord@input@bgt[1], 0) + \factor@bgt*(0, \coord@input@bgt[2])}
		\expandafter\xdef\csname #1\endcsname{($\factor@bgt*(\coord@input@bgt[1], 0) + \factor@bgt*(0, \coord@input@bgt[2])$)};
	\else
		% polar coordinates
		\setsepchar{:}
		\readlist*\coord@input@bgt{#2}
		\pgfmathsetmacro{\factor@bgt}{1/sqrt((\xscale@bgt*cos(\coord@input@bgt[1]))^2 + (\yscale@bgt*sin(\coord@input@bgt[1]))^2)}
		\expandafter\xdef\csname @#1\endcsname{(\coord@input@bgt[1]:\factor@bgt*\coord@input@bgt[2])}
		\expandafter\xdef\csname #1\endcsname{(\coord@input@bgt[1]:\factor@bgt*\coord@input@bgt[2])}
	\fi
}
%
% This code is due to user31034, available at https://tex.stackexchange.com/a/476785/203616
\def\pgfextractangle#1#2#3{%
	% yields angles in [0, 360)
    \pgfmathanglebetweenpoints{\pgfpointanchor{#2}{center}}{\pgfpointanchor{#3}{center}}%
    \global\let#1\pgfmathresult%
}
\def\extractangle#1#2#3{%
	\pgfmathparse{atan2(#3, #2)}%
    \global\let#1\pgfmathresult%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	 0.9 Convex Hull with Graham Scan
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following code is due to Qrrbrbirlbel, taken from https://tex.stackexchange.com/a/250146/203616
%
\usetikzlibrary{backgrounds}
\newcommand*\chset{\pgfqkeys{/ch}}
\chset{name/.initial=chp, total/.initial=4, outer macro/.initial=\outerPoints,
  inner macro/.initial=\innerPoints,
  @prepare coordinates/.code={\advance\pgfutil@tempcnta1
    \pgfcoordinate{ConvexHullPoint-\the\pgfutil@tempcnta}
      {\tikz@scan@one@point\pgfutil@firstofone#1\relax}},
  coordinates/.code={\pgfutil@tempcnta=0
    \pgfkeysalso{
      /ch/@prepare coordinates/.list={#1},
      /ch/name=ConvexHullPoint,
      /ch/total/.expanded=\the\pgfutil@tempcnta}}}
\newcommand*\chvof[1]{\pgfkeysvalueof{/ch/#1}}
\newcommand*\ConvexHull[1][]{%
  \begingroup\chset{#1}%
    %% Get the lowest left point
    % \CH@Ai stores ID, \CH@Axy stores x, y, \CH@Apoint expands to PGF-point
    \def\CH@Ai{0}\pgf@ya=16000pt \pgf@xa=16000pt
    \pgfmathloop
      \pgf@process{\pgfpointanchor{\chvof{name}-\pgfmathcounter}{center}}%
      \ifdim\pgf@y<\pgf@ya
        \let\CH@Ai\pgfmathcounter \pgf@xa=\pgf@x \pgf@ya=\pgf@y
      \else
        \ifdim\pgf@y=\pgf@ya
          \ifdim\pgf@x<\pgf@xa
            \let\CH@Ai\pgfmathcounter \pgf@xa=\pgf@x \pgf@ya=\pgf@y
          \fi
        \fi
      \fi
    \ifnum\pgfmathcounter<\chvof{total}\relax
    \repeatpgfmathloop
    \edef\CH@Axy{{\the\pgf@xa}{\the\pgf@ya}}%
    \edef\CH@Apoint{\noexpand\pgfqpoint\CH@Axy}%
    %% Build list of points sorted after angle from lowest left point
    % \CH@list will contain stack of (ID, angle, x, y) in TeX groups
    \let\CH@list\pgfutil@empty
    \pgfmathloop
      \ifnum\pgfmathcounter=\CH@Ai\else
        \pgfextract@process\CH@p{\pgfpointanchor{\chvof{name}-\pgfmathcounter}{center}}
        \edef\pgf@tempa{{\the\pgf@x}{\the\pgf@y}}%
        \pgfmathanglebetweenpoints{\CH@Apoint}{\CH@p}%
        \edef\CH@element{{\pgfmathcounter}{\pgfmathresult}}%
        \let\CH@angle\pgfmathresult
        \edef\CH@element{\CH@element\pgf@tempa}%
        \ifx\CH@list\pgfutil@empty
          \let\CH@list\CH@element
        \else
          \let\CH@lista\pgfutil@empty
          \expandafter\CH@sortin\CH@list\@@{}{}{}%
          \let\CH@list\CH@lista
        \fi
      \fi
    \ifnum\pgfmathcounter<\chvof{total}\relax
    \repeatpgfmathloop
    %% Drop points on the inner side.
    % This tests if point[i] is on the right of line through point[i-1] and point[i+1]
    % \CH@listb will contain list of outer points (reverse stack)
    % \CH@listc will contain list of inner points
    \edef\CH@listb{{\CH@Ai}{}\CH@Axy}%
    \let\CH@listc\pgfutil@gobble
    \expandafter\CH@store\CH@list\CH@stop\CH@Ti\CH@Txy\CH@list
    \pgfmathloop
      \expandafter\CH@store\CH@list\CH@stop\CH@Bi\CH@Bxy\CH@list
      \edef\pgf@marshall{\noexpand\CHtestforLeftOrRight\CH@Axy\CH@Bxy\CH@Txy}%
      \pgf@marshall
%      \errmessage{\CH@Ai, \CH@Ti, \CH@Bi; \pgfmathresult; \CH@Axy, \CH@Txy, \CH@Bxy}%
      \ifnum\pgfmathresult=-1 % to the right
        % woho, add point[i] to the outer list and push everything one down
        \edef\CH@listb{{\CH@Ti}{}\CH@Txy\CH@listb}%
        \let\CH@Ai\CH@Ti
        \let\CH@Axy\CH@Txy
        \let\CH@Ti\CH@Bi
        \let\CH@Txy\CH@Bxy
      \else % otherwise
        % ugh, insert point[i+1] back into the source list
        % so that it will be point[i+1] in the next iteration and push everything one up
        \edef\CH@listc{\CH@listc,\CH@Ti}%
        \edef\CH@list{{\CH@Bi}{}\CH@Bxy\CH@list}%
        \expandafter\CH@testforfirst\CH@listb\CH@stop\CH@Ti\CH@listb
        \expandafter\CH@store\CH@listb\CH@stop\CH@Ti\CH@Txy\CH@listb
        \expandafter\CH@store\CH@listb\CH@stop\CH@Ai\CH@Axy\CH@listb
        \edef\CH@listb{{\CH@Ai}{}\CH@Axy\CH@listb}%
      \fi
    \ifx\CH@list\pgfutil@empty % Before we finish, add the lastConvexHullPoint entry
      \edef\CH@listb{{\CH@Bi}{}\CH@Bxy\CH@listb}%
    \else
    \repeatpgfmathloop
    %% Alright lets pull only the IDs from \CH@listb and add to "outer" in reverse order
    \pgfkeysgetvalue{/ch/outer macro}\CH@outer \pgfkeysgetvalue{/ch/inner macro}\CH@inner
    \expandafter\let\CH@outer\pgfutil@empty
    \pgfmathloop
      \expandafter\CH@store\CH@listb\CH@stop\CH@Ai\CH@Axy\CH@listb
      \expandafter\ifx\CH@outer\pgfutil@empty
        \expandafter\edef\CH@outer{\CH@Ai}%
      \else\expandafter\edef\CH@outer{\CH@Ai,\CH@outer}\fi
    \ifx\CH@listb\pgfutil@empty\else
    \repeatpgfmathloop
    % get "outer" and \CH@listc (in the form of "inner") outside the group
    \ifx\CH@listc\pgfutil@gobble\let\CH@listc\pgfutil@empty\fi
    \xdef\pgf@marshall{\def\expandafter\noexpand\CH@outer{\CH@outer}%
      \def\expandafter\noexpand\CH@inner{\CH@listc}}%
  \endgroup
  \pgf@marshall}
\newcommand*\CH@sortin[4]{%
  \ifx\@@#1%
    \edef\CH@lista{\CH@lista\CH@element}%
    \expandafter\pgfutil@gobble
  \else
    \expandafter\pgfutil@firstofone
  \fi{%
    \ifdim#2pt<\CH@angle pt
      \edef\CH@lista{\CH@lista{#1}{#2}{#3}{#4}}\expandafter\CH@sortin
    \else
      \edef\CH@lista{\CH@lista\CH@element{#1}{#2}{#3}{#4}}\expandafter\CH@addLeftover
    \fi}}
\newcommand*\CHtestforLeftOrRight[6]{%
  \begingroup
    \dimen6=#6 \advance\dimen6-#2 % (#6-#2)
    \dimen3=#3 \advance\dimen3-#1 % (#3-#1)
    \dimen5=#5 \advance\dimen5-#1 % (#5-#1)
    \dimen4=#4 \advance\dimen4-#2 % (#4-#2)
    % numbers too big, scale everything down
    \dimen6=.1\dimen6 \dimen3=.1\dimen3
    \dimen5=.1\dimen5 \dimen4=-.1\dimen4
    \pgf@x=\pgf@sys@tonumber{\dimen5}\dimen4        % - (#5-#1)(#4-#2)
    \advance\pgf@x\pgf@sys@tonumber{\dimen3}\dimen6 % add (#3-#1)(#6-#2)
    \pgfmath@returnone\pgf@x\endgroup
%  \pgfmathparse{(#3-#1)(#6-#2)-(#5-#1)(#4-#2)}%
  \ifdim\pgfmathresult pt<0pt \def\pgfmathresult{-1}%
  \else\ifdim\pgfmathresult pt>0pt \def\pgfmathresult{1}%
    \else\def\pgfmathresult{0}\fi\fi}
\def\CH@addLeftover#1\@@#2#3#4{\edef\CH@lista{\CH@lista#1}}
\def\CH@store#1#2#3#4#5\CH@stop#6#7#8{\edef#6{#1}\edef#7{{#3}{#4}}\edef#8{#5}}
\def\CH@testforfirst#1#2#3#4#5\CH@stop#6#7{\ifnum#1=#6 \edef#7{#5}\fi}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		Global variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\definecolor{xg-fg}{rgb}{0, 0, 0}
\definecolor{xg-bg}{rgb}{1, 1, 1}
\colorlet{player0}{xg-fg}
\colorlet{event}{xg-fg!50!}
\colorlet{debug@bgt}{xg-fg!20!}
%
\newcommand{\setplayercolors}[3][1]{%
	\setsepchar{;}%
	\readlist*\colors@bgt{#3}%
	\foreach \i@bgt in {1, ..., \colors@bgtlen}{%
		\itemtomacro\colors@bgt[\i@bgt]\thiscolor@bgt%
		\pgfmathtruncatemacro{\k@bgt}{\i@bgt+#1-1}
		\edef\clrname@bgt{player\k@bgt}%
		\def\temp{\expandafter\xglobal\expandafter\definecolor\expandafter{\clrname@bgt}{#2}}%
		\expandafter\temp\expandafter{\thiscolor@bgt}%
	}%
}
\newcommand{\letplayercolors}[2][1]{%
	\setsepchar{,}%
	\readlist*\colors@bgt{#2}%
	\foreach \i@bgt in {1, ..., \colors@bgtlen}{%
		\itemtomacro\colors@bgt[\i@bgt]\thiscolor@bgt%
		\pgfmathtruncatemacro{\k@bgt}{\i@bgt+#1-1}
		\edef\clrname@bgt{player\k@bgt}%
		\def\temp{\expandafter\xglobal\expandafter\colorlet\expandafter{\clrname@bgt}}%
		\expandafter\temp\expandafter{\thiscolor@bgt}%
	}%
}
%
\setplayercolors{rgb}{0.7, 0.625, 0.1; % 1f85c2
					 0.12, 0.52, 0.76; % 00b300
					 0, 0.6, 0; % 009900. my original choice 0.7 wasn't great for color blind people
					 0.612, 0.063, 0.012} % 9c1003
\letplayercolors[5]{xg-fg, xg-fg, xg-fg, xg-fg, xg-fg}
%
\newcounter{activeplayer@bgt}
\newif\iftree@labels@short@def
\newif\iftree@labels@short@bgt
%
% Tree-like structure:
% - linewidth
%    - nodelinewidth
%       - state@linewidth
%       - atm@linewidth
%    - edgelinewidth
%      - informsetlinewidth
%	   - treelinewidth
%
\newlength{\templength@bgt}
\newlength{\nodelinewidth@bgt}
\newlength{\edgelinewidth@bgt}
\@ifclassloaded{beamer}{
	\setlength{\nodelinewidth@bgt}{0.8pt}
	\setlength{\edgelinewidth@bgt}{0.8pt}
}{
	\setlength{\nodelinewidth@bgt}{1pt}
	\setlength{\edgelinewidth@bgt}{1pt}
}
%
% - fontsize
%    - labelfontsize
%       - state@font
%       - atm@font
%       - tree@font
%          - infset@font
%          - node@font
%    - matrix@font
%
\let\labelfontsize\small
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			Package options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newif\ifpassoptionstotikz@bgt
\newif\ifdraft@bgt
\newif\ifcontrast@bgt
\newif\ifapchoice@bgt
\newif\ifexternal@bgt
\newif\ifnonode@bgt
\DeclareOption{passtotikz}{\passoptionstotikz@bgttrue}
\DeclareOption{ap}{\apchoice@bgttrue}
\DeclareOption{nonode}{\nonode@bgttrue}
\DeclareOption{external}{\external@bgttrue}
\DeclareOption{draft}{\draft@bgttrue}
\DeclareOption{nodraft}{\draft@bgtfalse}
\DeclareOption{metropolis}{
	\definecolor{xg-fg}{HTML}{23373b}
	\colorlet{xg-bg}{black!2!}
	\colorlet{player0}{xg-fg}
	\colorlet{event}{xg-fg!50!}
}
\DeclareOption{contrast}{
	% Changes main colors to black and white
	\definecolor{xg-fg}{rgb}{0, 0, 0}
	\definecolor{xg-bg}{rgb}{1, 1, 1}
	\colorlet{event}{xg-fg!50!}
	% Don't colorize text commands and matrices
	\contrast@bgttrue
}
\DeclareOption{greyscale}{
	% Changes main colors to black and white
	\definecolor{xg-fg}{rgb}{0, 0, 0}
	\definecolor{xg-bg}{rgb}{1, 1, 1}
	\colorlet{player1}{black!40!}
	\colorlet{player2}{black!60!}
	\colorlet{player3}{black!85!}
	\colorlet{player4}{black}
	\colorlet{event}{xg-fg}
	% Don't colorize text commands and matrices
	\contrast@bgttrue
}
\DeclareOption{backward}{
	\def\rowclr#1{{\color{player1} #1}}
	\def\colclr#1{{\color{player2} #1}}
	\def\thirdclr#1{{\color{player3} #1}}
	\def\fourthclr#1{{\color{player4} #1}}
	\def\eventclr#1{{\color{event} #1}}
	%
	\def\rowset#1{\plset{1}{#1}}
	\def\colset#1{\plset{2}{#1}}
	\def\thirdset#1{\plset{3}{#1}}
	\def\fourthset#1{\plset{4}{#1}}
}
%\DeclareOption*{\PackageWarning{xgames}{Unknown ‘\CurrentOption’}}
\ProcessOptions\relax
% Enable externalization support in fikz
\ifexternal@bgt
	\RequirePackage{environ}
	% Check if it has been activated by some other package already
	\ifexternal@fikz\else
		\externalizetikz
	\fi
\fi
\ifdraft@bgt
	% Changes main colors to black and white
	\definecolor{xg-fg}{rgb}{0, 0, 0}
	\definecolor{xg-bg}{rgb}{1, 1, 1}
	\colorlet{event}{xg-fg!50!}
	% Don't colorize text commands
	\contrast@bgttrue
	\nonode@bgttrue
	\def\contour#1#2{#2}
	\def\gobbleoverlay@bgt#1<#2>{
		\def\overlay@bgt{}
		\expandafter#1
	}
\fi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     1. Text commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     1.1 Player names 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Gobble first token of a string
\def\gobble@bgt#1#2\empty@bgt{#1}
\def\firsttoken@bgt#1{\gobble@bgt#1\empty@bgt}
\def\gobble@second@bgt#1#2#3\empty@bgt{#2}
\def\secondtoken@bgt#1{\gobble@second@bgt#1\empty@bgt}
%
% Define default values for player names. Maximum may be package option
\newcounter{iterator@bgt}%
\def\resetplayernames{%
	\def\playername@bgt{Nature}%
	\def\playerinitial@bgt{0}%
	\foreach \it@bgt in {1, ..., 9} {%
		\stepcounter{iterator@bgt}%
		\expandafter\xdef\csname playername\romannumeral\it@bgt @bgt\endcsname{Player~\it@bgt}%
		\expandafter\xdef\csname playerinitial\romannumeral\it@bgt @bgt\endcsname{\it@bgt}%
	}%
}
\resetplayernames
%
% User-level commands to set the player's names
\long\def\setplayername#1#2{%
	\expandafter\xdef\csname playername\romannumeral#1@bgt\endcsname{#2}%
	\expandafter\xdef\csname playerinitial\romannumeral#1@bgt\endcsname{\expandafter\firsttoken@bgt\expandafter{#2}}%
	\ignorespaces
}
\newcommand{\setplayernames}[2][1]{%
	\setcounter{iterator@bgt}{#1}%
	\foreach \i@bgt in {#2}{%
		\setplayername{\value{iterator@bgt}}{\i@bgt}%
		\stepcounter{iterator@bgt}%
	}%
	\ignorespaces
}
\def\setplayerinitials#1{%
	\setsepchar{,}%
	\readlist*\initialslist@bgt{#1}%
	\foreach \i@bgt in {1, ..., \initialslist@bgtlen} {%
		\itemtomacro\initialslist@bgt[\i@bgt]\temp@bgt%
		\expandafter\xdef\csname playerinitial\romannumeral\i@bgt @bgt\endcsname{\temp@bgt}%
	}%
}
\def\getplayerinitial@bgt#1{\csname playerinitial\romannumeral#1@bgt\endcsname}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     1.2 Display text in a player's color 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Display text in the active player's color. Default is the active player's name.
\ifcontrast@bgt
	\def\playercolor@bgt#1#2{#2}
	\def\ev#1{#1}
\else
	\def\playercolor@bgt#1#2{{\color{player#1}#2}}
	\def\ev#1{{\color{event}#1}}
\fi
% User-level command to display a player's name / something in a player's color
% Used to set activeplayer@bgt coutner rather than iterator@bgt
%\ifcontrast@bgt
%	\def\activeplayer@bgt#1{\ifempty@bgt{#1}{\csname playername\roman{iterator@bgt}@bgt\endcsname}{#1}}
%	\long\def\pl#1{\futurelet\pl@bgtNext\pl@bgtCheck}
%\else
	\def\activeplayer@bgt#1{%
		\ifempty@bgt{#1}{%
			\xdef\temp{\csname playername\roman{iterator@bgt}@bgt\endcsname}%
		}{%
			\def\temp{#1}%
		}%
		\playercolor@bgt{\the\value{iterator@bgt}}{\temp}%
	}
	\long\def\pl#1{%
		\setcounter{iterator@bgt}{#1}%
		\futurelet\pl@bgtNext\pl@bgtCheck%
	}
%\fi
%
\def\pl@bgtCheck{%
	\ifx\pl@bgtNext\bgroup%
		\expandafter\activeplayer@bgt%
	\else%
		\activeplayer@bgt{}%
	\fi%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     1.3 Player variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% One could consider using \pl for internal consistency and ease of code maintenace.
% It will be slightly slower though.
\newif\ifdefvar@sticky@bgt
\newif\ifdefvar@prime@bgt
\newif\ifdefvar@hat@bgt
\newif\ifdefvar@singleton@bgt
\def\defined@var@bgt{}
%
\newif\ifmultivar@sticky@bgt
\multivar@sticky@bgtfalse
\def\multivar@index@bgt{}
\def\multivar@prefix@bgt{}
\newif\ifmultivar@prime@bgt
\newif\ifmultivar@hat@bgt
%
\ifcontrast@bgt
	\def\defvar@bgt#1#2#3{%
		\expandafter\gdef\csname#2\endcsname{#3}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\defvar@prefix@bgt} {%
        	\expandafter\append@bgt\expandafter\defined@var@bgt\expandafter{\expandafter#2\item@bgt}%
			\expandafter\xdef\csname#2\item@bgt\endcsname{{\expandafter\noexpand\csname\item@bgt\endcsname{\noexpand#3}}}%
		}%
	}
	\def\multidef@aux@bgt#1#2#3{%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}
		}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidef@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{##2_{##1,##3}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
			\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				#2_{##1}%
			}%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidef@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefnone@aux@bgt#1#2#3{%
		\expandafter\xdef\csname#1#3\endcsname##1{{\expandafter\noexpand\csname#3\endcsname{\noexpand#2}}}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefnone@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{##2_{##3}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
			\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				#2%
			}%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidefnone@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefinitial@aux@bgt#1#2#3{%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\noexpand\ifnum##1=0%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}
			\noexpand\else%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{\noexpand\getplayerinitial@bgt{##1}}
			\noexpand\fi%
		}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefinitial@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{##2_{\getplayerinitial@bgt{##1},##3}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
			\ifnum##1=0%
				#2%
			\else%
				\@ifnextchar_{%
					\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
				}{%
					#2_{\getplayerinitial@bgt{##1}}%
				}%
			\fi%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidef@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefplayersonly@aux@bgt#1#2#3{%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\noexpand\ifnum##1=0%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}
			\noexpand\else%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}
			\noexpand\fi%
		}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefplayersonly@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{##2_{##1,##3}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
			\ifnum##1=0%
				#2%
			\else%
				\@ifnextchar_{%
					\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
				}{%
					#2_{##1}%
				}%
			\fi%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidef@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
\else
	\def\defvar@bgt#1#2#3{%
		% #1: player number
		% #2: name of command sequence to be defined (without \)
		% #3: text to be typeset
		% for the sake of compilation speed, ifs are outside
		%
		% subscript
		\expandafter\gdef\csname#2@sub\endcsname##1_##2{%
			\@ifnextchar^{%
				\expandonce@bgt{\csname#2@super\endcsname}{##1_{##2}}%
			}{%
				\@ifnextchar'{\expandonce@bgt{\csname#2@prime\endcsname}{##1_{##2}}}{{\color{player#1}##1_{##2}}}%
		}}%
		\append@bgt\defined@var@bgt{#2@sub}%
		% superscript
		\ifdefvar@hat@bgt%
			\expandafter\gdef\csname#2@super\endcsname##1^##2{%
				\@ifnextchar_{\expandonce@bgt{\csname#2@sub\endcsname}{##1^{##2}}}{{\color{player#1}##1^{##2}}}%
			}%
		\else%
			\expandafter\gdef\csname#2@super\endcsname##1^##2{%
				\colorlet{curr@color@bgt}{.}%
				\@ifnextchar_{\expandonce@bgt{\csname#2@sub\endcsname}{##1^{{\color{curr@color@bgt}##2}}}}{{\color{player#1}##1^{{\color{curr@color@bgt}##2}}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#2@super}%
		% prime
		\ifdefvar@prime@bgt%
			\expandafter\gdef\csname#2@prime\endcsname##1'{%
				{\color{player#1}##1'}%
			}%
		\else%
			\expandafter\gdef\csname#2@prime\endcsname##1'{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player#1}##1^{{\color{curr@color@bgt}\prime}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#2@prime}%
		% general command
		\expandafter\gdef\csname#2\endcsname{%
			\@ifnextchar_{%
				\expandonce@bgt{\csname#2@sub\endcsname}{#3}%
			}{%
				\@ifnextchar^{%
					\expandonce@bgt{\csname#2@super\endcsname}{#3}%
				}{%
					\@ifnextchar'{%
						\expandonce@bgt{\csname#2@prime\endcsname}{#3}%
					}{%
						{\color{player#1}#3}%
		}}}}%
		% prefix commands
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\defvar@prefix@bgt} {%
        	\expandafter\append@bgt\expandafter\defined@var@bgt\expandafter{\expandafter#2\item@bgt}%
			\expandafter\xdef\csname#2\item@bgt\endcsname{{\noexpand\color{player#1}\expandafter\noexpand\csname\item@bgt\endcsname{\noexpand#3}}}%
		}%
	}
	\def\multidef@aux@bgt#1#2#3{%
		% superscript
		\expandafter\xdef\csname#1#3@super\endcsname##1^##2{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}^{{\noexpand\color{curr@color@bgt}##2}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@super}%
		% prime
		\expandafter\xdef\csname#1#3@prime\endcsname##1'{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}^{{\noexpand\color{curr@color@bgt}\prime}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@prime}%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\noexpand\@ifnextchar^{%
				\expandafter\noexpand\csname#1#3@super\endcsname{##1}%
			}{%
				\noexpand\@ifnextchar'{%
					\expandafter\noexpand\csname#1#3@prime\endcsname{##1}%
				}{%
					{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}}
		}}}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidef@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{%
			\@ifnextchar^{%
				\expandonce@bgt{\csname#1@super\endcsname}##1{##2_{##1,##3}}%
			}{%
				\@ifnextchar'{\expandonce@bgt{\csname#1@prime\endcsname}##1{##2_{##1,##3}}}{{\color{player##1}##2_{##1,##3}}}%
		}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% superscripts
		\ifmultivar@hat@bgt%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				{\color{player##1}##2^{##3}}%
			}%
		\else%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}##3}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@super}%
		% prime
		\ifmultivar@prime@bgt%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{{\color{player##1}##2'}}%
		\else%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}\prime}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@prime}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
		\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				\@ifnextchar^{%
					\expandonce@bgt{\csname#1@super\endcsname}##1{#2_{##1}}%
				}{%
					\@ifnextchar'{%
						\expandonce@bgt{\csname#1@prime\endcsname}##1{#2_{##1}}%
					}{%
						{\color{player##1}#2_{##1}}%
		}}}}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidef@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefnone@aux@bgt#1#2#3{%
		\expandafter\xdef\csname#1#3\endcsname##1{{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}}}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefnone@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{%
			\@ifnextchar^{%
				\expandonce@bgt{\csname#1@super\endcsname}##1{##2_{##3}}%
			}{%
				\@ifnextchar'{\expandonce@bgt{\csname#1@prime\endcsname}##1{##2_{##3}}}{{\color{player##1}##2_{##3}}}%
		}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% superscripts
		\ifmultivar@hat@bgt%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				{\color{player##1}##2^{##3}}%
			}%
		\else%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}##3}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@super}%
		% prime
		\ifmultivar@prime@bgt%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{{\color{player##1}##2'}}%
		\else%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}\prime}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@prime}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
		\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				\@ifnextchar^{%
					\expandonce@bgt{\csname#1@super\endcsname}##1{#2}%
				}{%
					\@ifnextchar'{%
						\expandonce@bgt{\csname#1@prime\endcsname}##1{#2}%
					}{%
						{\color{player##1}#2}%
		}}}}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidefnone@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefinitial@aux@bgt#1#2#3{%
		% superscript
		\expandafter\xdef\csname#1#3@super\endcsname##1^##2{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{\noexpand\getplayerinitial@bgt{##1}}^{{\noexpand\color{curr@color@bgt}##2}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@super}%
		% prime
		\expandafter\xdef\csname#1#3@prime\endcsname##1'{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{\noexpand\getplayerinitial@bgt{##1}}^{{\noexpand\color{curr@color@bgt}\prime}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@prime}%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\noexpand\ifnum##1=0\noexpand\relax%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}%
			\noexpand\else%
				\noexpand\@ifnextchar^{%
					\expandafter\noexpand\csname#1#3@super\endcsname{##1}%
				}{%
					\noexpand\@ifnextchar'{%
						\expandafter\noexpand\csname#1#3@prime\endcsname{##1}%
					}{%
						{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{\noexpand\getplayerinitial@bgt{##1}}}
				}}%
			\fi%
		}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefinitial@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{%
			\@ifnextchar^{%
				\expandonce@bgt{\csname#1@super\endcsname}##1{##2_{\getplayerinitial@bgt{##1},##3}}%
			}{%
				\@ifnextchar'{\expandonce@bgt{\csname#1@prime\endcsname}##1{##2_{\noexpand\getplayerinitial@bgt{##1},##3}}}{{\color{player##1}##2_{\getplayerinitial@bgt{##1},##3}}}%
		}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% superscripts
		\ifmultivar@hat@bgt%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				{\color{player##1}##2^{##3}}%
			}%
		\else%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}##3}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@super}%
		% prime
		\ifmultivar@prime@bgt%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{{\color{player##1}##2'}}%
		\else%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}\prime}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@prime}%
		% need to define separate lookahead function because \@ifnextchar can't appear inside \if \else statement: the next char would be \fi.
		\expandafter\gdef\csname#1@lookahead\endcsname##1{
			\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				\@ifnextchar^{%
					\expandonce@bgt{\csname#1@super\endcsname}##1{#2_{\getplayerinitial@bgt{##1}}}%
				}{%
					\@ifnextchar'{%
						\expandonce@bgt{\csname#1@prime\endcsname}##1{#2_{\getplayerinitial@bgt{##1}}}%
					}{%
						{\color{player##1}#2_{\getplayerinitial@bgt{##1}}}%
		}}}}%
		\append@bgt\defined@var@bgt{#1@lookahead}%
		% general command
		\expandafter\gdef\csname#1\endcsname##1{%
			\ifnum##1=0\relax%
				#2%
				\expandafter\def\csname#1@next\endcsname##1{}%
			\else%	
				\expandafter\let\csname#1@next\expandafter\endcsname\csname#1@lookahead\endcsname%
			\fi%
			\csname#1@next\endcsname##1%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidefinitial@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
	\def\multidefplayersonly@aux@bgt#1#2#3{%
		% superscript, only called for non-zero player number
		\expandafter\xdef\csname#1#3@super\endcsname##1^##2{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}^{{\noexpand\color{curr@color@bgt}##2}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@super}%
		% prime, only called for non-zero player number
		\expandafter\xdef\csname#1#3@prime\endcsname##1'{%
			\noexpand\colorlet{curr@color@bgt}{.}%
			{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}^{{\noexpand\color{curr@color@bgt}\prime}}}
		}%
		\append@bgt\defined@var@bgt{#1#3@prime}%
  	 	% general command
		\expandafter\xdef\csname#1#3\endcsname##1{%
			\noexpand\ifnum##1=0\noexpand\relax%
				\expandafter\noexpand\csname#3\endcsname{\noexpand#2}%
			\noexpand\else%
				\noexpand\@ifnextchar^{%
					\expandafter\noexpand\csname#1#3@super\endcsname{##1}%
				}{%
					\noexpand\@ifnextchar'{%
						\expandafter\noexpand\csname#1#3@prime\endcsname{##1}%
					}{%
						{\noexpand\color{player##1}\expandafter\noexpand\csname#3\endcsname{\noexpand#2}_{##1}}
			}}%
			\noexpand\fi%
		}%
  	 	\append@bgt\defined@var@bgt{#1#3}%
	}%
	\def\multidefplayersonly@bgt#1#2{%
		% for the sake of compilation speed, ifs are outside
		% subscript, only called for non-zero player number
		\expandafter\gdef\csname#1@sub\endcsname##1##2_##3{%
			\@ifnextchar^{%
				\expandonce@bgt{\csname#1@super\endcsname}##1{##2_{##1,##3}}%
			}{%
				\@ifnextchar'{\expandonce@bgt{\csname#1@prime\endcsname}##1{##2_{##1,##3}}}{{\color{player##1}##2_{##1,##3}}}%
		}}%
		\append@bgt\defined@var@bgt{#1@sub}%
		% superscripts, only called for non-zero player number
		\ifmultivar@hat@bgt%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				{\color{player##1}##2^{##3}}%
			}%
		\else%
			\expandafter\gdef\csname#1@super\endcsname##1##2^##3{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}##3}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@super}%
		% prime, only called for non-zero player number
		\ifmultivar@prime@bgt%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{{\color{player##1}##2'}}%
		\else%
			\expandafter\gdef\csname#1@prime\endcsname##1##2'{%
				\colorlet{curr@color@bgt}{.}%
				{\color{player##1}##2^{{\color{curr@color@bgt}\prime}}}%
			}%
		\fi%
		\append@bgt\defined@var@bgt{#1@prime}%
		% need to define separate lookahead function because \@ifnextchar can't appear inside \if \else statement: the next char would be \fi.
		\expandafter\gdef\csname#1@lookahead\endcsname##1{
			\@ifnextchar_{%
				\expandonce@bgt{\csname#1@sub\endcsname}##1{#2}%
			}{%
				\@ifnextchar^{%
					\expandonce@bgt{\csname#1@super\endcsname}##1{#2_{##1}}%
				}{%
					\@ifnextchar'{%
						\expandonce@bgt{\csname#1@prime\endcsname}##1{#2_{##1}}%
					}{%
						{\color{player##1}#2_{##1}}%
		}}}}%
		\append@bgt\defined@var@bgt{#1@lookahead}%
		% general command, only called for non-zero player number
		\expandafter\gdef\csname#1\endcsname##1{%
			\ifnum##1=0\relax%
				#2%
				\expandafter\def\csname#1@next\endcsname##1{}%
			\else%	
				\expandafter\let\csname#1@next\expandafter\endcsname\csname#1@lookahead\endcsname%
			\fi%
			\csname#1@next\endcsname##1%
		}%
		% prefix commands
		\append@bgt\defined@var@bgt{#1}%
		\def\temp@b{\foreach \item@bgt in}%
		\expandafter\temp@b\expandafter{\multivar@prefix@bgt} {%
			\multidefplayersonly@aux@bgt{#1}{#2}{\item@bgt}%
  	 	}%
	}
\fi
%
% The following two macros are due to egreg, taken from https://tex.stackexchange.com/questions/42318/removing-a-backslash-from-a-character-sequence
\def\removebs@bgt#1{\if#1\@backslashchar\else#1\fi}
\def\macroname@bgt#1{\xdef\name@bgt{\expandafter\removebs@bgt\string#1}}
%
% Steven B. Segletes kindly helped me learn Latex expansion with his answer here https://tex.stackexchange.com/a/591508/203616
\define@key{defvar@bgt}{player}{\def\defvar@player@bgt{#1}}
\define@key{defvar@bgt}{sticky}{\defvar@sticky@bgttrue}
\define@key{defvar@bgt}{prefix}{\def\defvar@prefix@bgt{#1}}
\define@key{defvar@bgt}{postfix}{\foreach \i@bgt in {#1} {\ifstreq@bgt{\i@bgt}{'}{\global\defvar@prime@bgttrue}{\ifstreq@bgt{\i@bgt}{^}{\global\defvar@hat@bgttrue}}}}
%
\long\def\definevar@opt[#1]#2{%
	% set default and parse options
	\ifdefvar@sticky@bgt\else%
		\def\defvar@prefix@bgt{}%
		\defvar@prime@bgtfalse%
		\defvar@hat@bgtfalse%
		\defvar@singleton@bgtfalse%
		\def\defvar@player@bgt{1}%
	\fi%
	\setkeys{defvar@bgt}{#1}%
	% read input
    \setsepchar{;/,/->}%
    \readlist*\varlist@bgt{#2}%
    \ifnum\varlist@bgtlen=1% Need to treat this case separately for some reason
    	\ifnum\listlen\varlist@bgt[1]=1%
   			\readlist*\varlist@bgt{#2, @bgt}% not elegant but effective
   			\global\defvar@singleton@bgttrue%
    \fi\fi%
    \foreach \k@bgt in {1, ..., \varlist@bgtlen} {%
    	\expandafter\ifstrempty@bgt\expandafter{\varlist@bgt[\k@bgt]}{}{%
    		\pgfmathtruncatemacro{\pl@bgt}{\defvar@player@bgt+\k@bgt-1}%
    		\ifdefvar@singleton@bgt%
				\pgfmathtruncatemacro{\n@bgt}{\listlen\varlist@bgt[\k@bgt]-1}%
    		\else%
				\pgfmathtruncatemacro{\n@bgt}{\listlen\varlist@bgt[\k@bgt]}%
    		\fi%
			\foreach \i@bgt in {1, ..., \n@bgt} {%
				% process input
				\itemtomacro\varlist@bgt[\k@bgt, \i@bgt, 1]\j@bgt%
				\expandafter\macroname@bgt\expandafter{\j@bgt}%
				\expandafter\append@bgt\expandafter\defined@var@bgt\expandafter{\name@bgt}%
				\@ifundefined{\name@bgt}{}{%
					\expandafter\global\expandafter\let\csname\name@bgt @bgtsaved\expandafter\endcsname\csname\name@bgt\endcsname%
  				}%
  				\ifnum\listlen\varlist@bgt[\k@bgt, \i@bgt]>1%
					\itemtomacro\varlist@bgt[\k@bgt, \i@bgt, 2]\target@bgt%
					\edef\temp@a{{\pl@bgt}{\name@bgt}{\expandafter\noexpand\target@bgt}}%
					\expandafter\defvar@bgt\temp@a%
				\else%
					\expandafter\ifcmd@bgt\expandafter{\j@bgt}{%
						\edef\temp@a{{\pl@bgt}{\name@bgt}{\expandafter\noexpand\csname\name@bgt @bgtsaved\endcsname}}%
						\expandafter\defvar@bgt\temp@a%
					}{%
						\edef\temp@a{{\pl@bgt}{\name@bgt}{\j@bgt}}%
						\expandafter\defvar@bgt\temp@a%
					}%
				\fi%
	}}}%
	\ignorespaces
}%
\def\definevar{\@ifnextchar[{\definevar@opt}{\definevar@opt[]}}
%
% Option for multivar
\define@key{multivar@bgt}{prefix}{\def\multivar@prefix@bgt{#1}}
\define@key{multivar@bgt}{postfix}{\foreach \i@bgt in {#1} {\ifstreq@bgt{\i@bgt}{'}{\global\multivar@prime@bgttrue}{\ifstreq@bgt{\i@bgt}{^}{\global\multivar@hat@bgttrue}}}}
\define@key{multivar@bgt}{sticky}[true]{\ifstreq@bgt{#1}{true}{\multivar@sticky@bgttrue}{\multivar@sticky@bgtfalse}}
\define@key{multivar@bgt}{index}{\ifstreq@bgt{#1}{none}{\def\multivar@index@bgt{none}}{\ifstreq@bgt{#1}{initial}{\def\multivar@index@bgt{initial}}{\ifstreq@bgt{#1}{players only}{\def\multivar@index@bgt{playersonly}}{\def\multivar@index@bgt{}}}}}
%
\def\reset@multivarkeys@bgt{%
	\ifmultivar@sticky@bgt\else%
		\def\multivar@index@bgt{}%
		\def\multivar@prefix@bgt{}%
		\multivar@prime@bgtfalse%
		\multivar@hat@bgtfalse%
	\fi%
}
\def\multivar@opt[#1]#2{%
	\reset@multivarkeys@bgt%
	\defvar@singleton@bgtfalse%
	\setkeys{multivar@bgt}{#1}%
    \setsepchar{,/->}%
    \readlist*\varlist@bgt{#2}%
    \ifnum\varlist@bgtlen=1% Need to treat this case separately for some reason
   			\readlist*\varlist@bgt{#2, @bgt}% not elegant but effective
   			\global\defvar@singleton@bgttrue%
    \fi%
    \ifdefvar@singleton@bgt%
		\pgfmathtruncatemacro{\n@bgt}{\varlist@bgtlen-1}%
    \else%
		\pgfmathtruncatemacro{\n@bgt}{\varlist@bgtlen}%
    \fi%
	\foreach \i@bgt in {1, ..., \n@bgt} {%
		% process input
		\itemtomacro\varlist@bgt[\i@bgt, 1]\j@bgt%
		\expandafter\macroname@bgt\expandafter{\j@bgt}%
%		\expandafter\append@bgt\expandafter\defined@var@bgt\expandafter{\name@bgt}%
		\@ifundefined{\name@bgt}{}{%
			\expandafter\global\expandafter\let\csname\name@bgt @bgtsaved\expandafter\endcsname\csname\name@bgt\endcsname%
		}%
		\ifnum\listlen\varlist@bgt[\i@bgt]>1\relax%
			\itemtomacro\varlist@bgt[\i@bgt, 2]\target@bgt%
			\edef\temp@a{{\name@bgt}{\expandafter\noexpand\target@bgt}}%
			\csname multidef\multivar@index@bgt @bgt\expandafter\endcsname\temp@a%
		\else%
			\expandafter\ifcmd@bgt\expandafter{\j@bgt}{%
				\edef\temp@a{{\name@bgt}{\expandafter\noexpand\csname\name@bgt @bgtsaved\endcsname}}%
				\csname multidef\multivar@index@bgt @bgt\expandafter\endcsname\temp@a%
			}{%
				\edef\temp@a{{\name@bgt}{\j@bgt}}%
				\csname multidef\multivar@index@bgt @bgt\expandafter\endcsname\temp@a%
			}%
		\fi%
	}%
%    \foreach \i@bgt in {#2} {%
%        \expandafter\macroname@bgt\expandafter{\i@bgt}%
%		\@ifundefined{\name@bgt}{}{%
%			\expandafter\global\expandafter\let\csname\name@bgt @bgtsaved\expandafter\endcsname\csname\name@bgt\endcsname%
 % 		}%
  %		\expandafter\ifcmd@bgt\expandafter{\i@bgt}{%
	%  		\edef\temp@a{{\name@bgt}{\expandafter\noexpand\csname\name@bgt @bgtsaved\endcsname}}%
  	%		\csname multidef\multivar@index@bgt @bgt\expandafter\endcsname\temp@a%
  	%	}{%
  	%		\edef\temp@a{{\i@bgt}{\i@bgt}}%
  	%		\csname multidef\multivar@index@bgt @bgt\expandafter\endcsname\temp@a%
  	%	}%
%    }%
    \ignorespaces
}
\def\multivar{\@ifnextchar[{\multivar@opt}{\multivar@opt[]}}
%
\newif\ifclear@var@bgt
\def\releasevar{\@ifnextchar\bgroup{\clear@var@bgttrue\@releasevar}{\clear@var@bgtfalse\expandafter\@releasevar\expandafter{\defined@var@bgt}}}
\def\@releasevar#1{%
    \foreach \i@bgt in {#1} {%
        \expandafter\macroname@bgt\expandafter{\i@bgt}%
        \ifclear@var@bgt%
        	\expandafter\gdef\csname\name@bgt @clear@bgt\endcsname{}%
        	\expandafter\gdef\csname\name@bgt @sub@clear@bgt\endcsname{}%
        	\expandafter\gdef\csname\name@bgt @super@clear@bgt\endcsname{}%
        	\expandafter\gdef\csname\name@bgt @prime@clear@bgt\endcsname{}%
  			\expandafter\global\expandafter\let\csname\name@bgt @sub\endcsname\undefined%
  			\expandafter\global\expandafter\let\csname\name@bgt @super\endcsname\undefined%
  			\expandafter\global\expandafter\let\csname\name@bgt @prime\endcsname\undefined%
        \fi%
		\@ifundefined{\name@bgt @bgtsaved}{%
			\expandafter\global\expandafter\let\csname\name@bgt\endcsname\undefined%
		}{%
			\def\temp{\expandafter\let\csname\name@bgt\endcsname}%
			\expandafter\global\expandafter\temp\csname\name@bgt @bgtsaved\endcsname%
			\expandafter\global\expandafter\let\csname\name@bgt @bgtsaved\endcsname\undefined%
  		}%
    }%
    \ifclear@var@bgt%
	    \def\temp@definedvar@bgt{}%
    	\def\temp@a{\foreach \i@bgt in }%
    	\expandafter\temp@a\expandafter{\defined@var@bgt} {%
    		\@ifundefined{\i@bgt @clear@bgt}{%
        		\expandafter\append@bgt\expandafter\temp@definedvar@bgt\expandafter{\i@bgt}%
    		}{%
    			\expandafter\global\expandafter\let\csname\i@bgt @clear@bgt\endcsname\undefined%
    		}%
    	}%
    	\global\let\defined@var@bgt\temp@definedvar@bgt%
    \else%
    	\gdef\defined@var@bgt{}%
    \fi%
}
%
% Best response correspondences
\ifcontrast@bgt
	\newcommand{\BR}[1][]{\ifempty@bgt{#1}{\mathcal{B}}{\mathcal{B}_{#1}}}
\else
	\newcommand{\BR}[1][]{\ifempty@bgt{#1}{\mathcal{B}}{\ifisnum@bgt{#1}{{\color{player#1}\mathcal{B}_{#1}}}{\mathcal{B}_{#1}}}}
\fi
%
% Disable coloring
\def\disablecolor{
	\colorlet{event@bgt}{event}
	\foreach \i@bgt in {0, ..., 9} {
		\edef\temp@a{player\i@bgt @bgt}
		\edef\temp@b{player\i@bgt}
		\def\temp{\expandafter\xglobal\expandafter\colorlet\expandafter{\temp@a}}
		\expandafter\temp\expandafter{\temp@b}
		\expandafter\xglobal\expandafter\colorlet\expandafter{\temp@b}{xg-fg}
	}
}
\def\enablecolor{
	\colorlet{event}{event@bgt}
	\foreach \i@bgt in {0, ..., 9} {
		\edef\temp@a{player\i@bgt @bgt}
		\edef\temp@b{player\i@bgt}
		\def\temp{\expandafter\xglobal\expandafter\colorlet\expandafter{\temp@b}}
		\expandafter\temp\expandafter{\temp@a}
	}
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	  1.4  Action profiles and payoffs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Coloring action profile or payoff tuple
% this implementation is 40% faster than with pgffor
\ifcontrast@bgt
	\def\colorize@bgt#1#2#3{#3}
	\long\def\colorizelist@bgt#1#2{#2}
	\long\def\colorizetextlist@bgt#1{%
	% #1: player number
	% assuming that the inputlist has been read already
		\text{\inputlist@bgt[1]}%
		\ifnum\inputlist@bgtlen>1%
			\foreach \i@bgt in {2, ..., \inputlist@bgtlen}{%
				, \text{\inputlist@bgt[\i@bgt]}%
			}%
		\fi%
	}
\else
	\def\colorize@bgt#1#2#3{%
		% #1: starting index of player color
		% #2: output separator
		% #3: input list
		\setsepchar{,}%
		\readlist*\inputlist@bgt{#3}%
		%
		\ifnum\inputlist@bgtlen=1%
			{\color{player0}#3}%
		\else%
			{\color{player#1}\inputlist@bgt[1]}%
			\foreach \i@bgt in {2, ..., \inputlist@bgtlen} {%
				\pgfmathtruncatemacro{\j@bgt}{\i@bgt+#1-1}%
				#2{\color{player\j@bgt}\inputlist@bgt[\i@bgt]}%
			}%
		\fi%
		%
	}
	%
	\long\def\colorizelist@bgt#1#2{%
	% #1: player number
	% #2: player's actions
		\setsepchar{,}%
		\readlist*\inputlist@bgt{#2}%
		%
		\ifnum\inputlist@bgtlen=1%
			{\color{#1}#2}%
		\else%
			{\color{#1}\inputlist@bgt[1]}%
			\foreach \i@bgt in {2, ..., \inputlist@bgtlen}{%
				, {\color{#1}\inputlist@bgt[\i@bgt]}%
			}%
		\fi%
	}
	\long\def\colorizetextlist@bgt#1{%
	% #1: player number
	% assuming that the inputlist has been read already
		\text{\color{#1}\inputlist@bgt[1]}%
		\ifnum\inputlist@bgtlen>1%
			\foreach \i@bgt in {2, ..., \inputlist@bgtlen}{%
				, \text{\color{#1}\inputlist@bgt[\i@bgt]}%
			}%
		\fi%
	}
\fi
%
% User-level commands
\newcommand{\apm}[2][,]{\colorize@bgt{1}{#1}{#2}}
\newcommand{\apsm}[2][,]{\colorize@bgt{0}{#1}{#2}}
%
\ifapchoice@bgt
	\newlength{\bheight@bgt}
	\newlength{\bbheight@bgt}
	\newlength{\Bheight@bgt}
	\newlength{\BBheight@bgt}
	\settoheight{\bheight@bgt}{$\big($}
	\settoheight{\bbheight@bgt}{$\bigg($}
	\settoheight{\Bheight@bgt}{$\Big($}
	\settoheight{\BBheight@bgt}{$\Bigg($}
	%
	\def\setdelim#1{%
		\settoheight{\labelheight@bgt}{$#1$}%
		\ifdim\labelheight@bgt<0.9\bheight@bgt%
			\gdef\lbdelim{}\gdef\rbdelim{}%
		\else%
			\global\let\lbdelim\bigl%
			\global\let\rbdelim\bigr%
		\fi%
		\settoheight{\labelheight@bgt}{$\displaystyle#1$}%
		\ifdim\labelheight@bgt<0.9\bheight@bgt%
			\gdef\ldelim{}\gdef\rdelim{}%
		\else\ifdim\labelheight@bgt<0.9\Bheight@bgt%
			\global\let\ldelim\bigl%
			\global\let\rdelim\bigr%
		\else\ifdim\labelheight@bgt<0.9\bbheight@bgt%
			\global\let\ldelim\Bigl%
			\global\let\rdelim\Bigr%
		\else\ifdim\labelheight@bgt<0.9\BBheight@bgt%
			\global\let\ldelim\biggl%
			\global\let\rdelim\biggr%
		\else%
			\global\let\ldelim\Biggl%
			\global\let\rdelim\Biggr%
		\fi\fi\fi\fi%
	}
	%
	\newcommand{\ap}[2][,]{%
		\ifmmode%
			\setdelim{#2}%
			\mathchoice{\ldelim(}{\lbdelim(}{(}{(}%
			\colorize@bgt{1}{#1}{#2}%
			\mathchoice{\rdelim)}{\rbdelim)}{)}{)}%
		\else%
			(\colorize@bgt{1}{#1}{#2})%
		\fi%
	}
	%
	\newcommand{\aps}[2][,]{%
		\ifmmode%
			\setdelim{#2}%
			\mathchoice{\ldelim(}{\lbdelim(}{(}{(}%
			\colorize@bgt{0}{#1}{#2}%
			\mathchoice{\rdelim)}{\rbdelim)}{)}{)}%
		\else%
			(\colorize@bgt{1}{#1}{#2})%
		\fi%
	}
	%
	\long\def\plset#1#2{%
		\ifmmode%
			\setdelim{#2}%
			\mathchoice{\ldelim\lbrace}{\lbdelim\lbrace}{\lbrace}{\lbrace}%
			\colorizelist@bgt{player#1}{#2}%
			\mathchoice{\rdelim\rbrace}{\rbdelim\rbrace}{\rbrace}{\rbrace}%
		\else%
			\{\colorizelist@bgt{player#1}{#2}\}%
		\fi%
	}
	\long\def\pltextset@bgt#1#2{%
		\setsepchar{,}%
		\readlist*\inputlist@bgt{#2}%
		\ifmmode%
			\setdelim{#2}%
			\mathchoice{\ldelim\lbrace}{\lbdelim\lbrace}{\lbrace}{\lbrace}%
			\colorizetextlist@bgt{player#1}
			\mathchoice{\rdelim\lbrace}{\rbdelim\lbrace}{\rbrace}{\lbrace}%
		\else%
			\{\colorizetextlist@bgt{player#1}\}%
		\fi%
	}
\else
	\newcommand{\ap}[2][,]{\ifmmode\left(\colorize@bgt{1}{#1}{#2}\right)\else(\colorize@bgt{1}{#1}{#2})\fi}
	\newcommand{\aps}[2][,]{\ifmmode\left(\colorize@bgt{0}{#1}{#2}\right)\else(\colorize@bgt{0}{#1}{#2})\fi}
	\long\def\plset#1#2{\ifmmode\left\lbrace\colorizelist@bgt{player#1}{#2}\right\rbrace\else\{\colorizelist@bgt{player#1}{#2}\}\fi}
	\long\def\pltextset@bgt#1#2{%
		\setsepchar{,}%
		\readlist*\inputlist@bgt{#2}%
		\ifmmode%
			\left\lbrace\colorizetextlist@bgt{player#1}\right\rbrace%
		\else%
			\{\colorizetextlist@bgt{player#1}\}%
		\fi%
	}%
\fi

\ifcontrast@bgt
	\long\def\pltext#1#2{\text{\color{player#1}#2}}
\else
	\long\def\pltext#1#2{\text{#2}}
\fi

\def\textset@bgt#1{\lbrace\text{#1}\rbrace}
\def\textset{\@ifnextchar\bgroup{\textset@bgt}{\pltextset@bgt}}
\def\set#1{\left\lbrace#1\right\rbrace}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	  1.5 Automaton States
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\atm@bend@bgt{bend right=20}
\newif\ifatm@curveleft@bgt
\newif\ifatm@left@bgt
\newif\ifatm@right@bgt
%
% Optional arguments
\define@bgts@family{atm}{%
	opacity, 1;
	font, \labelfontsize;
	arrow, -latex;
	pos, 0.5;
	curv, 20;
	loop, 0;
	loop angle, 108;
	path, 0;
	alert color, player1;
	xscale, 1;
	yscale, 1
}{%
	xshift, 0pt;
	yshift, 0pt;
	radius, 4.5mm;
	inline radius, 3.8mm;
	loop radius, 6mm;
	line width, \nodelinewidth@bgt;
	label sep, 0.6ex
}{}{%
	base line, false;
	force math, false;
	ap, false
}{}{}{}{}
%
% scale
\define@key@thickness@bgts{atm}
\define@key{atm@bgt}{scale}{\def\atm@xscale@bgt{#1}\def\atm@yscale@bgt{#1}}
%
% Tikz style
\tikzset{atm@inline/.style={draw, line width=\atm@linewidth@bgt, circle, fill=xg-bg, fill opacity=\atm@opacity@bgt, inner sep=0pt, minimum size=2*\atm@inlineradius@bgt, font=\atm@font@bgt}}
\tikzset{atm/.style={draw, line width=\atm@linewidth@bgt, circle, inner sep=0pt, minimum size=2*\atm@radius@bgt, font=\atm@font@bgt}}
\@ifclassloaded{beamer}{\setlength{\atm@radius@bgt}{3.5mm}\setlength{\atm@radius@bgt}{2.125ex}}{}
%
% Bend left and right
\define@key{atm@bgt}{bend right}[true]{\ifstreq@bgt{#1}{false}{\atm@curveleft@bgttrue}{\atm@curveleft@bgtfalse\ifstreq@bgt{#1}{true}{\edef\atm@bend@bgt{bend right=\atm@curv@bgt}}{\def\atm@bend@bgt{bend right=#1}\def\atm@curv@bgt{#1}}}}
\define@key{atm@bgt}{bend left}[true]{\ifstreq@bgt{#1}{false}{\atm@curveleft@bgtfalse}{\atm@curveleft@bgttrue\ifstreq@bgt{#1}{true}{\edef\atm@bend@bgt{bend left=\atm@curv@bgt}}{\def\atm@bend@bgt{bend left=#1}\def\atm@curv@bgt{#1}}}}
\define@key{atm@bgt}{straight}[true]{\def\atm@bend@bgt{}\def\atm@curve@bgt{0}}
%
% Path | doesn't seem to work as intended
\define@key{atm@bgt}{color}{\def\atm@path@bgt{1}\def\atm@alertcolor@bgt{#1}}
\define@key{atm@bgt}{loop}{\def\atm@loop@bgt{#1}\process@direction{\atm@loop@bgt}}
%\define@key{atm@bgt}{path}[1]{\pgfmathparse{#1}\global\let\atm@path@bgt\pgfmathresult}
%
% Highlighting of path
\define@key{atm@bgt}{path}[1]{\def\atm@path@bgt{#1}}
%
\define@key{atm@bgt}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\state@debug@bgttrue}{\state@debug@bgtfalse}%
	\ifstreq@bgt{#1}{detail}{\state@debug@bgttrue\debug@detail@bgttrue}{}%
}
%
\def\set@loopangle@bgt{
	\pgfmathparse{2*atan(\atm@loopradius@bgt/\atm@radius@bgt)}%
    \global\let\atm@loopangle@bgt\pgfmathresult%
}
\def\set@loopradius@bgt{%
	\pgfmathparse{tan(\atm@loopangle@bgt/2)*\atm@radius@bgt}%
	\expandafter\global\expandafter\atm@loopradius@bgt\pgfmathresult pt%
}
% loop radius / angle
\define@key{atm@bgt}{radius}{\setlength{\atm@radius@bgt}{#1}\set@loopangle@bgt}
\define@key{atm@bgt}{loop radius}{\setlength{\atm@loopradius@bgt}{#1}\set@loopangle@bgt}
\define@key{atm@bgt}{loop angle}{\def\atm@loopangle@bgt{#1}\set@loopradius@bgt}
% externalization
\newif\ifatm@externalize@bgt
\def\atm@external@bgt{}
\define@key{atm@bgt}{external}{\def\atm@external@bgt{#1}\atm@externalize@bgttrue}
%
\newif\ifatm@loopleft@bgt
\def\loop@edge@bgt#1{
	\pgfmathsetmacro{\atm@out@bgt}{\atm@loop@bgt+\atm@loopangle@bgt/2}
	\pgfmathsetmacro{\atm@in@bgt}{\atm@loop@bgt-\atm@loopangle@bgt/2}	
	% parse label
	\ifatm@left@bgt
		\node at (-4, 0) {left};
		\ifatm@curveleft@bgt
			\global\atm@loopleft@bgtfalse
		\else
			\global\atm@loopleft@bgttrue
		\fi
		\let\atm@labeltext@bgt\atm@leftlabel@bgt
	\else
		\ifatm@curveleft@bgt
			\global\atm@loopleft@bgttrue
		\else
			\global\atm@loopleft@bgtfalse
		\fi
		\let\atm@labeltext@bgt\atm@rightlabel@bgt
	\fi
	% draw arrows
	\getscale@bgt
	\pgfmathparse{100*\atm@path@bgt}
	\edef\draw@bgt{\noexpand\draw[\atm@arrow@bgt, line width=\the\atm@linewidth@bgt, \atm@alertcolor@bgt!\pgfmathresult!xg-fg]}
	\ifatm@loopleft@bgt
		\draw@bgt (#1.\atm@out@bgt) arc(\atm@out@bgt+90:\atm@in@bgt-90:\invx@bgt\atm@loopradius@bgt\space and \invy@bgt\atm@loopradius@bgt) coordinate[pos=\atm@pos@bgt] (temp);
	\else
		\draw@bgt (#1.\atm@in@bgt) arc(\atm@in@bgt-90:\atm@out@bgt+90:\invx@bgt\atm@loopradius@bgt\space and \invy@bgt\atm@loopradius@bgt) coordinate[pos=\atm@pos@bgt] (temp);
	\fi
	% place label
%	\pgfmathparse{\atm@radius@bgt/cos(\atm@loopangle@bgt/2)+\atm@loopradius@bgt+\atm@labelsep@bgt+0.5*\atm@linewidth@bgt}
%	\edef\atm@labeldist@bgt{\pgfmathresult pt}
	\placelabel@bgt{xg-fg}{temp}{\atm@loop@bgt}{\dimexpr\atm@labelsep@bgt+0.5\atm@linewidth@bgt\relax}{\atm@font@bgt}{\atm@labeltext@bgt}{\overlay@bgt}{}
}
%
\def\edge@parse@bgt#1-#2\endparse{%
	\global\atm@left@bgtfalse
	\global\atm@right@bgtfalse
	\gdef\atm@rightlabel@bgt{}
	\gdef\atm@leftlabel@bgt{}
	% left side
	\ifempty@bgt{#1}{}{
		\setsepchar{</,}
		\readlist*\edge@leftarg@bgt{#1}
		\ifnum\edge@leftarg@bgtlen>1\relax
			\global\atm@left@bgttrue
			\itemtomacro\edge@leftarg@bgt[1]\temp@left
			\ifatm@ap@bgt
%				\ifnum\listlen\edge@leftarg@bgt[1]>1
					\ifstrempty@bgt{\temp@left}{}{\xdef\atm@leftlabel@bgt{\noexpand\ensuremath{\noexpand\ap{\temp@left}}}}
%				\else
%					\ifstrempty@bgt{\temp@left}{}{\xdef\atm@leftlabel@bgt{\noexpand\ensuremath{\temp@left}}}
%				\fi
			\else
				\ifatm@forcemath@bgt
					\ifstrempty@bgt{\temp@left}{}{\xdef\atm@leftlabel@bgt{\noexpand\ensuremath{\temp@left}}}
				\else
					\ifstrempty@bgt{\temp@left}{}{\expandafter\gdef\expandafter\atm@leftlabel@bgt\expandafter{\@firstofone\temp@left}}
		\fi\fi\fi
	}
	\ifempty@bgt{#2}{}{
		\setsepchar{>/,}
		\readlist*\edge@rightarg@bgt{#2}
		\ifnum\edge@rightarg@bgtlen>1\relax
			\global\atm@right@bgttrue
			\itemtomacro\edge@rightarg@bgt[2]\temp@right
			\ifatm@ap@bgt
%				\ifnum\listlen\edge@rightarg@bgt[2]>1
					\ifstrempty@bgt{\temp@right}{}{\xdef\atm@rightlabel@bgt{\noexpand\ensuremath{\noexpand\ap{\temp@right}}}}
%				\else
%					\ifstrempty@bgt{\temp@right}{}{\xdef\atm@rightlabel@bgt{\noexpand\ensuremath{\temp@right}}}
%				\fi
			\else
				\ifatm@forcemath@bgt
					\ifstrempty@bgt{\temp@right}{}{\xdef\atm@rightlabel@bgt{\noexpand\ensuremath{\temp@right}}}
				\else
					\ifstrempty@bgt{\temp@right}{}{\expandafter\gdef\expandafter\atm@rightlabel@bgt\expandafter{\@firstofone\temp@right}}
		\fi\fi\fi
	}
}
%
\def\atm@leftlabel@bgt{}
\def\atm@rightlabel@bgt{}
\def\edge@opt#1;{
	\begingroup
		\label@placement@simple@bgtfalse
		\label@placement@box@bgttrue
		\expandafter\atmsetoptions\expandafter{\option@bgt}
		\setsepchar{(||)}
		\readlist*\arrows@bgt{#1}
		% number of nodes
		\ifnum\arrows@bgtlen<3
			\PackageError{xgames}{Unbalanced parentheses in \noexpand\edge}{}
		\else
			\pgfmathtruncatemacro{\n@bgt}{(\arrows@bgtlen-3)/2}
		\fi
		% loop arrow
		\ifnum\n@bgt=0\relax
			\itemtomacro\arrows@bgt[3]\atm@arg@bgt
			\expandafter\edge@parse@bgt\atm@arg@bgt\endparse
			\expandafter\loop@edge@bgt\expandafter{\arrows@bgt[2]}
		\else
			\foreach \i@bgt in {1, ..., \n@bgt} {
				\itemtomacro\arrows@bgt[2*\i@bgt]\atm@leftnode@bgt
				\itemtomacro\arrows@bgt[2*\i@bgt+2]\atm@rightnode@bgt
				\itemtomacro\arrows@bgt[2*\i@bgt+1]\atm@arg@bgt
				\expandafter\edge@parse@bgt\atm@arg@bgt\endparse
				\ifstreq@bgt{\atm@leftnode@bgt}{\atm@rightnode@bgt}{
					% determine the direction of the loop
					\ifnum\i@bgt=1
						\ifnum\n@bgt=1
							\PackageError{xgames}{direction of loop missing}
						\else
							\itemtomacro\arrows@bgt[2*\i@bgt+4]\atm@nextnode@bgt
							\pgfextractangle{\atm@loop@bgt}{\atm@nextnode@bgt}{\atm@rightnode@bgt}
						\fi
					\else
						\itemtomacro\arrows@bgt[2*\i@bgt-2]\atm@prevnode@bgt
						\ifnum\i@bgt=\n@bgt
							\pgfextractangle{\atm@loop@bgt}{\atm@prevnode@bgt}{\atm@leftnode@bgt}
						\else
							\itemtomacro\arrows@bgt[2*\i@bgt+4]\atm@nextnode@bgt
							\pgfextractangle{\left@angle@bgt}{\atm@leftnode@bgt}{\atm@prevnode@bgt}
							\pgfextractangle{\right@angle@bgt}{\atm@nextnode@bgt}{\atm@rightnode@bgt}
							\ifatm@curveleft@bgt
								\ifdim\left@angle@bgt pt>\right@angle@bgt pt
									\pgfmathparse{\left@angle@bgt-360}
									\global\left@angle@bgt\pgfmathresult
								\fi
							\else
								\ifdim\right@angle@bgt pt>\left@angle@bgt pt
									\pgfmathparse{\right@angle@bgt-360}
									\global\right@angle@bgt\pgfmathresult
								\fi
							\fi
							\pgfmathparse{(\left@angle@bgt + \right@angle@bgt)/2}
							\global\let\atm@loop@bgt\pgfmathresult
					\fi\fi
					\loop@edge@bgt{\atm@leftnode@bgt}
				}{
					\pgfmathparse{100*\atm@path@bgt}
					\edef\draw@bgt{\noexpand\draw\overlay@bgt[\atm@arrow@bgt, line width=\atm@linewidth@bgt, \atm@bend@bgt, \atm@alertcolor@bgt!\pgfmathresult!xg-fg]}
					\ifatm@right@bgt
						\ifstrempty@bgt{\atm@rightlabel@bgt}{
							\draw@bgt (\atm@leftnode@bgt) edge (\atm@rightnode@bgt);
						}{
							\draw@bgt (\atm@leftnode@bgt) edge coordinate[pos=\atm@pos@bgt] (temp) (\atm@rightnode@bgt);
							\pgfextractangle{\angle@bgt}{\atm@leftnode@bgt}{\atm@rightnode@bgt};
							\ifatm@curveleft@bgt
								\placelabel@bgt{xg-fg}{temp}{\angle@bgt+90}{\dimexpr\atm@labelsep@bgt+0.5\atm@linewidth@bgt\relax}{\atm@font@bgt}{\atm@rightlabel@bgt}{\overlay@bgt}{}
							\else
								\placelabel@bgt{xg-fg}{temp}{\angle@bgt-90}{\dimexpr\atm@labelsep@bgt+0.5\atm@linewidth@bgt\relax}{\atm@font@bgt}{\atm@rightlabel@bgt}{\overlay@bgt}{}
							\fi
						}
					\fi
					\ifatm@left@bgt
						\ifstrempty@bgt{\atm@leftlabel@bgt}{
							\draw@bgt (\atm@rightnode@bgt) edge (\atm@leftnode@bgt);
						}{
							\draw@bgt (\atm@rightnode@bgt) edge coordinate[pos=\atm@pos@bgt] (temp) (\atm@leftnode@bgt);
							\pgfextractangle{\angle@bgt}{\atm@rightnode@bgt}{\atm@leftnode@bgt};
							\ifatm@curveleft@bgt
								\placelabel@bgt{xg-fg}{temp}{\angle@bgt+90}{\dimexpr\atm@labelsep@bgt+0.5\atm@linewidth@bgt\relax}{\atm@font@bgt}{\atm@leftlabel@bgt}{\overlay@bgt}{}
							\else
								\placelabel@bgt{xg-fg}{temp}{\angle@bgt-90}{\dimexpr\atm@labelsep@bgt+0.5\atm@linewidth@bgt\relax}{\atm@font@bgt}{\atm@leftlabel@bgt}{\overlay@bgt}{}
							\fi
						}
					\fi
			}}
		\fi
	\endgroup
}
\addoptions@bgt{edge}
\addoverlay@bgt{edge}
%
\ifexternal@bgt
	\NewEnviron{automaton}[1][]{%
		\atmsetoptions{#1}%
		\set@loopangle@bgt%
		\ifatm@externalize@bgt%
			\expandafter\externalize\expandafter{\atm@external@bgt}%
		\fi%
		\begin{tikzpicture}[xscale=\atm@xscale@bgt, yscale=\atm@yscale@bgt]
		\BODY
		\end{tikzpicture}%
	}{}
\else
	\newenvironment{automaton}[1][]{%
		\atmsetoptions{#1}%
		\set@loopangle@bgt%
		\begin{tikzpicture}[xscale=\atm@xscale@bgt, yscale=\atm@yscale@bgt]
	}{
		\end{tikzpicture}%
	}
\fi
%
% Inline command
\@ifclassloaded{beamer}{
	\def\atm@xshift@def{1.25ex}
	\def\atm@yshift@def{2.125ex}
}{
	\def\atm@xshift@def{1.4mm}
	\def\atm@yshift@def{3.8mm}
}

\newcommand{\atminline@bgt}[2][]{%
	\atmsetoptions{#1}%
	\hspace{\dimexpr\atm@xshift@bgt-\atm@xshift@def\relax}\smash{\raisebox{\dimexpr\atm@yshift@bgt-\atm@yshift@def\relax}{\tikz{\expandafter\node\overlay@bgt[atm@inline] at (0, 0) {$#2$};}}}%
}
\addoverlay@bgt{atminline}
%
\def\atmstate@opt#1{%
	\begingroup%
		\expandafter\atmsetoptions\expandafter{\option@bgt}%
		\hspace*{\dimexpr\atm@xshift@bgt-\atm@xshift@def\relax}\smash{\raisebox{\dimexpr\atm@yshift@bgt-\atm@yshift@def\relax}{\tikz{\expandafter\node\overlay@bgt[atm@inline] at (0, 0) {$#1$};}}}%
	\endgroup%
}
\addoptions@bgt{atmstate}
\addoverlay@bgt{atmstate}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	    2. Belief spaces
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Variables
\newlength{\inform@width@bgt}
\newlength{\inform@radius@bgt}
\newlength{\inform@maxradius@bgt}
\newlength{\inform@left@bgt}
\newlength{\inform@right@bgt}
\newlength{\belief@innersep@bgt}
\setlength{\belief@innersep@bgt}{1pt}
\newif\ifwithin@beliefspace@bgt
\newif\ifbelief@center@bgt%
\newif\ifbelief@center@measured@bgt%
\newif\ifbelief@baseline@bgt%
\newif\ifinform@misaligned@bgt%
\newif\ifbelief@state@bgt
\belief@state@bgttrue
\belief@baseline@bgttrue
%
% Define default radii. Maximum may be package option
\setcounter{iterator@bgt}{0}
\foreach \i in {0, ..., 9} {%
	\expandafter\newlength\expandafter{\csname playerradius\romannumeral\i @bgt\endcsname}%
}
%
\newcommand{\informsetradius}[2][1]{%
% #1 : first radius corresponds to player #1
% #2 : list of radii
	\ifempty@bgt{#2}{}{%
		\setcounter{iterator@bgt}{#1}%
		% determine the maximal radius
		\setlength{\inform@maxradius@bgt}{0pt}%
		\foreach \item@bgt in {#2} {%
			% store item in a global variable so we can let it to player radius after for loop
			\expandafter\xdef\csname tempradius\roman{iterator@bgt}@bgt\endcsname{\item@bgt}
			\expandafter\ifdim\item@bgt>\inform@maxradius@bgt%
				\expandafter\global\expandafter\inform@maxradius@bgt\item@bgt%
			\fi%
			\aftergroup\aftergroup\expandafter\aftergroup\csname playerradius\roman{iterator@bgt}@bgt\endcsname\aftergroup\aftergroup\expandafter\aftergroup\csname tempradius\roman{iterator@bgt}@bgt\endcsname
			\stepcounter{iterator@bgt}%
}}}
\informsetradius[0]{5.2mm, 3.6mm, 4.4mm, 5.2mm, 6mm}
%
% Select players generally
\def\select@activeplayer@bgt{%
	\def\activecolor@bgt{player\theactiveplayer@bgt}%
	\ifnum\value{activeplayer@bgt}=0%
		\gdef\activefillnode@bgt{xg-bg}%
		\gdef\activefill@bgt{xg-bg!90!xg-fg}%
	\else%
		\gdef\activefillnode@bgt{player\theactiveplayer@bgt}%
		\gdef\activefill@bgt{player\theactiveplayer@bgt!95!xg-bg}%
	\fi%
}
\def\activename@bgt{%
	\iftree@labels@short@bgt%
		\ifnum\value{activeplayer@bgt}=0%
			N%
		\else%
			\theactiveplayer@bgt%
		\fi%
	\else%
		\csname playername\roman{activeplayer@bgt}@bgt\endcsname%
	\fi%
}
%
% Select players in information sets
\def\inform@selectplayer@bgt{%
	\select@activeplayer@bgt%
	\xdef\inform@labeltext@bgt{\csname playername\roman{activeplayer@bgt}@bgt\endcsname}%
	\gdef\inform@color@bgt{player\theactiveplayer@bgt}%
	\expandafter\global\expandafter\inform@radius@bgt\csname playerradius\roman{activeplayer@bgt}@bgt\endcsname%
	%
%	\ifinform@sticky@bgt\else%
		\inform@reset@labelradius%
%	\fi%
}
%
\def\inform@reset@labelradius{%
	\ifinform@labelradius@maxdef%
		\global\inform@labelradius@bgt\inform@maxradius@bgt%
	\else%
		\global\inform@labelradius@bgt\inform@radius@bgt%
	\fi%
}
%
% Options
\newif\ifbelief@identicalwidth@bgt
\belief@identicalwidth@bgttrue
\define@key{belief@bgt}{identical width}[true]{\ifstreq@bgt{#1}{true}{\belief@identicalwidth@bgttrue}{\belief@identicalwidth@bgtfalse}}
\define@key{belief@bgt}{state}[true]{\ifstreq@bgt{#1}{true}{\belief@state@bgttrue}{\belief@state@bgtfalse\inform@misaligned@bgttrue}}
\define@key{belief@bgt}{state inner sep}{\setlength{\belief@innersep@bgt}{#1}}
\define@key{belief@bgt}{base line}[true]{\ifstreq@bgt{#1}{true}{\belief@baseline@bgttrue}{\belief@baseline@bgtfalse}}
% belief space with "center" option is always nonode: since the state is shifted, can't create a tikz node before all states are read. if the states are drawn only at the end of the environment, a full-fledged tikz node is no longer useful. Marking up with center option is difficult
\define@key{belief@bgt}{center}[@true]{%
	\inform@misaligned@bgttrue%
	\ifstreq@bgt{#1}{@true}{%
		\belief@center@bgttrue\state@delay@deftrue\state@delaylabel@deftrue%
	}{%
		\belief@center@measured@bgttrue%
		\global\inform@width@bgt#1%
	}
}
% Externalize
\newif\ifbelief@externalize@bgt
\def\belief@external@bgt{}
\define@key{belief@bgt}{external}{\def\belief@external@bgt{#1}\belief@externalize@bgttrue}

\define@key{belief@bgt}{tikz nodes}[true]{\ifstreq@bgt{#1}{true}{\state@delay@deffalse}{\state@delay@deftrue}}
\define@key{belief@bgt}{font}{%
	\def\inform@font@def{#1}%
	\def\state@font@def{#1}%
}
\define@key{belief@bgt}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{%
		\inform@debug@deftrue%
		\state@debug@deftrue%
	}{%
		\inform@debug@deffalse%
		\state@debug@deffalse%
	}%
	\ifstreq@bgt{#1}{detail}{%
		\inform@debug@deftrue%
		\state@debug@deftrue%
		\debug@detail@bgttrue%
	}{}
}
\define@key{belief@bgt}{inform line width}{\setlength{\inform@linewidth@def}{#1}}
\define@key{belief@bgt}{state line width}{\setlength{\state@linewidth@def}{#1}}
\define@key{belief@bgt}{state label sep}{\setlength{\state@labelsep@def}{#1}}
\define@key{belief@bgt}{line width}{%
	\setlength{\inform@linewidth@def}{#1}%
	\setlength{\state@linewidth@def}{#1}%
}
\define@key{belief@bgt}{state radius}{%
	\setlength{\state@radius@def}{#1}%
}
\define@key{belief@bgt}{left}{\setlength{\inform@left@bgt}{#1}\ifdim#1=0pt\else\inform@misaligned@bgttrue\fi}
\define@key{belief@bgt}{right}{\setlength{\inform@right@bgt}{#1}}
\define@key{belief@bgt}{xscale}{%
	\edef\passtotikz@bgt{\passtotikz@bgt, xscale=#1}%
}
\define@key{belief@bgt}{yscale}{%
	\edef\passtotikz@bgt{\passtotikz@bgt, yscale=#1}%
}
\define@key{belief@bgt}{scale}{%
	\edef\passtotikz@bgt{\passtotikz@bgt, scale=#1}%
}
\def\parseradiusinput@bgt{\@ifnextchar[{\@parseradiusinput@bgt}{\@parseradiusinput@bgt[1]}}
\def\@parseradiusinput@bgt[#1]#2{\def\temp@a{\informsetradius[#1]}\expandafter\temp@a\expandafter[#1]{#2}}
\define@key{belief@bgt}{radius}{\informsetradius{#1}}
\define@key{belief@bgt}{event}{\informsetradius[0]{#1}}
\define@key{belief@bgt}{label radius}{%
% I feel like this needs more options. parse label radius
	\ifstreq@bgt{#1}{max}{%
		\inform@labelradius@maxdeftrue%
		% set it to the maximum in case player radii have been parsed already
		\global\inform@labelradius@bgt\inform@maxradius@bgt%
	}{\inform@labelradius@maxdeffalse}%
}
\define@key{belief@bgt}{contour}[true]{\ifstreq@bgt{#1}{true}{\inform@contour@deftrue\state@contour@deftrue}{\ifstreq@bgt{#1}{false}{\inform@contour@deffalse\state@contour@deffalse}{\csname#1@contour@deftrue\endcsname}}}
\define@key{belief@bgt}{delay}[true]{\ifstreq@bgt{#1}{true}{\inform@delaycontour@deftrue\state@delaycontour@deftrue}{\ifstreq@bgt{#1}{false}{\inform@delaycontour@deffalse\state@delaycontour@deffalse}{\csname#1@delaycontour@deftrue\endcsname}}}
\define@key{belief@bgt}{arc}{\def\inform@arc@def{#1}}
\define@key{belief@bgt}{exterior}{\setdefaultswitch@bgt{inform@exterior}{#1}}
%
\def\beliefsetoptions@bgt#1{\setkeys{belief@bgt}{#1}}
\def\beliefsetoptions#1{\setkeys{belief@bgt}{#1}}
%
\def\belief@default@bgt{
	\within@beliefspace@bgttrue%
	\def\passtotikz@bgt{}%
	\ifbelief@baseline@bgt%
		\state@baseline@deftrue%
		\inform@baseline@deftrue%
	\else%
		\state@baseline@deffalse%
		\inform@baseline@deffalse%
	\fi%
}
%
\def\beliefspace@bgtbegin#1{%
	\belief@default@bgt%
	\beliefsetoptions@bgt{#1}%
}
\def\beliefspace@bgtend{%
	\global\inform@width@bgt0pt%
	\global\inform@left@bgt0pt%
	\global\inform@right@bgt0pt%
	\global\inform@misaligned@bgtfalse%
%	\setcounter{activeplayer@bgt}{0}%
	\global\belief@center@bgtfalse%
	\global\belief@center@measured@bgtfalse%
	\global\within@beliefspace@bgtfalse%
	\ignorespacesafterend
}
\ifexternal@bgt
	\NewEnviron{beliefspace}[1][]{%
		\beliefspace@bgtend% not sure why this is necessary, but it is.
		\beliefspace@bgtbegin{#1}%
		\ifbelief@externalize@bgt%
			\expandafter\externalize\expandafter{\belief@external@bgt}%
		\fi%
		\def\temp{\begin{tikzpicture}}%
		\expandafter\temp\expandafter[\passtotikz@bgt]
		\BODY
		\end{tikzpicture}%
	}{\beliefspace@bgtend}
\else
	\newenvironment{beliefspace}[1][]{%
		\beliefspace@bgtbegin{#1}%
		\def\temp{\begin{tikzpicture}}%
		\expandafter\temp\expandafter[\passtotikz@bgt]
	}{
		\end{tikzpicture}%
		\beliefspace@bgtend
	}
\fi
%
%\passtotikz is expensive
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      2.1 Label position
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newif\ifdebug@detail@bgt
\def\debugsetoptions#1{\debug@detail@bgttrue}
%
\newlength{\labelwidth@bgt}
\newlength{\labelheight@bgt}
\newlength{\labeldepth@bgt}
\newif\iflabelplaced@bgt
\newif\iflabel@placement@box@bgt
\newif\iflabel@placement@simple@bgt
\newcounter{contour@label@bgt}
%
\newcommand{\placelabel@bgt}[9][]{%
% #1: coordinate name
% #2: color (or any other tikz options)
% #3: position of node
% #4: direction of label
% #5: distance from node
% #6: font size
% #7: label text
% #8: outer overlay specifications
% #9: inner overlay specifications
	\labelplaced@bgtfalse%
	% set state@delaylabel@bgt
	\ifstate@contour@bgt\ifstate@delaycontour@bgt
		\state@delaylabel@bgttrue
	\fi\fi
	% measure label size
	\ifstate@delaylabel@bgt
		% expand the \noexpand
		\edef\temp@a{#7}
		\settowidth{\labelwidth@bgt}{\pgfinterruptpicture{#6\temp@a}\endpgfinterruptpicture}%
		\settoheight{\labelheight@bgt}{\pgfinterruptpicture{#6\temp@a}\endpgfinterruptpicture}%
		\settodepth{\labeldepth@bgt}{\pgfinterruptpicture{#6\temp@a}\endpgfinterruptpicture}%
	\else
		\settowidth{\labelwidth@bgt}{\pgfinterruptpicture{#6#7}\endpgfinterruptpicture}%
		\settoheight{\labelheight@bgt}{\pgfinterruptpicture{#6#7}\endpgfinterruptpicture}%
		\settodepth{\labeldepth@bgt}{\pgfinterruptpicture{#6#7}\endpgfinterruptpicture}%
	\fi
	\ifstate@baseline@bgt\else%
		\addtolength{\labelheight@bgt}{\labeldepth@bgt}%
	\fi%
	% process above, below, etc.
	\def\processed@angle@bgt{#4}%
	\process@direction{\processed@angle@bgt}%
	% deal with most frequent special cases for (a) speed and (b) prevent division by 0
	\pgfmathtruncatemacro{\roundedangle@bgt}{Mod(\processed@angle@bgt, 360)}%
	\ifnum\roundedangle@bgt=0%
		\scale@invariant@bgt{offset}{\the\dimexpr#5 + 0.5\labelwidth@bgt\relax, 0}
		\xdef\temp@coord@bgt{(#3) + \@offset}%
		\labelplaced@bgttrue%
	\else\ifnum\roundedangle@bgt=90%
		\scale@invariant@bgt{offset}{0, \the\dimexpr#5 + 0.5\labelheight@bgt\relax}
		\xdef\temp@coord@bgt{(#3) + \@offset}%
		\labelplaced@bgttrue%
	\else\ifnum\roundedangle@bgt=180%
		\scale@invariant@bgt{offset}{-\the\dimexpr#5 + 0.5\labelwidth@bgt\relax, 0}
		\xdef\temp@coord@bgt{(#3) + \@offset}%
		\labelplaced@bgttrue%
	\else\ifnum\roundedangle@bgt=270%
		\scale@invariant@bgt{offset}{0, -\the\dimexpr#5 + 0.5\labelheight@bgt\relax}
		\xdef\temp@coord@bgt{(#3) + \@offset}%
		\labelplaced@bgttrue%
	\fi\fi\fi\fi%
	% If it was not one of the most frequent cases
	\iflabelplaced@bgt\else%
		\pgfmathsetmacro{\angle@bgt}{Mod(\processed@angle@bgt, 360)}%
		\ifdim\angle@bgt pt>270pt%
			\scale@invariant@bgt{label@offset}{\the\dimexpr0.5\labelwidth@bgt\relax, -\the\dimexpr0.5\labelheight@bgt\relax}
		\else%
			\ifdim\angle@bgt pt>180pt%
				\scale@invariant@bgt{label@offset}{-\the\dimexpr0.5\labelwidth@bgt\relax, -\the\dimexpr0.5\labelheight@bgt\relax}
			\else%
				\ifdim\angle@bgt pt>90pt%
					\scale@invariant@bgt{label@offset}{-\the\dimexpr0.5\labelwidth@bgt\relax, \the\dimexpr0.5\labelheight@bgt\relax}
				\else%
					\scale@invariant@bgt{label@offset}{\the\dimexpr0.5\labelwidth@bgt\relax, \the\dimexpr0.5\labelheight@bgt\relax}
		\fi\fi\fi%
		%
		\iflabel@placement@simple@bgt%
			\ifdim\angle@bgt pt>270pt%
				\scale@invariant@bgt{sep@offset}{-45:#5}
			\else%
				\ifdim\angle@bgt pt>180pt%
					\scale@invariant@bgt{sep@offset}{-135:#5}
				\else%
					\ifdim\angle@bgt pt<90pt%
						\scale@invariant@bgt{sep@offset}{135:#5}
					\else%
						\scale@invariant@bgt{sep@offset}{45:#5}
			\fi\fi\fi%
			\xdef\temp@coord@bgt{(#3) + \@sep@offset + \@label@offset}
		\else
			\iflabel@placement@box@bgt%
				\scale@invariant@bgt{sep@offset}{\processed@angle@bgt:#5}
				\xdef\temp@coord@bgt{(#3) + \@sep@offset + \@label@offset}
			\else%
				% use symmetry to reduce the problem to the first quadrant
				\ifdim\angle@bgt pt>270pt%
					\pgfmathsetmacro{\alpha@bgt}{360-\angle@bgt};%
				\else%
					\ifdim\angle@bgt pt>180pt%
						\pgfmathsetmacro{\alpha@bgt}{\angle@bgt-180};%
					\else%
						\ifdim\angle@bgt pt<90pt%
							\pgfmathsetmacro{\alpha@bgt}{\angle@bgt};%
						\else%
							\pgfmathsetmacro{\alpha@bgt}{180-\angle@bgt};%
				\fi\fi\fi%
				% Get angle from label
				\extractangle{\beta@bgt}{\labelwidth@bgt}{\labelheight@bgt}%
				% Figure out if the label extends past the north/east pole
				\pgfmathsetmacro{\gamma@bgt}{\alpha@bgt-\beta@bgt}%
				\pgfmathsetmacro{\y@bgt}{sqrt(\labelwidth@bgt^2 + \labelheight@bgt^2)/2}%
				% here I have to be careful
				\pgfmathsetmacro{\mindist@bgt}{#5}% not sure if I can divide numbers by lengths?
				\pgfmathsetmacro{\sineta@bgt}{sin(\gamma@bgt)/\mindist@bgt*\y@bgt}%
				% Note that |\sineta@bgt| is larger than 1 if the label extends past the north/east pole
				\ifdim\sineta@bgt pt>1pt%
					\pgfmathsetmacro{\dist@bgt}{(\mindist@bgt + \y@bgt*sin(\beta@bgt))/sin(\alpha@bgt)}%
					\else\ifdim\sineta@bgt pt<-1pt%
						\pgfmathsetmacro{\dist@bgt}{(\mindist@bgt + \y@bgt*cos(\beta@bgt))/cos(\alpha@bgt)}%
						\else%
							\pgfmathsetmacro{\coszeta@bgt}{cos(\alpha@bgt)*sqrt(1 - \sineta@bgt^2) - sin(\alpha@bgt)*\sineta@bgt}%
							\pgfmathsetmacro{\sinzeta@bgt}{sin(\alpha@bgt)*sqrt(1 - \sineta@bgt^2) + cos(\alpha@bgt)*\sineta@bgt}%
							\ifdim\coszeta@bgt pt<0pt%
								\pgfmathsetmacro{\dist@bgt}{(\mindist@bgt + \y@bgt*sin(\beta@bgt))/sin(\alpha@bgt)}
							\else\ifdim\sinzeta@bgt pt<0pt%
								\pgfmathsetmacro{\dist@bgt}{(\mindist@bgt + \y@bgt*cos(\beta@bgt))/cos(\alpha@bgt)}
								\else%
									\pgfmathsetmacro{\cosdelta@bgt}{sin(\gamma@bgt)*\sineta@bgt - cos(\gamma@bgt)*sqrt(1 - \sineta@bgt^2)}%
								\pgfmathsetmacro{\dist@bgt}{sqrt(\y@bgt^2 + \mindist@bgt^2 - 2*\y@bgt*\mindist@bgt*\cosdelta@bgt)}%
				\fi\fi\fi\fi%
				% define coordinate of label
				\scale@invariant@bgt{offset}{\processed@angle@bgt:\dist@bgt\space pt}
				\xdef\temp@coord@bgt{(#3) + \@offset}%
%				\xdef\temp@coord@bgt{(#3) + (\processed@angle@bgt:\invx@bgt*\dist@bgt pt and \invy@bgt*\dist@bgt pt)}
		\fi\fi%
	\fi%
	%
	% Place the label
	\ifstate@baseline@bgt%
		\setlength{\state@voffset@bgt}{\invy@bgt\labeldepth@bgt}%
	\else%
		\setlength{\state@voffset@bgt}{0pt}
	\fi%
	% Assigning name (#1-label) to a node that is drawn anyway is essentially costless in terms of speed
	% inner sep=0pt helps with bounding box calculations. Arrows won't be shortened if drawn to the label
	\ifstate@contour@bgt
		\ifstate@delaylabel@bgt
			\ifempty@bgt{#1}{\def\temp{}}{\def\temp{(#1-label) }}
			\stepcounter{contour@label@bgt}
			\expandafter\xdef\csname contour@label@bgt\roman{contour@label@bgt}\endcsname{#7}
			\AtEndEnv@bgt{\noexpand\visible#8{\noexpand\node#9[inner sep=0pt, #2, font=\noexpand#6] \temp at ($\temp@coord@bgt - 0.5*(0, \the\state@voffset@bgt)$) {\noexpand\contour{xg-bg}{\expandafter\noexpand\csname contour@label@bgt\roman{contour@label@bgt}\endcsname}};}}
		\else
			\ifempty@bgt{#1}{%
				\def\temp{\expandafter\node#9[inner sep=0pt, #2, font=#6] at}
			}{%
				\def\temp{\expandafter\node#9[inner sep=0pt, #2, font=#6] (#1-label) at}
			}%
			\expandafter\visible#8{\expandafter\temp\expandafter(\expandafter$\temp@coord@bgt + (0, -0.5\state@voffset@bgt)$) {\contour{xg-bg}{#7}};}%
		\fi
	\else
		\ifstate@delaylabel@bgt
			\ifempty@bgt{#1}{\def\temp{}}{\def\temp{(#1-label) }}
			\stepcounter{contour@label@bgt}
			\expandafter\xdef\csname contour@label@bgt\roman{contour@label@bgt}\endcsname{#7}
			\AtEndEnv@bgt{\noexpand\visible#8{\noexpand\node#9[inner sep=0pt, #2, font=\noexpand#6] \temp at ($\temp@coord@bgt - 0.5*(0, \the\state@voffset@bgt)$) {\expandafter\noexpand\csname contour@label@bgt\roman{contour@label@bgt}\endcsname};}}
		\else
			\ifempty@bgt{#1}{%
				\def\temp{\expandafter\node#9[inner sep=0pt, #2, font=#6] at}
			}{%
				\def\temp{\expandafter\node#9[inner sep=0pt, #2, font=#6] (#1-label) at}
			}%
			\expandafter\visible#8{\expandafter\temp\expandafter(\expandafter$\temp@coord@bgt + (0, -0.5\state@voffset@bgt)$) {#7};}%
		\fi
	\fi
	% Visualize placement for debugging
	\ifstate@debug@bgt%
		% \scale@invariant has stored \invx@bgt and \invy@bgt
		\ifstate@delaylabel@bgt%
			\ifwithin@beliefspace@bgt%
				\edef\draw@node{\noexpand\draw[debug@bgt] (#3) ellipse (\expandafter\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \expandafter\the\dimexpr\invy@bgt\state@radius@bgt\relax);}
				\draw@node%
			\fi%
			\AtEndEnv@bgt{\noexpand\draw[debug@bgt] (#3) ellipse (\invx@bgt*#5 and \invy@bgt*#5);}
			\AtEndEnv@bgt{\noexpand\draw[debug@bgt] ($\temp@coord@bgt - 0.5*(\the\dimexpr\invx@bgt\labelwidth@bgt\relax, \the\dimexpr\invy@bgt\labelheight@bgt\relax)$) rectangle ++(\the\dimexpr\invx@bgt\labelwidth@bgt\relax, \the\dimexpr\invy@bgt\labelheight@bgt\relax);}
			% box placement algorithm
			\ifdebug@detail@bgt
				\iflabel@placement@box@bgt%
					\AtEndEnv@bgt{\noexpand\draw[debug@bgt!50!] (#3) -- ++\sep@offset;}
				\else%
					\iflabel@placement@simple@bgt\else%
						\AtEndEnv@bgt{\noexpand\draw[debug@bgt!50!] (#3) -- ($\temp@coord@bgt$);}
			\fi\fi\fi%
		\else%
			\edef\draw@ring{\noexpand\draw[debug@bgt] (#3) ellipse (\invx@bgt*#5 and \invy@bgt*#5);}
			\draw@ring%
			\def\temp{\draw[debug@bgt]}
			\expandafter\temp\expandafter(\expandafter$\temp@coord@bgt - 0.5*(\invx@bgt\labelwidth@bgt, \invy@bgt\labelheight@bgt)$) rectangle ++(\invx@bgt\labelwidth@bgt, \invy@bgt\labelheight@bgt);%
			% box placement algorithm
			\ifdebug@detail@bgt
				\iflabel@placement@box@bgt%
					\edef\draw@line{\noexpand\draw[debug@bgt!50!] (#3) -- ++\sep@offset;}
					\draw@line
				\else%
					\iflabel@placement@simple@bgt\else%
						\edef\draw@line{\noexpand\draw[debug@bgt!50!] (#3) -- ($\temp@coord@bgt$);}
						\draw@line
			\fi\fi\fi%
		\fi%
	\fi%
}
%
\newcommand{\state@placelabel@bgt}[6][]{%
% #1: coordinate name
% #2: position of node
% #3: direction of label
% #4: label text
% #5: outer overlay specifications
% #6: inner overlay specifications
	\begingroup
		\ifstate@labelplacement@simple@bgt%
			\label@placement@simple@bgttrue%
			\label@placement@box@bgtfalse%
		\else\ifstate@labelplacement@box@bgt
			\aftergroup\label@placement@simple@bgtfalse%
			\aftergroup\label@placement@box@bgttrue%
		\else%
			\aftergroup\label@placement@simple@bgtfalse%
			\aftergroup\label@placement@box@bgtfalse%
		\fi\fi%
		\placelabel@bgt[#1]{\state@labelcolor@bgt}{#2}{#3}{\dimexpr0.5\state@linewidth@bgt + \state@radius@bgt + \state@labelsep@bgt\relax}{\state@font@bgt}{#4}{#5}{#6}%
	\endgroup
}
%
\def\statelabel@bgt#1(#2)#3at#4(#5)#6;{
	\begingroup
		\setsepchar{:}
		\readlist*\label@dir@bgt{#2}
		\itemtomacro\label@dir@bgt[1]\temp@a
		%
		\ifnum\label@dir@bgtlen>1
			\itemtomacro\label@dir@bgt[2]\state@labelsep@bgt
		\fi
		%\@firstofone removes the braces
		\def\state@labelcolor@bgt{xg-fg}
		\state@placelabel@bgt{#5}{\temp@a}{\@firstofone#6}{}{\overlay@bgt}
	\endgroup
}
\addoverlay@bgt{statelabel}
%
\newcommand{\edge@placelabel@bgt}[9]{%
% #1: color
% #2: position of first node
% #3: position of second node
% #4: \pos@bgt
% #5: direction of label
% #6: distance of label
% #7: label text
% #8: outer overlay specifications
% #9: inner overlay specifications
	\pgfextractangle{\angle@bgt}{#2}{#3}%
	\pgfmathsetmacro{\labelangle@bgt}{\angle@bgt+#5}%
	\begingroup%
		\ifedge@labelplacement@simple@bgt%
			\label@placement@simple@bgttrue%
			\label@placement@box@bgtfalse%
		\else\ifedge@labelplacement@box@bgt
			\label@placement@simple@bgtfalse%
			\label@placement@box@bgttrue%
		\else%
			\label@placement@simple@bgtfalse%
			\label@placement@box@bgtfalse%
		\fi\fi%
		\ifedge@debug@bgt\state@debug@bgttrue\else\state@debug@bgtfalse\fi%
		\ifedge@contour@bgt\state@contour@bgttrue\else\state@contour@bgtfalse\fi%
		\ifedge@delaycontour@bgt\state@delaycontour@bgttrue\else\state@delaycontour@bgtfalse\fi%
		\state@baseline@bgtfalse%
		\placelabel@bgt{#1}{$(#2)!#4!(#3)$}{\labelangle@bgt}{#6}{\edge@font@bgt}{#7}{#8}{#9}%
	\endgroup%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     	   2.2 States
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Variables
\newlength{\state@voffset@bgt}
\newif\ifstate@colorprovided@bgt
\newif\ifwithin@tree@bgt
%
% Optional arguments
\define@bgt@family{state}{%
	font, \labelfontsize;
	label, 0;
	line color, xg-fg;
	label color, xg-fg;
	fill, xg-bg
}{%
	radius, 2pt;
	line width, \nodelinewidth@bgt;
	label sep, 0.6ex
}{}{
	base line, false;
	delay, false;
	delay label, false;
	contour, false;
	delay contour, false;
	debug, false
}{
	label placement, center:box:simple
}{%
%	fill, xg-bg
}{}{
	% Doesn't work if \pl is used in the argument of a state since that changes the activeplayer. 
	% Did I fix this?
	\ifstate@colorprovided@bgt\else
%		\ifwithin@tree@bgt
			\ifnum\value{activeplayer@bgt}=0
				\def\state@labelcolor@bgt{xg-fg}
			\else
				\let\state@labelcolor@bgt\activecolor@bgt
			\fi
%		\else
%			\def\state@labelcolor@bgt{xg-fg}
%		\fi
	\fi
%	\setswitchtodefault@bgt{state@labelplacement}
}
\ifnonode@bgt\state@delay@deftrue\fi
\@ifclassloaded{beamer}{\setlength{\state@radius@def}{1.5pt}}{}
%
\define@key@thickness{state}{def}{\state@setlinewidth@bgt{def}}
\define@key@thickness{state}{bgt}{\state@setlinewidth@bgt{bgt}}
%
\def\state@setlinewidth@bgt#1#2{
	\def\temp{\expandafter\addtolength\expandafter{\csname state@radius@#1\endcsname}}
	\expandafter\temp{\expandafter-\expandafter0\expandafter.\expandafter5\csname state@linewidth@#1\endcsname}
	\expandafter\setlength\expandafter{\csname state@linewidth@#1\endcsname}{#2}
	\expandafter\temp{\expandafter0\expandafter.\expandafter5\csname state@linewidth@#1\endcsname}
}
\define@key{state@def}{tikz nodes}[true]{\ifstreq@bgt{#1}{true}{\state@delay@deffalse}{\state@delay@deftrue}}
\define@key{state@bgt}{delay}[true]{\ifstreq@bgt{#1}{true}{\state@delay@bgttrue\state@delaycontour@bgttrue}{\state@delay@bgtfalse}}
\define@key{state@bgt}{line width}{\state@setlinewidth@bgt{bgt}{#1}}
\define@key{state@def}{line width}{\state@setlinewidth@bgt{def}{#1}}
\define@key{state@bgt}{color}{\def\state@linecolor@bgt{#1}\def\state@labelcolor@bgt{#1}\state@colorprovided@bgttrue}
\define@key{state@def}{color}{\def\state@linecolor@def{#1}\def\state@labelcolor@def{#1}\state@colorprovided@bgttrue}
%\define@key{state@bgt}{label color}{\colorlet{state@labelcolor@bgt}{#1}}
\define@key{state@bgt}{label placement}{\ifstreq@bgt{#1}{simple}{\label@placement@simple@bgttrue\label@placement@box@bgtfalse}{\label@placement@simple@bgtfalse\ifstreq@bgt{#1}{box}{\label@placement@box@bgttrue}{\label@placement@box@bgtfalse}}}
\define@key{state@def}{contour}[true]{\ifstreq@bgt{#1}{true}{\state@contour@deftrue}{\ifstreq@bgt{#1}{delay}{\state@contour@deftrue\state@delaycontour@deftrue}{\state@contour@deffalse\state@delaycontour@deffalse}}}
\define@key{state@bgt}{contour}[true]{\ifstreq@bgt{#1}{true}{\state@contour@bgttrue}{\ifstreq@bgt{#1}{delay}{\state@contour@bgttrue\state@delaycontour@bgttrue}{\state@contour@bgtfalse\state@delaycontour@bgtfalse}}}
%
% accept eight standard directions directly
\def\directionkeys@bgt#1#2#3{
	\globaldefs=1
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{left}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{180}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{above}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{90}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{right}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{0}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{below}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{-90}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{above left}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{135}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{above right}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{45}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{below left}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{-135}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\edef\define@key@bgt{\noexpand\define@key{#1@bgt}{below right}[true]{\noexpand\def\expandafter\noexpand\csname#1@label@bgt\endcsname{-45}\expandafter\noexpand\csname #2@labelplacement@box@bgttrue\endcsname\expandafter\noexpand\csname#2@labelplacement@simple@bgtfalse\endcsname\noexpand#3}}
	\define@key@bgt
	\globaldefs=0
}
\directionkeys@bgt{state}{state}{}
%
\tikzset{dot/.style={draw=\state@linecolor@bgt, line width=\state@linewidth@bgt, circle, fill=\state@fill@bgt, inner sep=0pt, minimum size=2*\state@radius@bgt}}
\tikzset{circ/.style={line width=\state@linewidth@bgt, fill=\state@fill@bgt}}
\tikzset{edge/.style={line width=\state@linewidth@bgt, line join=bevel}}
%
\define@key{state@def}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\state@debug@deftrue}{\state@debug@deffalse}%
	\ifstreq@bgt{#1}{detail}{\state@debug@deftrue\debug@detail@bgttrue}{}%
}
\define@key{state@bgt}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\state@debug@bgttrue}{\state@debug@bgtfalse}%
	\ifstreq@bgt{#1}{detail}{\state@debug@bgttrue\debug@detail@bgttrue}{}%
}
%
\newlength{\@state@shift@bgt}
\def\state@opt#1at#2;{
	% process optional argument
	\ifpassoptionstotikz@bgt
		\parsekeyvalue@bgt{state}{\option@bgt}
	\else
		\expandafter\statesetoptions@bgt\expandafter{\option@bgt}
		\def\passtotikz@bgt{}
	\fi
	% read coordinate name
	\def\coordname@bgt{temp}
	\ifempty@bgt{#1}{}{
		\setsepchar{(||)}
		\readlist*\optionallist@bgt{#1}
		\ifnum\optionallist@bgtlen>1
			\itemtomacro\optionallist@bgt[2]\coordname@bgt
		\fi
	}
	% read mandatory argument
	\setsepchar{(||)/$/<||>} %$
	\readlist*\mandatorylist@bgt{#2}
	% parse and store label overlay
	\let\label@overlay@bgt\overlay@bgt
	\expandafter\ifnum\listlen\mandatorylist@bgt[\mandatorylist@bgtlen,1]>1
		\edef\label@overlay@bgt{<\mandatorylist@bgt[\mandatorylist@bgtlen,1,2]>}
		\itemtomacro\mandatorylist@bgt[\mandatorylist@bgtlen,1,3]\labeltext@bgt
	\else
		\itemtomacro\mandatorylist@bgt[\mandatorylist@bgtlen]\labeltext@bgt
	\fi
	% in belief spaces, the labels might have to be shifted
	\def\state@shift@bgt{}%
	\ifwithin@beliefspace@bgt%
		% set direction to 0 so that width of information sets is correct
		\def\state@label@bgt{0}%			
		% measure the width of the label
		\getscale@bgt%
		\ifbelief@center@measured@bgt
			\addtolength{\inform@width@bgt}{\dimexpr\inform@left@bgt+\state@labelsep@bgt+\inform@right@bgt+0.5\state@linewidth@bgt+0.5\state@radius@bgt-2pt\relax}
			\setlength{\inform@width@bgt}{\invx@bgt\inform@width@bgt}
		\else
			\ifstate@delaylabel@bgt
				% expand any \noexpands
				\edef\temp@a{\labeltext@bgt}
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture{\state@font@bgt\temp@a}\endpgfinterruptpicture}%
			\else
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture{\state@font@bgt\labeltext@bgt}\endpgfinterruptpicture}%
			\fi
			\ifbelief@state@bgt
				% the -2pt is somewhat ad hoc to correct for bounding box issues
				\addtolength{\labelwidth@bgt}{\dimexpr\inform@left@bgt+\state@labelsep@bgt+\inform@right@bgt+0.5\state@linewidth@bgt+0.5\state@radius@bgt-2pt\relax}%
			\else
				% if the state is not drawn, do not need labelsep
				\addtolength{\labelwidth@bgt}{\dimexpr\inform@left@bgt+\inform@right@bgt-3pt\relax}%
			\fi
			%
			\setlength{\labelwidth@bgt}{\invx@bgt\labelwidth@bgt}%
			% process width for information sets in belief spaces
			\ifdim\labelwidth@bgt>\inform@width@bgt%
				% make it global so it woks in iterated loops
				\global\inform@width@bgt\labelwidth@bgt%
			\fi%
			% save label width if necessary
			\ifbelief@identicalwidth@bgt\else%
				\expandafter\xdef\csname\coordname@bgt-labelwidth\endcsname{\the\labelwidth@bgt}%
			\fi%
			% shift if center option is given. the \noexpands ensure that \informwidth is not expanded until it is read back -- hopefully after all the label widths have been measured.
			\ifbelief@center@bgt
				\ifbelief@state@bgt % state is drawn
					\def\state@shift@bgt{ + 0.5*(\noexpand\dimexpr\noexpand\inform@width@bgt-\the\labelwidth@bgt\noexpand\relax, 0) + (\the\inform@left@bgt, 0)}
				\else
					\def\state@shift@bgt{ + 0.5*(\noexpand\inform@width@bgt, 0) + (\the\inform@left@bgt, 0)}
				\fi
			\else
				\ifbelief@state@bgt
					\def\state@shift@bgt{ + (\the\inform@left@bgt, 0)}
				\else
					\def\state@shift@bgt{ + 0.5*(\the\labelwidth@bgt, 0) + (\the\inform@left@bgt, 0)}
				\fi
			\fi
		\fi
	\fi
	% reparse coordinate in case it involves a computation
	\expandafter\ifnum\listlen\mandatorylist@bgt[2]>1
		% reparsing with $ in top hierarchy guarantees balanced parentheses
		\setsepchar{$} %$
		\readlist*\parsecoord@bgt{#2}
		\edef\coord@bgt{$\parsecoord@bgt[2]\state@shift@bgt$}
		\ifinform@misaligned@bgt
			\coordinate (\coordname@bgt-is) at ($\parsecoord@bgt[2]$);
		\fi
	\else
		\itemtomacro\mandatorylist@bgt[2]\coord@bgt
		\ifinform@misaligned@bgt
			\coordinate (\coordname@bgt-is) at (\coord@bgt);
			\xdef\coord@bgt{$(\coord@bgt)\state@shift@bgt$}
		\fi
	\fi
	% draw state
	\ifstate@delay@bgt%
		% get current scale
		\getscale@bgt
		\ifstreq@bgt{\coordname@bgt}{temp}{%
			% states in a belief space have to be given a label in order to draw information sets. in particular, this is not a state in a belief space
			\AtEndEnv@bgt{\noexpand\draw\overlay@bgt[draw=\state@linecolor@bgt, line width=\the\state@linewidth@bgt, fill=\state@fill@bgt, \passtotikz@bgt] (\coord@bgt) ellipse (\expandafter\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \expandafter\the\dimexpr\invy@bgt\state@radius@bgt\relax);}
		}{%
			\begingroup
				\ifwithin@beliefspace@bgt\else\belief@center@bgtfalse\belief@state@bgttrue\fi
				\ifbelief@center@bgt
					\ifbelief@state@bgt
						\AtEndEnv@bgt{\noexpand\coordinate (\coordname@bgt) at (\coord@bgt);}
					\else
						\AtEndEnv@bgt{\noexpand\node\label@overlay@bgt[\state@labelcolor@bgt, inner sep=\the\belief@innersep@bgt, font=\noexpand\state@font@bgt] (\coordname@bgt) at (\coord@bgt) {\labeltext@bgt};}
					\fi
				\else
					% define coordinate for immediate use
					\ifbelief@state@bgt
						\edef\def@coord{\noexpand\coordinate (\coordname@bgt) at (\coord@bgt);}
					\else
						\edef\def@coord{\noexpand\node\label@overlay@bgt[\state@labelcolor@bgt, inner sep=\the\belief@innersep@bgt, font=\noexpand\state@font@bgt] (\coordname@bgt) at (\coord@bgt) {\labeltext@bgt};}
					\fi
					\def@coord
				\fi
				% draw ellipse later
				\ifbelief@state@bgt
					\AtEndEnv@bgt{\noexpand\draw\overlay@bgt[draw=\state@linecolor@bgt, line width=\the\state@linewidth@bgt, fill=\state@fill@bgt, \passtotikz@bgt] (\coordname@bgt) ellipse (\expandafter\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \expandafter\the\dimexpr\invy@bgt\state@radius@bgt\relax);}
				\fi
			\endgroup
		}%
	\else%
		\begingroup
			\ifwithin@beliefspace@bgt\else\belief@center@bgtfalse\belief@state@bgttrue\fi
			\ifbelief@center@bgt
				\ifbelief@state@bgt
					\AtEndEnv@bgt{\noexpand\node\overlay@bgt[dot, \passtotikz@bgt] (\coordname@bgt) at (\coord@bgt) {};}
				\else
					\AtEndEnv@bgt{\noexpand\node\label@overlay@bgt[\state@labelcolor@bgt, inner sep=\the\belief@innersep@bgt, font=\noexpand\state@font@bgt] (\coordname@bgt) at (\coord@bgt) {\labeltext@bgt};}
				\fi
			\else
				\ifbelief@state@bgt
					\edef\draw@node{\noexpand\node\overlay@bgt[dot, \passtotikz@bgt] (\coordname@bgt) at (\coord@bgt) {};}
				\else
					\edef\draw@node{\noexpand\node\label@overlay@bgt[\state@labelcolor@bgt, inner sep=\the\belief@innersep@bgt, font=\noexpand\state@font@bgt] (\coordname@bgt) at (\coord@bgt) {\labeltext@bgt};}
				\fi
				\draw@node;
			\fi
		\endgroup
	\fi
	% add label
	\ifbelief@state@bgt% if the state isn't drawn, the label is in the tikz node
		\ifstreq@bgt{\coordname@bgt}{temp}{
			\state@placelabel@bgt{\coord@bgt}{\state@label@bgt}{\labeltext@bgt}{\overlay@bgt}{\label@overlay@bgt}
		}{
			\state@placelabel@bgt[\coordname@bgt]{\coord@bgt}{\state@label@bgt}{\labeltext@bgt}{\overlay@bgt}{\label@overlay@bgt}
		}
	\fi
}
\addoptions@bgt{state}
\addoverlay@bgt{state}
% dummy state
\def\coord#1at#2;{
	% read coordinate name
	\def\coordname@bgt{temp}
	\ifempty@bgt{#1}{}{
		\setsepchar{(||)}
		\readlist*\optionallist@bgt{#1}
		\ifnum\optionallist@bgtlen>1
			\itemtomacro\optionallist@bgt[2]\coordname@bgt
		\fi
	}
	% define coordinate
	\ifinform@misaligned@bgt
		\coordinate (\coordname@bgt-is) at #2;
	\else
		\coordinate (\coordname@bgt) at #2;
	\fi
	% save label width if necessary
	\ifbelief@identicalwidth@bgt\else%
		\expandafter\gdef\csname\coordname@bgt-labelwidth\endcsname{10pt}%
	\fi%
}
% state grids
\define@bgt@family{grid}{
	name, w;
	h, 1.2;
	v, 1;
	center, {0, 0};
	autolabel, {}
}{}{}{
	force math, false
}{
	enum, line:grid
}{}{}{}
%
\newcounter{grid@counter@bgt}
\def\stategrid@opt#1{
	\expandafter\gridsetoptions@bgt\expandafter{\option@bgt}
	\def\option@bgt{} % for \state@opt
	\setsepchar{\\/&}
	\readlist*\input@bgt{#1}
	\def\enum{}
	\ifstreq@bgt{\grid@autolabel@bgt}{}{
		% process options
		\ifgrid@enum@grid@bgt
			\def\grid@coord@bgt{\grid@name@bgt\y@bgt\x@bgt}
		\else
			\def\grid@coord@bgt{\grid@name@bgt\thegrid@counter@bgt}
		\fi
		\ifgrid@forcemath@bgt
			\def\grid@label@bgt{$\input@bgt[\y@bgt, \x@bgt]$}
		\else
			\def\grid@label@bgt{\input@bgt[\y@bgt, \x@bgt]}
		\fi
		% draw states
		\setcounter{grid@counter@bgt}{0}
		\foreach \y@bgt in {1, ..., \input@bgtlen} {
			\foreach \x@bgt in {1, ..., \numexpr\listlen\input@bgt[\y@bgt]\relax} {
				\global\stepcounter{grid@counter@bgt}
				\state@opt (\grid@coord@bgt) at (\x@bgt*\grid@h@bgt, -\y@bgt*\grid@v@bgt) {\grid@label@bgt};
		}}
	}{
		% process options
		\ifgrid@enum@grid@bgt
			\def\grid@coord@bgt{\grid@name@bgt\y@bgt\x@bgt}
			\def\enum{\y@bgt, \x@bgt}
		\else
			\def\grid@coord@bgt{\grid@name@bgt\thegrid@counter@bgt}
			\def\enum{\thegrid@counter@bgt}
		\fi
		\ifgrid@forcemath@bgt
			\def\grid@label@bgt{$\grid@autolabel@bgt$}
		\else
			\let\grid@label@bgt\grid@autolabel@bgt
		\fi
		% draw states
		\setcounter{grid@counter@bgt}{0}
		\foreach \y@bgt in {1, ..., \input@bgtlen} {
			\foreach \x@bgt in {1, ..., \input@bgt[\y@bgt]} {
				\global\stepcounter{grid@counter@bgt}
				\state@opt (\grid@coord@bgt) at (\x@bgt*\grid@h@bgt, -\y@bgt*\grid@v@bgt) {\grid@label@bgt};
		}}
	}
}
\addoptions@bgt{stategrid}
\addoverlay@bgt{stategrid}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		 2.3 Information Sets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newlength{\inform@labelradius@bgt}
\newif\ifinform@labelradius@maxdef
\def\inform@label@overlay@def{}
\newif\ifinform@open@bgt
%
% Optional arguments
\define@bgt@family{inform}{
	font, \labelfontsize;
	label, none; % center, square, or number
	curved, 0;
	line, solid;
	color, \activecolor@bgt;
	arc, 22.5
}{
	line width, \edgelinewidth@bgt;
	label sep, 0.3ex;
	extend outer, 4mm;
	extend inner, 2mm
}{}{
	base line, false;
	contour, false;
	delay contour, false;
	dashed, false;
	debug, false;
	very sticky, false
}{
	exterior, extend:arc
}{%
%	color, activecolor@bgt
}{}{%
%	\inform@selectplayer@bgt%
	\let\inform@label@overlay@bgt\inform@label@overlay@def
}
%
\directionkeys@bgt{inform}{inform}{}
\define@key@thickness@bgt{inform}
% two levels of sticky
\define@key{inform@bgt}{very sticky}[true]{\ifstreq@bgt{#1}{true}{\inform@verysticky@bgttrue\inform@sticky@bgttrue}{\ifstreq@bgt{#1}{false}{\inform@verysticky@bgtfalse}{}}}
\define@key{inform@bgt}{sticky}[true]{\ifstreq@bgt{#1}{true}{\inform@sticky@bgttrue}{\ifstreq@bgt{#1}{false}{\inform@verysticky@bgtfalse\inform@sticky@bgtfalse}{}}}
\define@key{inform@def}{very sticky}[true]{\ifstreq@bgt{#1}{true}{\inform@verysticky@deftrue\inform@sticky@deftrue}{\ifstreq@bgt{#1}{false}{\inform@verysticky@deffalse}{}}}
\define@key{inform@def}{sticky}[true]{\ifstreq@bgt{#1}{true}{\inform@sticky@deftrue}{\ifstreq@bgt{#1}{false}{\inform@verysticky@deffalse\inform@sticky@deffalse}{}}}
\define@key{inform@bgt}{extend}{\setsepchar{,}\readlist*\inform@in@bgt{#1}\itemtomacro\inform@in@bgt[1]\inform@extendinner@bgt\itemtomacro\inform@in@bgt[2]\inform@extendouter@bgt}
% Sticky options
\define@key{inform@bgt}{radius}{\setlength{\inform@radius@bgt}{#1}}
\define@key{inform@bgt}{player}{
	\setcounter{activeplayer@bgt}{#1}
	\inform@selectplayer@bgt
	\ifwithin@beliefspace@bgt % I imagine for a tree you don't want to style information sets too much
		\ifinform@verysticky@bgt\else
			\iflabel@dirprovided@bgt\else%
				\let\inform@label@bgt\inform@label@def%
			\fi%
			\setiftodefault@bgt{inform@contour}%
			\setiftodefault@bgt{inform@delaycontour}%
	\fi\fi
}
\define@key{inform@bgt}{dashed}[true]{%
	\ifstreq@bgt{#1}{true}{%
		\inform@dashed@bgttrue%
		\ifinform@labelsuppress@bgt\else%
			\def\inform@label@bgt{135}%
		\fi%
	}{%
		\inform@dashed@bgtfalse%
		\ifinform@labelsuppress@bgt\else%
			\def\inform@label@def{center}%
		\fi%
}}
\define@key{inform@bgt}{curved}[20]{%
	\def\inform@curved@bgt{#1}\def\inform@curved@def{#1}
	\inform@dashed@bgttrue%
	\ifinform@labelsuppress@bgt\else%
		\def\inform@label@bgt{135}%
	\fi%
} 
% labels
\define@key{inform@def}{contour}[true]{\ifstreq@bgt{#1}{true}{\inform@contour@deftrue}{\ifstreq@bgt{#1}{delay}{\inform@contour@deftrue\inform@delaycontour@bgttrue}{\inform@contour@deffalse\inform@delaycontour@bgtfalse}}}
\define@key{inform@bgt}{contour}[true]{\ifstreq@bgt{#1}{true}{\inform@contour@bgttrue}{\ifstreq@bgt{#1}{delay}{\inform@contour@bgttrue\inform@delaycontour@bgttrue}{\inform@contour@bgtfalse\inform@delaycontour@bgtfalse}}}
\define@key{inform@def}{label radius}{\ifstreq@bgt{#1}{max}{\inform@labelradius@maxdeftrue}{\inform@labelradius@maxdeffalse}}
% BB 0411: needs more options
\define@key{inform@bgt}{label}{\parse@label@bgt{#1}}
\define@key{inform@bgt}{label radius}{\parse@labelradius@bgt{#1}}
%
\define@key{inform@def}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\inform@debug@deftrue}{\inform@debug@deffalse}%
	\ifstreq@bgt{#1}{detail}{\inform@debug@deftrue\debug@detail@bgttrue}{}%
}
\define@key{inform@bgt}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\inform@debug@bgttrue}{\inform@debug@bgtfalse}%
	\ifstreq@bgt{#1}{detail}{\inform@debug@bgttrue\debug@detail@bgttrue}{}%
}
%
\def\parse@labelradius@bgt#1{
	\setsepchar{:}	
	\readlist*\sepdetails@bgt{#1}
	\ifnum\sepdetails@bgtlen>1
		\edef\radius@bgt{\noexpand\dimexpr\csname playerradius\romannumeral\sepdetails@bgt[1]@bgt\endcsname + \sepdetails@bgt[2]\noexpand\relax}
		\expandafter\global\expandafter\inform@labelradius@bgt\radius@bgt
	\else
		\expandafter\ifisnum@bgt\expandafter{\sepdetails@bgt[1]}{
			\expandafter\global\expandafter\inform@labelradius@bgt\csname playerradius\romannumeral\sepdetails@bgt[1]@bgt\endcsname
		}{
			\expandafter\global\expandafter\inform@labelradius@bgt\sepdetails@bgt[1]
		}
	\fi
}
\def\parse@label@bgt#1{
	\setsepchar{:}	
	\readlist*\sepdetails@bgt{#1}
	\ifnum\sepdetails@bgtlen>1
		\xdef\inform@label@bgt{\sepdetails@bgt[1]}
		\ifnum\sepdetails@bgtlen>2
			\edef\radius@bgt{\noexpand\dimexpr\csname playerradius\romannumeral\sepdetails@bgt[2]@bgt\endcsname + \sepdetails@bgt[3]\noexpand\relax}
			\expandafter\global\expandafter\inform@labelradius@bgt\radius@bgt
		\else
			\expandafter\ifisnum@bgt\expandafter{\sepdetails@bgt[2]}{
				\expandafter\global\expandafter\inform@labelradius@bgt\csname playerradius\romannumeral\sepdetails@bgt[2]@bgt\endcsname
			}{
				\expandafter\global\expandafter\inform@labelradius@bgt\sepdetails@bgt[2]
			}
		\fi
	\else
		\gdef\inform@label@bgt{#1}
	\fi
	\process@direction{\inform@label@bgt}
	\label@dirprovided@bgttrue%
}
%
% if in a game tree and informset is dashed, then default label is 135
%
\newif\ifinform@outsidelabel@bgt
\def\inform@placelabel@bgt#1#2#3#4#5#6#7{
% #1: first coordinate
% #2: last coordinate
% #3: center coordinate
% #4: square coordinate
% #5: label text
% #6: outer overlay specification
% #7: inner overlay specification
	\inform@outsidelabel@bgtfalse%
	\ifstreq@bgt{\inform@label@bgt}{none}{}{%
		\ifstreq@bgt{\inform@label@bgt}{center}{%
			% baseline options
			\ifinform@baseline@bgt%
				\getscale@bgt%
				\pgfmathsetmacro{\invy@bgt}{1/\yscale@bgt}%
				\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\inform@font@bgt#5}\endpgfinterruptpicture}%
				\setlength{\state@voffset@bgt}{\invy@bgt\labeldepth@bgt}%
			\else%
				\setlength{\state@voffset@bgt}{0pt}
			\fi%
			\ifinform@contour@bgt%
				\ifinform@delaycontour@bgt
					\AtEndEnv@bgt{\noexpand\visible#6{\noexpand\node#7[\inform@color@bgt, font=\noexpand\inform@font@bgt] at ($(#3) - 0.5*(0,\the\state@voffset@bgt)$) {\noexpand\contour{xg-bg}{#5}};}}%
				\else
					\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#3) - 0.5*(0,\state@voffset@bgt)$) {\contour{xg-bg}{#5}};}%
				\fi
			\else%
				\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#3) - 0.5*(0,\state@voffset@bgt)$) {#5};}%
			\fi
		}{%
			\ifstreq@bgt{\inform@label@bgt}{square}{%
				% baseline options
				\ifinform@baseline@bgt%
					\getscale@bgt%
					\pgfmathsetmacro{\invy@bgt}{1/\yscale@bgt}%
					\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\inform@font@bgt#5}\endpgfinterruptpicture}%
					\setlength{\state@voffset@bgt}{\invy@bgt\labeldepth@bgt}%
				\else%
					\setlength{\state@voffset@bgt}{0pt}
				\fi%
				\ifinform@contour@bgt%
					\ifinform@delaycontour@bgt
						\AtEndEnv@bgt{\noexpand\visible#6{\noexpand\node#7[\inform@color@bgt, font=\noexpand\inform@font@bgt] at ($(#4) - 0.5*(0,\the\state@voffset@bgt)$) {\noexpand\contour{xg-bg}{#5}};}}%
					\else
						\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#4) - 0.5*(0,\state@voffset@bgt)$) {\contour{xg-bg}{#5}};}%
					\fi
				\else%
					\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#4) - 0.5*(0,\state@voffset@bgt)$) {#5};}%
				\fi
			}{%
				\pgfmathsetmacro{\inform@label@bgt}{\inform@label@bgt}
				\ifdim\inform@label@bgt pt<1pt%
					\ifdim\inform@label@bgt pt>0pt%
						\ifinform@dashed@bgt%
							\pgfextractangle{\angle@bgt}{#1}{#2}%
							\pgfmathsetmacro{\labelangle@bgt}{\angle@bgt-90}%
							\begingroup%
								\ifinform@baseline@bgt\state@baseline@bgttrue\else\state@baseline@bgtfalse\fi%
								\ifinform@debug@bgt\state@debug@bgttrue\else\state@debug@bgtfalse\fi%
								\ifinform@contour@bgt\state@contour@bgttrue\else\state@contour@bgtfalse\fi%
								\ifinform@delaycontour@bgt\state@delaycontour@bgttrue\else\state@delaycontour@bgtfalse\fi%
								\expandafter\placelabel@bgt\expandafter{\inform@color@bgt}{$(#1)!\inform@label@bgt!(#2)$}{\labelangle@bgt}{\dimexpr0.5\inform@linewidth@bgt + \edge@labelsep@bgt\relax}{\inform@font@bgt}{#5}{#6}{#7}%
							\endgroup%
						\else%
							% baseline options
							\ifinform@baseline@bgt%
								\getscale@bgt%
								\pgfmathsetmacro{\invy@bgt}{1/\yscale@bgt}%
								\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\inform@font@bgt#5}\endpgfinterruptpicture}%
								\setlength{\state@voffset@bgt}{\invy@bgt\labeldepth@bgt}%
							\else%
								\setlength{\state@voffset@bgt}{0pt}
							\fi%
							% debug option missing
							\ifinform@contour@bgt%
								\ifinform@delaycontour@bgt
									\AtEndEnv@bgt{\noexpand\visible#6{\noexpand\node#7[\inform@color@bgt, font=\noexpand\inform@font@bgt] at ($(#1)!\inform@label@bgt!(#2) - 0.5*(0,\state@voffset@bgt)$) {\noexpand\contour{xg-bg}{#5}};}}%
								\else
									\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#1)!\inform@label@bgt!(#2) - 0.5*(0,\state@voffset@bgt)$) {\contour{xg-bg}{#5}};}%
								\fi
							\else%
								\expandafter\visible#6{\expandafter\node#7[\inform@color@bgt, font=\inform@font@bgt] at ($(#1)!\inform@label@bgt!(#2) - 0.5*(0,\state@voffset@bgt)$) {#5};}%
						\fi\fi%
					\else%
						\inform@outsidelabel@bgttrue%
					\fi%
				\else%
					\inform@outsidelabel@bgttrue%
				\fi%
				%
				\ifinform@outsidelabel@bgt%
					\ifwithin@beliefspace@bgt%
						\pgfmathtruncatemacro{\roundedangle@bgt}{Mod(\inform@label@bgt, 360)}%
						% BB: should I not scale \inform@width@bgt with \xscale@bgt?
						\ifdim\roundedangle@bgt pt=90pt%
							\def\label@anchor@bgt{$(#1) + 0.5*(\inform@width@bgt, 0)$}%
						\else\ifdim\roundedangle@bgt pt=270pt%
							\def\label@anchor@bgt{$(#1) + 0.5*(\inform@width@bgt, 0)$}%
						\else\ifdim\roundedangle@bgt pt<270pt%
							\ifdim\roundedangle@bgt pt>90pt%
								\def\label@anchor@bgt{#1}%
							\else%
								\def\label@anchor@bgt{$(#1) + (\inform@width@bgt, 0)$}%
							\fi%
						\else%
							\def\label@anchor@bgt{$(#1) + (\inform@width@bgt, 0)$}%
						\fi\fi\fi%
						%\expandafter\draw\expandafter(\label@anchor@bgt) circle (2pt);
						\getscale@bgt%
						% BB: scaling with xscale is imperfect
						\begingroup%
							\ifinform@baseline@bgt\state@baseline@bgttrue\else\state@baseline@bgtfalse\fi%
							\ifinform@debug@bgt\state@debug@bgttrue\else\state@debug@bgtfalse\fi%
							\ifinform@contour@bgt\state@contour@bgttrue\else\state@contour@bgtfalse\fi%
							\ifinform@delaycontour@bgt\state@delaycontour@bgttrue\else\state@delaycontour@bgtfalse\fi%
							\placelabel@bgt{\inform@color@bgt}{\label@anchor@bgt}{\inform@label@bgt}{\expandafter\the\dimexpr0.5\inform@linewidth@bgt + \xscale@bgt\inform@labelradius@bgt + \inform@labelsep@bgt\relax}{\inform@font@bgt}{#5}{#6}{#7}%
						\endgroup%
					\else%
						\begingroup%
							\ifinform@baseline@bgt\state@baseline@bgttrue\else\state@baseline@bgtfalse\fi%
							\ifinform@debug@bgt\state@debug@bgttrue\else\state@debug@bgtfalse\fi%
							\ifinform@contour@bgt\state@contour@bgttrue\else\state@contour@bgtfalse\fi%
							\ifinform@delaycontour@bgt\state@delaycontour@bgttrue\else\state@delaycontour@bgtfalse\fi%
							\def\label@anchor@bgt{$(#1) + 0.5*(\inform@width@bgt, 0)$}%
							\ifinform@dashed@bgt%
								\placelabel@bgt{\inform@color@bgt}{\label@anchor@bgt}{\inform@label@bgt}{\expandafter\the\dimexpr0.5\state@linewidth@bgt + \state@labelsep@bgt + \state@radius@bgt\relax}{\inform@font@bgt}{#5}{#6}{#7}%
							\else%
								\placelabel@bgt{\inform@color@bgt}{\label@anchor@bgt}{\inform@label@bgt}{\expandafter\the\dimexpr0.5\inform@linewidth@bgt + \xscale@bgt\inform@labelradius@bgt + \inform@labelsep@bgt\relax}{\inform@font@bgt}{#5}{#6}{#7}%
							\fi%
						\endgroup%
				\fi\fi%
}}}}%
%
%
\def\inform@draw@instruction@bgt{}
\def\addto@informset@bgt#1{\xdef\inform@draw@instruction@bgt{\inform@draw@instruction@bgt #1}}
\def\finalize@informset@bgt{%
	\ifstreq@bgt{\inform@line@bgt}{solid}{
		\def\temp{\expandafter\draw\overlay@bgt[line width=\inform@linewidth@bgt, color=\inform@color@bgt]}
	}{
		\def\temp{\expandafter\draw\overlay@bgt[line width=\inform@linewidth@bgt, color=\inform@color@bgt, \inform@line@bgt]}
	}
	\expandafter\temp\inform@draw@instruction@bgt;
	\gdef\inform@draw@instruction@bgt{}
}
%
\newlength{\segment@length@bgt}
\newif\ifoutwardturn@bgt
\newif\ifnextoutwardturn@bgt
\newif\iftrailin@bgt
\newif\iftrailout@bgt
\newlength{\shorten@path@bgt}
\def\determine@outwardturns@bgt#1#2#3{
	% reset
	\nextoutwardturn@bgtfalse
	\outwardturn@bgtfalse
	% determine if this is an outward turn
	\pgfmathsetmacro{\anglediff@bgt}{Mod(\angle@bgt-\prevangle@bgt+180, 360)}
	\ifdim\anglediff@bgt pt<180pt
		\ifdim\anglediff@bgt pt>0pt
			\outwardturn@bgttrue
		\fi
	\fi
	% determine if the next turn is an outward turn
	\pgfextractangle{\nextangle@bgt}{#2}{#3}
	\pgfmathsetmacro{\anglediff@bgt}{Mod(\nextangle@bgt-\angle@bgt+180, 360)}
	\ifdim\anglediff@bgt pt<180pt
		\ifdim\anglediff@bgt pt>0pt
			\nextoutwardturn@bgttrue
		\fi
	\fi
	\xdef\nextcoord@bgt{#2}
}
\def\drawsegment@bgt#1#2{
	% Length of regular segment
	\tikz@scan@one@point\pgfutil@firstofone($(#2)-(#1)$)\relax
	\pgfmathparse{100*sqrt((\the\pgf@x/100)^2 + (\the\pgf@y/100)^2)}
	\setlength{\segment@length@bgt}{\pgfmathresult pt}
	% reset informwidth to width of label
	\ifbelief@identicalwidth@bgt
		\edef\firstwidth@bgt{\the\inform@width@bgt}
		\edef\secondwidth@bgt{\the\inform@width@bgt}
	\else
		\expandafter\let\expandafter\firstwidth@bgt\csname#1-labelwidth\endcsname
		\expandafter\let\expandafter\secondwidth@bgt\csname#2-labelwidth\endcsname
	\fi
	% Deal with special cases
	\ifoutwardturn@bgt\else
		% go to center of node
		\iftrailin@bgt
			\addto@informset@bgt{++(\prevangle@bgt+90:\the\inform@radius@bgt)}
		\fi
		% add an extra step if the angle crosses 0 or 180
		\ifdim\angle@bgt pt=0pt
			\ifnextoutwardturn@bgt\else
				\addtolength{\segment@length@bgt}{\secondwidth@bgt}
			\fi
		\else\ifdim\angle@bgt pt<180pt
			\ifdim\prevangle@bgt pt<180pt\else
				\iftrailin@bgt
					\addto@informset@bgt{ ++(\firstwidth@bgt, 0)}
				\else
					\addto@informset@bgt{arc(\prevangle@bgt-90:270:\the\inform@radius@bgt) -- ++(\firstwidth@bgt, 0)}
				\fi
  				\pgfmathtruncatemacro{\prevangle@bgt}{0}%
			\fi
		\else\ifdim\angle@bgt pt=180pt
			\ifnextoutwardturn@bgt\else
				\addtolength{\segment@length@bgt}{\firstwidth@bgt}
			\fi
		\else
			\ifdim\prevangle@bgt pt<180pt
				\iftrailin@bgt
					\addto@informset@bgt{ ++(-\secondwidth@bgt, 0)}
				\else
					\addto@informset@bgt{arc(\prevangle@bgt-90:90:\the\inform@radius@bgt) -- ++(-\secondwidth@bgt, 0)}
				\fi
				\pgfmathtruncatemacro{\prevangle@bgt}{180}%
			\fi
		\fi\fi\fi
	\fi
	% shorten the next segment in case of an outward turn
	\ifnextoutwardturn@bgt
		\pgfmathsetmacro{\shorten@end@bgt}{tan((\angle@bgt-\nextangle@bgt)/2)*\inform@radius@bgt*2}
	\else
		\def\shorten@end@bgt{0}
	\fi
	\ifdim\prevangle@bgt pt >\angle@bgt pt
		\pgfmathsetmacro{\prevangle@bgt}{\prevangle@bgt-360}
	\fi
	% draw regular segment
	\setlength{\shorten@path@bgt}{\dimexpr\shorten@front@bgt pt + \shorten@end@bgt pt\relax}
	\ifoutwardturn@bgt
		\ifnextoutwardturn@bgt
			\addtolength{\shorten@path@bgt}{\inform@width@bgt}
	\fi\fi
	% outward turns
	\ifoutwardturn@bgt
		\ifdim\angle@bgt pt<\prevangle@bgt pt
			\iftrailin@bgt
				\addto@informset@bgt{++(\prevangle@bgt-90:\the\inform@radius@bgt)++(\angle@bgt+90:\the\inform@radius@bgt)}
			\else
				\addto@informset@bgt{arc(\prevangle@bgt+90:\angle@bgt+90:\the\inform@radius@bgt)}
			\fi
		\else
			\iftrailin@bgt
				\addto@informset@bgt{++(\prevangle@bgt-90:\the\inform@radius@bgt)++(\angle@bgt-270:\the\inform@radius@bgt)}
			\else
				\addto@informset@bgt{arc(\prevangle@bgt+90:\angle@bgt-270:\the\inform@radius@bgt)}
			\fi
		\fi
	\else
		\iftrailin@bgt
			\addto@informset@bgt{++(\angle@bgt-90:\the\inform@radius@bgt)}
		\else
			\addto@informset@bgt{arc(\prevangle@bgt-90:\angle@bgt-90:\the\inform@radius@bgt)}
		\fi
	\fi
	\iftrailout@bgt
		\expandafter\ifdim\dimexpr0.6\segment@length@bgt-\shorten@path@bgt\relax<0pt
			\setlength{\segment@length@bgt}{\dimexpr2.5\segment@length@bgt-2.5\shorten@path@bgt\relax} %1/0.475
		\else
			\addto@informset@bgt{ -- ++(\angle@bgt:\expandafter\the\dimexpr0.6\segment@length@bgt-\shorten@path@bgt\relax)}
		\fi
		\addto@informset@bgt{++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.135\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.065\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.035\segment@length@bgt\relax)}
	\else\iftrailin@bgt
		\expandafter\ifdim\dimexpr0.6\segment@length@bgt-\shorten@path@bgt\relax<0pt
			\setlength{\segment@length@bgt}{\dimexpr2.5\segment@length@bgt-2.5\shorten@path@bgt\relax} %1/0.475
		\fi
		\addto@informset@bgt{-- ++(\angle@bgt:\expandafter\the\dimexpr0.035\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.065\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.135\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.055\segment@length@bgt\relax)}
		\expandafter\ifdim\dimexpr0.6\segment@length@bgt-\shorten@path@bgt\relax<0pt\else
			\addto@informset@bgt{ -- ++(\angle@bgt:\expandafter\the\dimexpr0.6\segment@length@bgt-\shorten@path@bgt\relax)}
		\fi
	\else
		\addtolength{\segment@length@bgt}{-\the\shorten@path@bgt}
		\ifinform@open@bgt
			\ifbelief@identicalwidth@bgt
				\addto@informset@bgt{-- ++(\angle@bgt:\expandafter\the\dimexpr0.29\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.06\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.29\segment@length@bgt\relax)}
			\else
				\addtolength{\segment@length@bgt}{-\firstwidth@bgt}
				\addtolength{\segment@length@bgt}{-\secondwidth@bgt}
				\addto@informset@bgt{-- ++(\angle@bgt:\expandafter\the\dimexpr\firstwidth@bgt+0.185\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax)
						 ++(\angle@bgt:\expandafter\the\dimexpr0.09\segment@length@bgt\relax) --
						 ++(\angle@bgt:\expandafter\the\dimexpr\secondwidth@bgt+0.185\segment@length@bgt\relax)}
			\fi
		\else
			\addto@informset@bgt{ -- ++(\angle@bgt:\the\segment@length@bgt)}
	\fi\fi\fi
	\global\let\prevangle@bgt\angle@bgt
	\global\let\angle@bgt\nextangle@bgt
	\global\let\thiscoord@bgt\nextcoord@bgt
	\global\let\shorten@front@bgt\shorten@end@bgt
}
%
\newdimen\pgf@coord@bgt%
%
% Parts of the following macro are due to Simon Byrne and Jake, taken from https://tex.stackexchange.com/questions/27171/padded-boundary-of-convex-hull. My thanks also go to user237285 who answered a clarifying question I had at https://tex.stackexchange.com/a/586841/203616. [ ] 
%
\newcounter{infparse@e}
\newcounter{infparse@above}
\newcounter{infparse@below}
\newcounter{infparse@left}
\newcounter{infparse@right}
\newcounter{infparse@open}
\newcounter{infparse@in}
\newcounter{infparse@out}
\def\addto@seplist@bgt#1{%
	\ifstreq@bgt{\inform@seplist@bgt}{}{%
		\xdef\inform@seplist@bgt{#1}%
	}{%
		\xdef\inform@seplist@bgt{\inform@seplist@bgt, #1}%
	}%
}
\def\addto@nodelist@bgt#1{%
	\ifstreq@bgt{\inform@nodelist@bgt}{}{%
		\xdef\inform@nodelist@bgt{#1}%
	}{%
		\xdef\inform@nodelist@bgt{\inform@nodelist@bgt, #1}%
	}%
}
\def\parse@infsep@bgt#1{
	% reset
	\gdef\inform@seplist@bgt{}
	\gdef\inform@nodelist@bgt{}
	\setcounter{infparse@e}{0}
	\setcounter{infparse@above}{0}
	\setcounter{infparse@below}{0}
	\setcounter{infparse@left}{0}
	\setcounter{infparse@right}{0}
	\setcounter{infparse@open}{0}
	\setcounter{infparse@in}{0}
	\setcounter{infparse@out}{0}
	% parse input
	\ifinform@misaligned@bgt\def\is@bgt{-is}\else\def\is@bgt{}\fi
	\setsepchar{--/../-./.-/~~/~^~/~v~/~<~/~>~}
	\readlist*\seplist@bgt{#1}
	% extract separators
	\foreach \r@bgt in {1, ..., \seplist@bgtlen} {
		\pgfmathtruncatemacro{\num@open@bgt}{\listlen\seplist@bgt[\r@bgt]}
		\foreach \open@bgt in {1, ..., \num@open@bgt} {
			\pgfmathtruncatemacro{\num@out@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt]}
			\foreach \out@bgt in {1, ..., \num@out@bgt} {
				\pgfmathtruncatemacro{\num@in@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt]}
				\foreach \in@bgt in {1, ..., \num@in@bgt} {
					\pgfmathtruncatemacro{\num@e@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt]}
					\foreach \e@bgt in {1, ..., \num@e@bgt} {
						\pgfmathtruncatemacro{\num@above@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt, \e@bgt]}
						\foreach \above@bgt in {1, ..., \num@above@bgt} {
							\pgfmathtruncatemacro{\num@below@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt, \e@bgt, \above@bgt]}
							\foreach \below@bgt in {1, ..., \num@below@bgt} {
								\pgfmathtruncatemacro{\num@left@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt, \e@bgt, \above@bgt, \below@bgt]}
								\foreach \left@bgt in {1, ..., \num@left@bgt} {
									\pgfmathtruncatemacro{\num@right@bgt}{\listlen\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt, \e@bgt, \above@bgt, \below@bgt, \left@bgt]}
									\foreach \right@bgt in {1, ..., \num@right@bgt} {
										\itemtomacro\seplist@bgt[\r@bgt, \open@bgt, \out@bgt, \in@bgt, \e@bgt, \above@bgt, \below@bgt, \left@bgt, \right@bgt]\currentcoord@bgt
										\insidepair()\currentcoord@bgt\coord@bgt
										\addto@nodelist@bgt{\coord@bgt\is@bgt}
										
										\ifnum\right@bgt<\num@right@bgt
											\addto@seplist@bgt{~>~}
											\stepcounter{infparse@right}
											\stepcounter{infparse@e}
										\fi
									}
									\ifnum\left@bgt<\num@left@bgt
										\addto@seplist@bgt{~<~}
										\stepcounter{infparse@left}
										\stepcounter{infparse@e}
									\fi
								}
								\ifnum\below@bgt<\num@below@bgt
									\addto@seplist@bgt{~v~}
									\stepcounter{infparse@below}
									\stepcounter{infparse@e}
								\fi
							}
							\ifnum\above@bgt<\num@above@bgt
								\addto@seplist@bgt{~^~}
								\stepcounter{infparse@above}
								\stepcounter{infparse@e}
							\fi
						}
						\ifnum\e@bgt<\num@e@bgt
							\addto@seplist@bgt{~~}
							\stepcounter{infparse@e}
						\fi
					}
					\ifnum\in@bgt<\num@in@bgt
						\addto@seplist@bgt{.-}
						\stepcounter{infparse@in}
					\fi
				}
				\ifnum\out@bgt<\num@out@bgt
					\addto@seplist@bgt{-.}
					\stepcounter{infparse@out}
				\fi
			}
			\ifnum\open@bgt<\num@open@bgt
				\addto@seplist@bgt{..}
				\stepcounter{infparse@open}
			\fi
		}
		\ifnum\r@bgt<\seplist@bgtlen
			\addto@seplist@bgt{--}
		\fi
	}
	% last separator
	\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@e}, 2)}
	\ifnum\m@bgt=1
		\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@above}, 2)}
		\ifnum\m@bgt=1
			\addto@seplist@bgt{~^~}
		\else
			\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@below}, 2)}
			\ifnum\m@bgt=1
				\addto@seplist@bgt{~v~}
			\else
				\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@left}, 2)}
				\ifnum\m@bgt=1
					\addto@seplist@bgt{~<~}
				\else
					\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@right}, 2)}
					\ifnum\m@bgt=1
						\addto@seplist@bgt{~>~}
					\else
						\addto@seplist@bgt{~~}
		\fi\fi\fi\fi
	\else
		\pgfmathtruncatemacro{\m@bgt}{mod(\value{infparse@open}, 2)}
		\ifnum\m@bgt=1
			\addto@seplist@bgt{..}
		\else
			\ifnum\value{infparse@out}=\value{infparse@in}
				\addto@seplist@bgt{--}
			\else\ifnum\value{infparse@out}>\value{infparse@in}
					\addto@seplist@bgt{.-}
				\else
					\addto@seplist@bgt{-.}
	\fi\fi\fi\fi
	% parse again
	\setsepchar{,}
	\expandafter\readlist\expandafter*\expandafter\seplist@bgt\expandafter{\inform@seplist@bgt}
	\expandafter\readlist\expandafter*\expandafter\nodelist@bgt\expandafter{\inform@nodelist@bgt}
}
\def\test{\inform@nodelist@bgt}

\def\initialize@informset@bgt#1#2#3{
	% #1: last state
	% #2: first state
	% #3: second state
	% extact starting angles
	\pgfextractangle{\thisangle@bgt}{#1}{#2}
	\global\let\prevangle@bgt\thisangle@bgt
	\pgfextractangle{\thisangle@bgt}{#2}{#3}
	\global\let\angle@bgt\thisangle@bgt
	% deal with extension
	\determine@outwardturns@bgt{#1}{#2}{#3}
	\ifnextoutwardturn@bgt
		\outwardturn@bgttrue
	\fi
	\def\j@bgt{1}
%	\edef\nextcoord@bgt{#2}
	\next@extended@bgtfalse
	\check@extended@bgt{\j@bgt}
	\ifextended@bgt
		\next@extended@bgttrue
	\fi
	\check@extended@bgt{\seplist@bgtlen}
	\ifextended@bgt
		\extend@outwards@bgt{\seplist@bgtlen}{1}
		\ifnext@extended@bgt
			\global\let\prevangle@bgt\offsetangle@bgt
		\fi
	\fi
	\global\let\thiscoord@bgt\nextcoord@bgt
	% 
	\addto@informset@bgt{($(\thiscoord@bgt)}%$
	\ifdim\prevangle@bgt pt<180pt%
		\ifbelief@identicalwidth@bgt
			\edef\firstwidth@bgt{\the\inform@width@bgt}
		\else
			\expandafter\let\expandafter\firstwidth@bgt\csname#2-labelwidth\endcsname
		\fi
		\addto@informset@bgt{ + (\firstwidth@bgt, 0)}
	\fi
	\addto@informset@bgt{ + (\prevangle@bgt-90:\the\inform@radius@bgt)$)}%$
	\def\shorten@front@bgt{0}
	%
	\comment{
	% to start in inside turn of ~^~
	\ifnext@extended@bgt
		\ifextended@bgt
			\let\eventualangle@bgt\nextangle@bgt
			\coordinate (\nodelist@bgt[\j@bgt]-inner) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\dimexpr2\inform@radius@bgt+\inform@extendinner@bgt\relax)$);
			\outwardturn@bgtfalse
			\nextoutwardturn@bgtfalse
			\pgfmathsetmacro{\angle@bgt}{\offsetangle@bgt+180}
			\let\nextangle@bgt\offsetangle@bgt
			\xdef\debugcode{\debugcode; \angle@bgt, \nextangle@bgt}
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
			\nextoutwardturn@bgttrue
			\let\nextangle@bgt\eventualangle@bgt
			\xdef\debugcode{\debugcode; \angle@bgt, \nextangle@bgt}
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-inner}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
		\fi
	\fi
	}
}

\newif\ifcentersquare@complete@bgt
% before for loop
\def\initialize@centersquare@bgt{%
	\def\center@x@bgt{0}%
	\def\center@y@bgt{0}%
	\def\square@xmin@bgt{16000}%
	\def\square@xmax@bgt{-16000}%
	\def\square@ymin@bgt{16000}%
	\def\square@ymax@bgt{-16000}%
	\centersquare@complete@bgtfalse%
}
% inside for loop
\def\centersquare@bgt#1{
	\ifcentersquare@complete@bgt\else
		% Compute center x
		\pgfextractx{\pgf@coord@bgt}{\pgfpointanchor{\nodelist@bgt[#1]}{center}}
		\pgfmathadd{\center@x@bgt}{\pgf@coord@bgt}
		\global\let\center@x@bgt\pgfmathresult
		% Compute square x
		\pgfmathparse{\pgf@coord@bgt}
		\ifdim\pgfmathresult pt<\square@xmin@bgt pt
			\global\let\square@xmin@bgt\pgfmathresult
		\fi
		\ifdim\pgfmathresult pt>\square@xmax@bgt pt
			\global\let\square@xmax@bgt\pgfmathresult
		\fi
		% Compute center y
		\pgfextracty{\pgf@coord@bgt}{\pgfpointanchor{\nodelist@bgt[#1]}{center}}
		\pgfmathadd{\center@y@bgt}{\pgf@coord@bgt}
		\global\let\center@y@bgt\pgfmathresult
		% Compute square y
		\pgfmathparse{\pgf@coord@bgt}
		\ifdim\pgfmathresult pt<\square@ymin@bgt pt
			\global\let\square@ymin@bgt\pgfmathresult
		\fi
		\ifdim\pgfmathresult pt>\square@ymax@bgt pt
			\global\let\square@ymax@bgt\pgfmathresult
		\fi
	\fi
}
% after for loop
\def\finalize@centersquare@bgt{
	\pgfmathparse{\center@x@bgt/\n@nodes@bgt}
	\global\let\center@x@bgt\pgfmathresult
	\pgfmathparse{\center@y@bgt/\n@nodes@bgt}
	\global\let\center@y@bgt\pgfmathresult
	%
	\pgfmathparse{0.5*\square@xmin@bgt+0.5*\square@xmax@bgt}
	\global\let\square@x@bgt\pgfmathresult
	\pgfmathparse{0.5*\square@ymin@bgt+0.5*\square@ymax@bgt}
	\global\let\square@y@bgt\pgfmathresult
	%
	\ifwithin@beliefspace@bgt
		\pgfmathadd{\center@x@bgt}{0.5*\inform@width@bgt}
		\global\let\center@x@bgt\pgfmathresult
		\pgfmathadd{\square@x@bgt}{0.5*\inform@width@bgt}
		\global\let\square@x@bgt\pgfmathresult
	\fi
	\edef\center@coord@bgt{\center@x@bgt pt, \center@y@bgt pt}
	\edef\square@coord@bgt{\square@x@bgt pt, \square@y@bgt pt}
}

\newif\ifextended@bgt
\newif\ifnext@extended@bgt
\def\check@extended@bgt#1{
	% #1: index to check for
	% #2: first index of information set
	\extended@bgtfalse
	\ifstreq@bgt{\seplist@bgt[#1]}{~^~}{
		\def\offsetangle@bgt{90}
		\extended@bgttrue
	}{
		\ifstreq@bgt{\seplist@bgt[#1]}{~v~}{
			\def\offsetangle@bgt{-90}
			\extended@bgttrue
		}{
			\ifstreq@bgt{\seplist@bgt[#1]}{~<~}{
				\def\offsetangle@bgt{180}
				\extended@bgttrue
			}{
				\ifstreq@bgt{\seplist@bgt[#1]}{~<~}{
					\def\offsetangle@bgt{0}
					\extended@bgttrue
				}{
					\ifstreq@bgt{\seplist@bgt[#1]}{~~}{
						\extended@bgttrue
						\if#1\j@bgt
							\let\offsetangle@bgt\angle@bgt
						\else
							\pgfmathsetmacro{\offsetangle@bgt}{\nextangle@bgt+180}
						\fi
					}{
	}}}}}
}
\def\extend@outwards@bgt#1#2{
	\ifinform@exterior@arc@bgt\else
		\if#1\j@bgt
			\ifnextoutwardturn@bgt
				\coordinate (\nodelist@bgt[\j@bgt]-inner) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\dimexpr2\inform@radius@bgt+\inform@extendinner@bgt\relax)$);
				\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-inner}
			\else
				\coordinate (\nodelist@bgt[\j@bgt]-outer) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\inform@extendouter@bgt)$);
				\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-outer}
			\fi
		\else
			\ifcentersquare@complete@bgt\else
				\pgfmathparse{\i@bgt-#2+1}
				\global\let\n@nodes@bgt\pgfmathresult
				\global\centersquare@complete@bgttrue
			\fi
			\ifoutwardturn@bgt
				\coordinate (\nodelist@bgt[\j@bgt]-inner) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\dimexpr2\inform@radius@bgt+\inform@extendinner@bgt\relax)$);
				\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-inner}
			\else
				\coordinate (\nodelist@bgt[\j@bgt]-outer) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\inform@extendouter@bgt)$);
				\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-outer}
	\fi\fi\fi
}
\def\extend@singleton@bgt#1#2{
	\ifinform@exterior@arc@bgt\else
		\ifcentersquare@complete@bgt\else
			\pgfmathparse{\i@bgt-#2+1}
			\global\let\n@nodes@bgt\pgfmathresult
			\global\centersquare@complete@bgttrue
		\fi
		% save for later
		\let\eventualangle@bgt\nextangle@bgt
		% will need both
		\coordinate (\nodelist@bgt[\j@bgt]-inner) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\dimexpr2\inform@radius@bgt+\inform@extendinner@bgt\relax)$);
		\coordinate (\nodelist@bgt[\j@bgt]-outer) at ($(\nodelist@bgt[\j@bgt]) + (\offsetangle@bgt:\inform@extendouter@bgt)$);
		%
		\ifoutwardturn@bgt
			\nextoutwardturn@bgttrue
			\pgfmathsetmacro{\nextangle@bgt}{\offsetangle@bgt+180}
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-inner}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
			\nextoutwardturn@bgtfalse
			\let\nextangle@bgt\offsetangle@bgt
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
			\outwardturn@bgtfalse
			\let\nextangle@bgt\eventualangle@bgt
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-outer}
		\else
			\nextoutwardturn@bgtfalse
			\pgfmathsetmacro{\nextangle@bgt}{\offsetangle@bgt+180}
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-outer}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
			\let\nextangle@bgt\offsetangle@bgt
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]}
			\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
			\nextoutwardturn@bgttrue
			\let\nextangle@bgt\eventualangle@bgt
			\edef\nextcoord@bgt{\nodelist@bgt[\j@bgt]-inner}
	\fi\fi
}

\def\draw@informset@bgt#1#2{
	% #1: first index
	% #2: last index
	% draw a closed loop
	\pgfmathtruncatemacro{\num@nodes@bgt}{#2-#1+1}
	\let\n@nodes@bgt\num@nodes@bgt
	\ifnum#1=#2\relax
		% reset informwidth to width of label
		\ifbelief@identicalwidth@bgt\else
			\expandafter\inform@width@bgt\csname\nodelist@bgt[#1]-labelwidth\endcsname
		\fi
		% draw loop
		\addto@informset@bgt{($(\nodelist@bgt[#1]) + (90:\inform@radius@bgt)$) arc(90:270:\inform@radius@bgt) -- ++(\inform@width@bgt, 0) arc (-90:90:\inform@radius@bgt) -- cycle}
		\finalize@informset@bgt
		\inform@placelabel@bgt{\nodelist@bgt[#1]}{\nodelist@bgt[#1]}{\nodelist@bgt[#1]}{\nodelist@bgt[#1]}{\inform@labeltext@bgt}{\overlay@bgt}{\inform@label@overlay@bgt}
	\else
		% Support for game trees
		\ifinform@dashed@bgt
			% dummy coords
			\itemtomacro\nodelist@bgt[#1]\center@coord@bgt
			\itemtomacro\nodelist@bgt[#1]\square@coord@bgt
			\ifdim \inform@curved@bgt pt>0pt
				% draw information set
				\expandafter\draw\overlay@bgt[line width=\inform@linewidth@bgt, dashed] (\nodelist@bgt[#1]) to[bend right=\inform@curved@bgt] (\nodelist@bgt[#2]);
			\else
				\addto@informset@bgt{(\nodelist@bgt[1])}
				\foreach \i@bgt in {1, ..., \nodelist@bgtlen} {
					\addto@informset@bgt{-- (\nodelist@bgt[\i@bgt])}
				}
				\def\temp{\expandafter\draw\overlay@bgt[line width=\inform@linewidth@bgt, dashed]}
				\expandafter\temp\inform@draw@instruction@bgt;
				\gdef\inform@draw@instruction@bgt{}
			\fi
		\else
			% Within belief spaces
			\pgfmathtruncatemacro{\j@bgt}{#1+1}
			\initialize@informset@bgt{\nodelist@bgt[#2]}{\nodelist@bgt[#1]}{\nodelist@bgt[\j@bgt]}
			\initialize@centersquare@bgt
			% Draw information set
			\foreach \i@bgt in {#1, ..., #2}{
				\centersquare@bgt{\i@bgt}
				\pgfmathtruncatemacro{\j@bgt}{mod(\i@bgt-#1+1, \num@nodes@bgt)+#1}
				\pgfmathtruncatemacro{\k@bgt}{mod(\i@bgt-#1+2, \num@nodes@bgt)+#1}
				\determine@outwardturns@bgt{\nodelist@bgt[\i@bgt]}{\nodelist@bgt[\j@bgt]}{\nodelist@bgt[\k@bgt]}
				\next@extended@bgtfalse
				\check@extended@bgt{\j@bgt}
				\ifextended@bgt
					\next@extended@bgttrue
				\fi
				\check@extended@bgt{\i@bgt}
				\ifnext@extended@bgt
					\ifextended@bgt
						\extend@singleton@bgt{\i@bgt}{#1}
					\else
						\extend@outwards@bgt{\j@bgt}{#1}
					\fi
				\else
					\ifextended@bgt
						\extend@outwards@bgt{\i@bgt}{#1}
				\fi\fi
				\ifstreq@bgt{\seplist@bgt[\i@bgt]}{..}{\inform@open@bgttrue}{\ifstreq@bgt{\seplist@bgt[\i@bgt]}{-.}{\trailout@bgttrue}{\ifstreq@bgt{\seplist@bgt[\i@bgt]}{.-}{\trailin@bgttrue}{}}}
				\drawsegment@bgt{\thiscoord@bgt}{\nextcoord@bgt}
				% debug
				\ifinform@debug@bgt%
					\ifbelief@state@bgt\else % if state isn't drawn
						\expandafter\draw\overlay@bgt[debug@bgt] (\nodelist@bgt[\i@bgt]) circle (\state@radius@bgt);
					\fi
					\expandafter\draw\overlay@bgt[debug@bgt] (\nodelist@bgt[\i@bgt]) circle (\inform@radius@bgt);
					\expandafter\draw\overlay@bgt[debug@bgt] ($(\nodelist@bgt[\i@bgt]) + (\inform@width@bgt, 0)$) circle (\state@radius@bgt);
					\expandafter\draw\overlay@bgt[debug@bgt] ($(\nodelist@bgt[\i@bgt]) + (\inform@width@bgt, 0)$) circle (\inform@radius@bgt);
				\fi%
			}
			\finalize@informset@bgt
			\finalize@centersquare@bgt
		\fi
		% place label
		\edef\place@islabel@bgt{\noexpand\inform@placelabel@bgt{\nodelist@bgt[#1]}{\nodelist@bgt[#2]}{\center@coord@bgt}{\square@coord@bgt}{\inform@labeltext@bgt}{\overlay@bgt}{\inform@label@overlay@bgt}}
		\place@islabel@bgt
  	\fi
}
\def\draw@arc@bgt#1#2{
	% arc radius
	\tikz@scan@one@point\pgfutil@firstofone($(#2)-(#1)$)\relax
	\pgfmathparse{100*sqrt((\the\pgf@x/100)^2 + (\the\pgf@y/100)^2)}
	\pgfmathsetmacro{\arcradius@bgt}{\pgfmathresult/2/cos(90-\inform@arc@bgt)}
	% arc angles
	\pgfextractangle{\tempangle@bgt}{#1}{#2}%
	\pgfmathsetmacro{\anglediff@bgt}{Mod(\offsetangle@bgt-\tempangle@bgt, 360)}
	\ifdim\anglediff@bgt pt<180pt
		\pgfmathsetmacro{\fromangle@bgt}{\offsetangle@bgt+\inform@arc@bgt}
		\pgfmathsetmacro{\toangle@bgt}{\offsetangle@bgt-\inform@arc@bgt}
	\else
		\pgfmathsetmacro{\fromangle@bgt}{\offsetangle@bgt-\inform@arc@bgt}
		\pgfmathsetmacro{\toangle@bgt}{\offsetangle@bgt+\inform@arc@bgt}
	\fi
	% horizontal offset due to information set width
	\pgfmathsetmacro{\offsetangle@bgt}{Mod(\offsetangle@bgt, 360)}
	\ifdim\offsetangle@bgt pt=90 pt
		\edef\hoffset@bgt{ + (\expandafter\the\dimexpr0.5\inform@width@bgt\relax, 0)}
	\else
		\ifdim\offsetangle@bgt pt<90 pt
			\edef\hoffset@bgt{ + (\the\inform@width@bgt, 0)}
		\else
			\ifdim\offsetangle@bgt pt=270 pt
				\edef\hoffset@bgt{ + (\expandafter\the\dimexpr0.5\inform@width@bgt\relax, 0)}
			\else
				\ifdim\offsetangle@bgt pt>270 pt
					\edef\hoffset@bgt{ + (\the\inform@width@bgt, 0)}
				\else
					\def\hoffset@bgt{}
	\fi\fi\fi\fi
	% draw the arc
	\edef\temp@bgt{\noexpand\draw\overlay@bgt[line width=\the\inform@linewidth@bgt, \activecolor@bgt] ($(#1)\hoffset@bgt + (\offsetangle@bgt:\the\inform@radius@bgt)$) arc(\fromangle@bgt:\toangle@bgt:\arcradius@bgt pt);}
	\temp@bgt
}

\def\informset@opt#1;{
	\label@dirprovided@bgtfalse%
	\ifwithin@beliefspace@bgt
		\expandafter\informsetoptions@bgt\expandafter{\option@bgt}
	\else
		\let\temp@def\tree@inform@def
		\expandafter\append@key@bgt\expandafter{\expandafter\temp@def\expandafter}\expandafter{\option@bgt}
		\expandafter\informsetoptions@bgt\expandafter{\temp@def}
	\fi
	% read nodes and parse separators
	\parse@infsep@bgt{#1}%
	\iftree@enablestrategies@bgt\ifwithin@beliefspace@bgt\else\combine@coordlist@bgt\fi\fi%
	% read label text
	\setsepchar{)/<||>}
	\readlist*\mandatorylist@bgt{#1}
	\expandafter\ifnum\listlen\mandatorylist@bgt[\mandatorylist@bgtlen]>1
		\edef\inform@label@overlay@bgt{<\mandatorylist@bgt[\mandatorylist@bgtlen, 2]>}
		\itemtomacro\mandatorylist@bgt[\mandatorylist@bgtlen, 3]\inform@labeltext@bgt
		% display label by default if a text is provided	
		\ifstreq@bgt{\inform@label@bgt}{none}{
			\ifnum\nodelist@bgtlen=1
				\def\inform@label@bgt{0}
			\else
				\ifnum\value{infparse@e}>0
					\def\inform@label@bgt{square}
				\else
					\def\inform@label@bgt{center}
			\fi\fi
		}{}
	\else
		\ifwithin@beliefspace@bgt
			\def\inform@labeltext@bgt{}
		\else
			% for game trees, set the standard label to the player label
			\let\inform@labeltext@bgt\activename@bgt
		\fi
		% let it to \labeltext so the active player's name is not overwritten if \labeltext has 0 width
		\itemtomacro\mandatorylist@bgt[\mandatorylist@bgtlen]\labeltext@bgt
		\sbox\z@{\pgfinterruptpicture\labeltext@bgt\endpgfinterruptpicture}%
		\ifdim\wd0>\z@\relax%
			\let\inform@labeltext@bgt\labeltext@bgt
			% display label by default if a text is provided	
			\ifstreq@bgt{\inform@label@bgt}{none}{
				\ifnum\nodelist@bgtlen=1
					\def\inform@label@bgt{0}
				\else
					\ifnum\value{infparse@e}>0
						\def\inform@label@bgt{square}
					\else
						\def\inform@label@bgt{center}
				\fi\fi
			}
	\fi\fi
	% draw information set
	\ifinform@exterior@arc@bgt
		\ifnum\value{infparse@e}>0\relax
			\def\is@begin@bgt{1}
			\foreach \k@bgt in {1, ..., \seplist@bgtlen} {
				\pgfmathtruncatemacro{\l@bgt}{mod(\k@bgt, \seplist@bgtlen)+1}
				\let\j@bgt\is@begin@bgt
				\pgfextractangle{\nextangle@bgt}{\nodelist@bgt[\k@bgt]}{\nodelist@bgt[\l@bgt]}
				\check@extended@bgt{\k@bgt}
				\ifextended@bgt
					\draw@informset@bgt{\is@begin@bgt}{\k@bgt}
					% draw arc
					\draw@arc@bgt{\nodelist@bgt[\k@bgt]}{\nodelist@bgt[\l@bgt]}
					% set up next information set
					\global\let\is@begin@bgt\l@bgt
					\gdef\inform@label@bgt{none}
				\fi
			}
		\else
			\draw@informset@bgt{1}{\nodelist@bgtlen}
		\fi
	\else
		\draw@informset@bgt{1}{\nodelist@bgtlen}
	\fi
}
\addoptions@bgt{informset}
\addoverlay@bgt{informset}
%
\def\event@opt#1;{
	\setcounter{activeplayer@bgt}{0}
	\inform@selectplayer@bgt
%	\def\activecolor@bgt{event}%
%	\def\inform@color@bgt{event}%
	\informset@opt#1;
}
\addoptions@bgt{event}
\addoverlay@bgt{event}
%
%
\def\informlabel@opt#1(#2)#3at#4(#5)#6;{
	% #1: gobbling space
	% #2: direction:label radius
	% #3: gobbling space
	% #4: gobbling space
	% #5: coordinate
	% #6: label text
	% default is max radius
	%
	\ifwithin@beliefspace@bgt
		\def\temp@a{color=xg-fg, base line=false}
		\expandafter\expandafter\expandafter\informsetoptions@bgt\expandafter\expandafter\expandafter{\expandafter\temp@a\expandafter,\option@bgt}
	\else
		\append@bgt\tree@inform@def{color=xg-fg, \option@bgt, label=#2}
	\fi
	\global\inform@labelradius@bgt\inform@maxradius@bgt
	\parse@label@bgt{#2}
	%
	% \@firstofone removes the braces around the actual argument
	\ifinform@misaligned@bgt
		\inform@placelabel@bgt{#5-is}{#5-is}{#5-is}{#5-is}{\@firstofone#6}{\overlay@bgt}{}
	\else
		\inform@placelabel@bgt{#5}{#5}{#5}{#5}{\@firstofone#6}{\overlay@bgt}{}
	\fi
}
\addoptions@bgt{informlabel}
\addoverlay@bgt{informlabel}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		3.1 Strategic-Form Games
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Variables
\newcounter{matrix@count@bgt}
\newlength{\matrix@commadepth@bgt}
\newlength{\matrix@Aheight@bgt}
\newlength{\matrix@voffset@bgt}
\newif\ifmatrix@forcemath@bgt
\matrix@forcemath@bgttrue
\newif\ifmatrix@forcemath@label@bgt
\newif\ifwithin@matrix@bgt
\colorlet{top@color@bgt}{xg-fg}
\colorlet{bottom@color@bgt}{xg-fg}
% immediate switch
\newif\ifmatrix@delayedlabel@bgt
\newif\ifmatrix@immediate@text@bgt
\newif\ifmatrix@immediate@text@def
\matrix@immediate@text@deftrue
%
% Optional arguments
\define@bgts@family{matrix}{
	font, \normalsize;
	label font, \normalsize;
	name, pmt;
	pos, {0,0};
	w, 1.6;
	h, 0.8;
	left align, center
}{
	line width, \edgelinewidth@bgt; % note: setting line width locally won't affect label placement
	strike width, 1.5\edgelinewidth@bgt;
	label sep, 1ex
}{}{%
	immediate, false;
	debug, false;
	br, false
}{
	vertical align, default:baseline:center
}{}{
	\setiftodefault@bgt{matrix@immediate@text}
	\global\matrix@delayedlabel@bgtfalse
}
%
\define@key@thickness@bgts{matrix}
% immediate switch
\define@key{matrix@def}{immediate}[true]{\ifstreq@bgt{#1}{true}{\matrix@immediate@deftrue\matrix@immediate@text@deftrue}{\matrix@immediate@deffalse\ifstreq@bgt{#1}{text}{\matrix@immediate@text@deftrue}{\matrix@immediate@text@deffalse}}}
\define@key{matrix@bgt}{immediate}[true]{\ifstreq@bgt{#1}{true}{\matrix@immediate@bgttrue\matrix@immediate@text@bgttrue}{\matrix@immediate@bgtfalse\ifstreq@bgt{#1}{text}{\matrix@immediate@text@bgttrue}{\matrix@immediate@text@bgtfalse}}}
%
% Externalize
\newif\ifmatrix@externalize@bgt
\def\matrix@external@bgt{}
\define@key{matrix@bgt}{external}{\def\matrix@external@bgt{#1}\matrix@externalize@bgttrue}
%
% Update depths and vertical offset only when changing keys
\define@key{matrix@bgt}{font}{%
	\def\matrix@font@bgt{#1}%
	\def\matrix@labelfont@bgt{#1}%
	\settodepth{\matrix@commadepth@bgt}{#1,}%
	\settoheight{\matrix@Aheight@bgt}{#1 A}%
}
\settodepth{\matrix@commadepth@bgt}{\matrix@font@bgt$,$}
\settoheight{\matrix@Aheight@bgt}{\matrix@font@bgt A}
\setlength{\matrix@voffset@bgt}{\matrix@commadepth@bgt}
%
\define@key{matrix@bgt}{vertical align}{%
	\setswitch@bgt{matrix@verticalalign}{#1}%
	\ifmatrix@verticalalign@center@bgt\setlength{\matrix@voffset@bgt}{0pt}\else\setlength{\matrix@voffset@bgt}{\matrix@commadepth@bgt}\fi%
}
\def\br@overlay@bgt{}
\define@key{matrix@bgt}{br}[true]{\ifstreq@bgt{#1}{true}{\matrix@immediate@text@bgtfalse\matrix@br@bgttrue}{\ifstreq@bgt{#1}{false}{\matrix@br@bgtfalse}{\matrix@immediate@text@bgtfalse\matrix@br@bgttrue\def\br@overlay@bgt{#1}}}}
%
\define@key{matrix@bgt}{force math}[true]{\ifstreq@bgt{#1}{true}{\matrix@forcemath@bgttrue\matrix@forcemath@label@bgttrue}{\ifstreq@bgt{#1}{matrix}{\matrix@forcemath@bgttrue\matrix@forcemath@label@bgtfalse}{\ifstreq@bgt{#1}{label}{\matrix@forcemath@bgtfalse\matrix@forcemath@label@bgttrue}{\matrix@forcemath@bgtfalse\matrix@forcemath@label@bgtfalse}}}}
%
% Always non-sticky
\newif\ifmatrix@reset@bgt
\define@key{matrix@bgt}{reset}[true]{\ifstreq@bgt{#1}{true}{\matrix@reset@bgttrue}{\matrix@reset@bgtfalse}}
%
% Always sticky
\newif\ifmatrix@players@bgt
\define@key{matrix@bgt}{players}[true]{\ifstreq@bgt{#1}{true}{\matrix@players@bgttrue}{\matrix@players@bgtfalse}}
\define@key{matrix@bgt}{player names}{\setplayernames{#1}\matrix@players@bgttrue}
%
% Labels
\define@key{matrix@bgt}{top}{\AtEndEnvNoExpand@bgt{\@toplabel@bgt{}{#1}{}}\matrix@delayedlabel@bgttrue}
\define@key{matrix@bgt}{left}{\AtEndEnvNoExpand@bgt{\@leftlabel@bgt{}{#1}{}}\matrix@delayedlabel@bgttrue}
\define@key{matrix@bgt}{top left}{\AtEndEnvNoExpand@bgt{\@toplabel@bgt{}{#1}{}}\AtEndEnvNoExpand@bgt{\@leftlabel@bgt{}{#1}{}}\matrix@delayedlabel@bgttrue}
\define@key{matrix@bgt}{bottom}{\AtEndEnvNoExpand@bgt{\@bottomlabel@bgt{}{#1}{}}\matrix@delayedlabel@bgttrue}
%
% Highlight best responses
\def\br@bgt#1{\expandafter\alt\overlay@bgt{\underline{#1}}{#1}}
\addoverlay@bgt{br}
%
% Executed before every tikzpicture
\def\matrixreset{%
	\global\setcounter{matrix@count@bgt}{0}%
}
% Define the matrixgame environment
\def\matrixgame@bgtbegin#1{%
	\within@matrix@bgttrue%
	\ResetStorage@bgt%
	\matrixsetoptions{#1}%
}
\def\matrixgame@bgtdelay{
	\ifmatrix@immediate@text@bgt\else
		\ifnum\value{matrix@count@bgt}>0
			\display@matrices@bgt
		\fi
		\EnvStored@bgt
		\LateEnvStored@bgt
		\ifpayoff@drawn@bgt\draw@payoffs@bgt\fi
	\fi
	% has to be after EnvStored so it is placed after labels
	\ifmatrix@players@bgt
		\addplayers
	\fi
}
\def\matrixgame@bgtend{%
%	\setcounter{activeplayer@bgt}{0}%
	\within@matrix@bgtfalse%
	\ignorespacesafterend
}
%
\ifexternal@bgt
	% don't want to load the environ package if it is not needed
	\NewEnviron{matrixgame}[1][]{%
		\matrixgame@bgtbegin{#1}%
		\ifmatrix@externalize@bgt%
			\expandafter\externalize\expandafter{\matrix@external@bgt}%
		\fi%
		\begin{tikzpicture}
		\BODY
		\matrixgame@bgtdelay
		\end{tikzpicture}%
	}{\matrixgame@bgtend}
\else
	\newenvironment{matrixgame}[1][]{%
		\matrixgame@bgtbegin{#1}%
		\begin{tikzpicture}
	}{
		\matrixgame@bgtdelay
		\end{tikzpicture}%
		\matrixgame@bgtend
	}
\fi
%
\def\payoffmatrix@opt#1{
	\begingroup
	% process options
	\expandafter\matrixsetoptions\expandafter{\option@bgt}%
	\ifmatrix@reset@bgt
		\matrixreset
	\fi
	\global\matrix@reset@bgtfalse
	% step matrix counter and abbreviate for ease of use
	\global\stepcounter{matrix@count@bgt}
    \pgfmathtruncatemacro{\c@bgt}{\value{matrix@count@bgt}}
    % make overlay specification available for label and addplayers
    \expandafter\global\expandafter\let\csname\matrix@name@bgt @\romannumeral\c@bgt @overlay@bgt\endcsname\overlay@bgt
	% read matrix and store globally for access in \drawpayoffs
	\setsepchar{\\/&/,}%
	\expandafter\greadlist\expandafter*\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname{#1}%
	% extract information on nmber of players and strategies
	\xdef\nrows@bgt{\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgtlen\endcsname}%
	\xdef\ncols@bgt{\expandafter\listlen\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[1]}%
	\xdef\nplayers@bgt{\expandafter\listlen\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[1,1]}%
	\expandafter\global\expandafter\let\csname nrows@\romannumeral\c@bgt @bgt\endcsname\nrows@bgt
	\expandafter\global\expandafter\let\csname ncols@\romannumeral\c@bgt @bgt\endcsname\ncols@bgt
	\expandafter\global\expandafter\let\csname nplayers@\romannumeral\c@bgt @bgt\endcsname\nplayers@bgt
    % process width and height
    \setsepchar{,}
    \readlist*\matrix@temp@w@bgt{\matrix@w@bgt}
    \readlist*\matrix@temp@h@bgt{\matrix@h@bgt}
    % calculate cumulative and total heights of cells (not location of labels)
    \edef\matrix@hcum@bgt{\matrix@temp@h@bgt[1]}
    \let\matrix@total@h@bgt\matrix@hcum@bgt
    \ifnum\nrows@bgt>1
	    \foreach \i@bgt in {2, ..., \nrows@bgt} {
	    	\pgfmathtruncatemacro{\j@bgt}{mod(\i@bgt-1, \matrix@temp@h@bgtlen)+1}
	    	\pgfmathparse{\matrix@total@h@bgt+\matrix@temp@h@bgt[\j@bgt]}
	    	\global\let\matrix@total@h@bgt\pgfmathresult
	    	\xdef\matrix@hcum@bgt{\matrix@hcum@bgt, \matrix@total@h@bgt}
	    }
	\fi
    % calculate cumulative and total widths of cells (not location of labels)
    \edef\matrix@wcum@bgt{\matrix@temp@w@bgt[1]}
    \let\matrix@total@w@bgt\matrix@wcum@bgt
    \ifnum\ncols@bgt>1
	    \foreach \i@bgt in {2, ..., \ncols@bgt} {
	    	\pgfmathtruncatemacro{\j@bgt}{mod(\i@bgt-1, \matrix@temp@w@bgtlen)+1}
	    	\pgfmathparse{\matrix@total@w@bgt+\matrix@temp@w@bgt[\j@bgt]}
	    	\global\let\matrix@total@w@bgt\pgfmathresult
	    	\xdef\matrix@wcum@bgt{\matrix@wcum@bgt, \matrix@total@w@bgt}
 		}
 	\fi
    % store globally for labels and strikes
 	\expandafter\greadlist\expandafter*\csname pmtw\romannumeral\c@bgt\expandafter\endcsname\expandafter{\matrix@wcum@bgt}
 	\expandafter\greadlist\expandafter*\csname pmth\romannumeral\c@bgt\expandafter\endcsname\expandafter{\matrix@hcum@bgt}
    \expandafter\global\expandafter\let\csname pmtotw\romannumeral\c@bgt\endcsname\matrix@total@w@bgt
    \expandafter\global\expandafter\let\csname pmtoth\romannumeral\c@bgt\endcsname\matrix@total@h@bgt
    % define top-left coordinates as reference point
    \coordinate (pmt\c@bgt-tl) at ($(\matrix@pos@bgt) + 0.5*(-\matrix@total@w@bgt, \matrix@total@h@bgt)$);
	% draw grid
    \expandafter\draw\overlay@bgt[line width=\matrix@linewidth@bgt] (pmt\c@bgt-tl) rectangle ++(\matrix@total@w@bgt, -\matrix@total@h@bgt);
    \ifnum\nrows@bgt>1
		\foreach \i@bgt in {1, ..., \numexpr\nrows@bgt-1\relax} {
			\expandafter\draw\overlay@bgt[line width=\matrix@linewidth@bgt] ($(pmt\c@bgt-tl) + (0, -\csname pmth\romannumeral\c@bgt\endcsname[\i@bgt])$) -- ++(\matrix@total@w@bgt, 0);
		}
	\fi
	\ifnum\ncols@bgt>1
		\foreach \j@bgt in {1, ..., \numexpr\ncols@bgt-1\relax} {
			\expandafter\draw\overlay@bgt[line width=\matrix@linewidth@bgt] ($(pmt\c@bgt-tl) + (\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt], 0)$) -- ++(0, -\matrix@total@h@bgt);
		}
	\fi
	\ifmatrix@br@bgt
		% determine best responses for player 1
		\foreach \j@bgt in {1, ..., \ncols@bgt} {%
			\expandafter\gdef\csname max@col\romannumeral\c@bgt @\romannumeral\j@bgt @bgt\endcsname{-16000}
			\foreach \i@bgt in {1, ..., \nrows@bgt} {%
				\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[\i@bgt,\j@bgt,1]\x@bgt
				\expandafter\ifdim\csname max@col\romannumeral\c@bgt @\romannumeral\j@bgt @bgt\endcsname pt<\x@bgt pt
					\expandafter\global\expandafter\let\csname max@col\romannumeral\c@bgt @\romannumeral\j@bgt @bgt\endcsname\x@bgt
				\fi
		}}
		% determine best responses for player 2
		\foreach \i@bgt in {1, ..., \nrows@bgt} {%
			\expandafter\gdef\csname max@row\romannumeral\c@bgt @\romannumeral\i@bgt @bgt\endcsname{-16000}
			\foreach \j@bgt in {1, ..., \ncols@bgt} {%
				\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[\i@bgt,\j@bgt,2]\y@bgt
				\expandafter\ifdim\csname max@row\romannumeral\c@bgt @\romannumeral\i@bgt @bgt\endcsname pt<\y@bgt pt
					\expandafter\global\expandafter\let\csname max@row\romannumeral\c@bgt @\romannumeral\i@bgt @bgt\endcsname\y@bgt
				\fi
		}}
	\fi
	% Store overlay
	\expandafter\global\expandafter\let\csname overlay@\romannumeral\c@bgt @bgt\endcsname\overlay@bgt
	% Draw matrix if needed
	\ifwithin@matrix@bgt
		\ifmatrix@immediate@text@bgt
			\expandafter\display@matrix@bgt\expandafter{\c@bgt}
		\fi
	\else
		\expandafter\display@matrix@bgt\expandafter{\c@bgt}
	\fi
	% Default colors for labels
	\ifmatrix@debug@bgt
		\expandafter\draw\overlay@bgt[debug@bgt] ($(pmt\c@bgt-tl) + (\matrix@total@w@bgt, 0) + (0.5\matrix@linewidth@bgt, \matrix@labelsep@bgt + 0.5\matrix@linewidth@bgt)$) -- ++($(-\matrix@total@w@bgt, 0) - (\matrix@labelsep@bgt + \matrix@linewidth@bgt, 0)$) -- ++($(0, -\matrix@total@h@bgt) - (0, 2\matrix@labelsep@bgt + \matrix@linewidth@bgt)$) -- ++($(\matrix@total@w@bgt, 0) + (\matrix@linewidth@bgt + \matrix@labelsep@bgt, 0)$);
	\fi
	\ifmatrix@sticky@bgt
		\endgroup
		\expandafter\matrixsetoptions\expandafter{\option@bgt}%
	\else
		% name should be given as an environment option. 
		% if it isn't, however, we must make sure it is visible to \toplabel, \leftlabel
		\global\let\temp\matrix@name@bgt
		\endgroup
		\let\matrix@name@bgt\temp
	\fi
}
\addoptions@bgt{payoffmatrix}
\addoverlay@bgt{payoffmatrix}
%
\def\display@matrix@bgt#1{
	% option br allowed only for fewer than three players
	\ifmatrix@br@bgt\expandafter\ifnum\csname nplayers@\romannumeral#1@bgt\endcsname>3
		\PackageWarning{xgames}{Option br is supported only for at most three players}{}
		\aftergroup\matrix@br@bgtfalse
	\fi\fi
    % get scale for depth and label placement
    \getscale@bgt%
    \pgfmathsetmacro{\invy@bgt}{1/\yscale@bgt}
	% "single-player" matrices won't have the commadepth
    \expandafter\ifnum\csname nplayers@\romannumeral#1@bgt\endcsname=1%
    	\setlength{\matrix@voffset@bgt}{0pt}%
    \fi%
    % to make the code more readable
    \expandafter\let\expandafter\overlay@bgt\csname overlay@\romannumeral#1@bgt\endcsname
	\ifmatrix@br@bgt
		% for option br, only constants are allowed. in particular, there are no special characters. Since underline is less deep than a comma, matrix@verticalalign@baseline@bgt doesn't matter
		\foreach \i@bgt in {1, ..., \csname nrows@\romannumeral#1@bgt\endcsname} {
			% compute y-coordinate
			\expandafter\itemtomacro\csname pmth\romannumeral\c@bgt\endcsname[\i@bgt]\temp@h@bgt
			\ifnum\i@bgt>1
				\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral\c@bgt\endcsname[\i@bgt-1]}
			\fi
			\expandafter\ifnum\csname nplayers@\romannumeral#1@bgt\endcsname=3
				\foreach \j@bgt in {1, ..., \csname ncols@\romannumeral#1@bgt\endcsname} {
					% load values
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,1]\x@bgt
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,2]\y@bgt
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,3]\z@bgt
					% add underline if maximum
					\expandafter\ifdim\csname max@col\romannumeral#1@\romannumeral\j@bgt @bgt\endcsname pt=\x@bgt pt
						\edef\x@bgt{\noexpand\br\br@overlay@bgt{\x@bgt}}
					\fi
					\expandafter\ifdim\csname max@row\romannumeral#1@\romannumeral\i@bgt @bgt\endcsname pt=\y@bgt pt
						\edef\y@bgt{\noexpand\br\br@overlay@bgt{\y@bgt}}
					\fi
					\expandafter\ifdim\csname max@row\romannumeral\i@bgt @col\romannumeral\j@bgt @bgt\endcsname pt=\z@bgt pt
						\edef\z@bgt{\noexpand\br\br@overlay@bgt{\z@bgt}}
					\fi
					% compute x-coordinate
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt]\temp@w@bgt
					\ifnum\j@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt-1]}
					\fi
					% output
					\ifmatrix@forcemath@bgt
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {$\apm{\x@bgt, \y@bgt, \z@bgt}$};
					\else
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {\apm{\x@bgt, \y@bgt, \z@bgt}};
					\fi
				}
			\else\expandafter\ifnum\csname nplayers@\romannumeral#1@bgt\endcsname=2
				\foreach \j@bgt in {1, ..., \csname ncols@\romannumeral#1@bgt\endcsname} {
					% load values
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,1]\x@bgt
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,2]\y@bgt
					% add underline if maximum
					\expandafter\ifdim\csname max@col\romannumeral#1@\romannumeral\j@bgt @bgt\endcsname pt=\x@bgt pt
						\edef\x@bgt{\noexpand\br\br@overlay@bgt{\x@bgt}}
					\fi
					\expandafter\ifdim\csname max@row\romannumeral#1@\romannumeral\i@bgt @bgt\endcsname pt=\y@bgt pt
						\edef\y@bgt{\noexpand\br\br@overlay@bgt{\y@bgt}}
					\fi
					% compute x-coordinate
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt]\temp@w@bgt
					\ifnum\j@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt-1]}
					\fi
					% output
					\ifmatrix@forcemath@bgt
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {$\apm{\x@bgt, \y@bgt}$};
					\else
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {\apm{\x@bgt, \y@bgt}};
					\fi
				}
			\else
				\foreach \j@bgt in {1, ..., \csname ncols@\romannumeral#1@bgt\endcsname} {
					% load values
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral#1@bgt\endcsname[\i@bgt,\j@bgt,1]\x@bgt
					% add underline if maximum
					\expandafter\ifdim\csname max@col\romannumeral#1@\romannumeral\j@bgt @bgt\endcsname pt=\x@bgt pt
						\edef\x@bgt{\noexpand\br\br@overlay@bgt{\x@bgt}}
					\fi
					% compute x-coordinate
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt]\temp@w@bgt
					\ifnum\j@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt-1]}
					\fi
					% output
					\ifmatrix@forcemath@bgt
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {$\apm{\x@bgt}$};
					\else
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {\apm{\x@bgt}};
					\fi
				}
			\fi\fi
		}
	\else
		\ifmatrix@verticalalign@baseline@bgt
			\foreach \i@bgt in {1, ..., \csname nrows@\romannumeral#1@bgt\endcsname} {
				% compute y-coordinate
				\expandafter\itemtomacro\csname pmth\romannumeral\c@bgt\endcsname[\i@bgt]\temp@h@bgt
				\ifnum\i@bgt>1
					\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral\c@bgt\endcsname[\i@bgt-1]}
				\fi
				\foreach \j@bgt in {1, ..., \csname ncols@\romannumeral#1@bgt\endcsname} {%
					% measure depth
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[\i@bgt,\j@bgt]\payoff@bgt
					\ifmatrix@forcemath@bgt
						\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@font@bgt$\payoff@bgt$}\endpgfinterruptpicture}
					\else
						\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@font@bgt\payoff@bgt}\endpgfinterruptpicture}
					\fi
					% compute x-coordinate
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt]\temp@w@bgt
					\ifnum\j@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt-1]}
					\fi
					% outpu
					\ifmatrix@forcemath@bgt
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \labeldepth@bgt)$) {$\apm{\payoff@bgt}$};
					\else
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \labeldepth@bgt)$) {\apm{\payoff@bgt}};
					\fi
			}}
		\else
			\foreach \i@bgt in {1, ..., \csname nrows@\romannumeral#1@bgt\endcsname} {
				% compute y-coordinate
				\expandafter\itemtomacro\csname pmth\romannumeral\c@bgt\endcsname[\i@bgt]\temp@h@bgt
				\ifnum\i@bgt>1
					\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral\c@bgt\endcsname[\i@bgt-1]}
				\fi
				\foreach \j@bgt in {1, ..., \csname ncols@\romannumeral#1@bgt\endcsname} {%
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[\i@bgt,\j@bgt]\payoff@bgt
					% compute x-coordinate
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt]\temp@w@bgt
					\ifnum\j@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\j@bgt-1]}
					\fi
					% output
					\ifmatrix@forcemath@bgt
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {$\apm{\payoff@bgt}$};
					\else
						\expandafter\node\overlay@bgt[font=\matrix@font@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) + 0.5*(\temp@w@bgt, 0) - 0.5*\invy@bgt*(0, \matrix@voffset@bgt)$) {\apm{\payoff@bgt}};
					\fi
				}
			}
		\fi
	\fi
}
%
\def\display@matrices@bgt{
	% check inputs
	\ifwithin@matrix@bgt\ifnum\value{matrix@count@bgt}>1
		\foreach \c@bgt in {2, ..., \value{matrix@count@bgt}} {
			\expandafter\ifnum\csname nplayers@\romannumeral\c@bgt @bgt\expandafter\endcsname\expandafter=\csname nplayers@\romannumeral\numexpr\c@bgt-1\relax @bgt\endcsname\else
				\PackageWarning{xgames}{Matrices in the same environment should contain the same number of players. Unexpected behavior may occur}{}
			\fi
			\expandafter\ifnum\csname nrows@\romannumeral\c@bgt @bgt\expandafter\endcsname\expandafter=\csname nrows@\romannumeral\numexpr\c@bgt-1\relax @bgt\endcsname\else
				\PackageWarning{xgames}{Matrices in the same environment should contain the same number of rows. Unexpected behavior may occur}{}
			\fi
			\expandafter\ifnum\csname ncols@\romannumeral\c@bgt @bgt\expandafter\endcsname\expandafter=\csname ncols@\romannumeral\numexpr\c@bgt-1\relax @bgt\endcsname\else
				\PackageWarning{xgames}{Matrices in the same environment should contain the same number of columns. Unexpected behavior may occur}{}
			\fi
		}
	\fi\fi
	% determine best responses for player 3 if necessary
	\ifmatrix@br@bgt\ifnum\nplayers@i@bgt=3
		\foreach \i@bgt in {1, ..., \nrows@i@bgt} {%
			\foreach \j@bgt in {1, ..., \ncols@i@bgt} {%
				\expandafter\gdef\csname max@row\romannumeral\i@bgt @col\romannumeral\j@bgt @bgt\endcsname{-16000}
				\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
					\expandafter\itemtomacro\csname\matrix@name@bgt @payoff@\romannumeral\c@bgt @bgt\endcsname[\i@bgt,\j@bgt,3]\z@bgt	
					\expandafter\ifdim\csname max@row\romannumeral\i@bgt @col\romannumeral\j@bgt @bgt\endcsname pt<\z@bgt pt
						\expandafter\global\expandafter\let\csname max@row\romannumeral\i@bgt @col\romannumeral\j@bgt @bgt\endcsname\z@bgt
					\fi
		}}}
	\fi\fi
	% output
	\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
		\expandafter\display@matrix@bgt\expandafter{\c@bgt}
	}
}
%
\def\mat@visible@bgt#1{#1}
\def\recall@overlay@bgt#1{\expandafter\ifstreq@bgt\expandafter{\csname\matrix@name@bgt @\romannumeral#1@overlay@bgt\endcsname}{}{\def\mat@visible@bgt##1{##1}}{\edef\mat@visible@bgt{\noexpand\visible\csname\matrix@name@bgt @\romannumeral#1@overlay@bgt\endcsname}}}
%
\newif\ifleft@baseline@bgt
\newlength{\left@maxwidth@bgt}
\newlength{\left@hoffset@bgt}
\define@key{left@bgt}{color}{\colorlet{left@color@bgt}{#1}}
\define@key{left@bgt}{align}{\def\matrix@leftalign@bgt{#1}}
\define@key{left@bgt}{base line}[true]{\ifstreq@bgt{#1}{true}{\left@baseline@bgttrue}{\left@baseline@bgtfalse}}
\def\@leftlabel@bgt#1#2#3{
	% #1: color
	% #2: label
	% #3: overlay
	\ifcontrast@bgt\colorlet{left@color@bgt}{xg-fg}\else\colorlet{left@color@bgt}{player1}\fi
	\ifmatrix@verticalalign@baseline@bgt\left@baseline@bgttrue\else\left@baseline@bgtfalse\fi
	\setkeys{left@bgt}{#1}
	% store globally for \drawpayoffs
	\setsepchar{,}%
	\expandafter\greadlist\expandafter*\csname\matrix@name@bgt @playeri@bgt\endcsname{#2}%
	\ifnum\csname\matrix@name@bgt @playeri@bgtlen\endcsname>\pmthilen
		\PackageError{xgames}{The argument of leftlabel exceeds the number of rows}{}
	\else
		\ifnum\csname\matrix@name@bgt @playeri@bgtlen\endcsname<\pmthilen
			\PackageWarning{xgames}{The argument of leftlabel is shorter than the number of rows}{}
		\fi
	    % get scale for depth and label placement
		\getscale@bgt%
		% Measure maximum label width
		\setlength{\left@maxwidth@bgt}{0pt}
		\ifmatrix@forcemath@label@bgt
			\expandafter\foreachitem\expandafter\i@bgt\expandafter\in\csname\matrix@name@bgt @playeri@bgt\endcsname {
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\ensuremath{\i@bgt}}\endpgfinterruptpicture}
				\ifdim\labelwidth@bgt>\left@maxwidth@bgt
					\global\left@maxwidth@bgt\labelwidth@bgt
				\fi
			}
		\else
			\expandafter\foreachitem\expandafter\i@bgt\expandafter\in\csname\matrix@name@bgt @playeri@bgt\endcsname {
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\i@bgt}\endpgfinterruptpicture}
				\ifdim\labelwidth@bgt>\left@maxwidth@bgt
					\global\left@maxwidth@bgt\labelwidth@bgt
				\fi
			}
		\fi
		% place labels
		\foreach \i@bgt in {1, ..., \csname\matrix@name@bgt @playeri@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname\matrix@name@bgt @playeri@bgt\endcsname[\i@bgt]\cell@bgt
			% force math option
			\ifmatrix@forcemath@label@bgt
				\def\temp@bgt{\ensuremath{\cell@bgt}}
			\else
				\def\temp@bgt{\cell@bgt}
			\fi
			% measure height if debug option is given
			\ifmatrix@debug@bgt
				\settoheight{\labelheight@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
			\fi
			% measure depth is base line option is given
			\ifleft@baseline@bgt
				\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
			\else
				\labeldepth@bgt0pt
			\fi
			% horizontal alignment within box
			\ifstreq@bgt{\matrix@leftalign@bgt}{center}{
				\left@hoffset@bgt0.5\left@maxwidth@bgt
			}{
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
				\ifstreq@bgt{\matrix@leftalign@bgt}{right}{\left@hoffset@bgt0.5\labelwidth@bgt}{\left@hoffset@bgt\dimexpr\left@maxwidth@bgt-0.5\labelwidth@bgt\relax}
			}
			% place label
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				% Determine y-coordinate
				\expandafter\itemtomacro\csname pmth\romannumeral\c@bgt\endcsname[\i@bgt]\temp@h@bgt
				\ifnum\i@bgt>1
					\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral\c@bgt\endcsname[\i@bgt-1]}
				\fi
				% output
				\mat@visible@bgt{\node#3[font=\matrix@labelfont@bgt, left@color@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) - \invx@bgt*(\matrix@labelsep@bgt + 0.5\matrix@linewidth@bgt + \left@hoffset@bgt, 0) - \invy@bgt*(0, 0.5\labeldepth@bgt)$) {\temp@bgt};}
				\ifmatrix@debug@bgt
					\mat@visible@bgt{\draw#3[debug@bgt] ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) - \invx@bgt*(\matrix@labelsep@bgt + \left@maxwidth@bgt + 0.5\matrix@linewidth@bgt, 0) - \invy@bgt*(0, 0.5\labelheight@bgt)$) rectangle ++(\left@maxwidth@bgt, \labelheight@bgt);}
				\fi
		}}
	\fi
}
\newcommand{\leftlabel@bgt}[2][]{
	\ifwithin@matrix@bgt
		\ifmatrix@immediate@text@bgt
			\def\temp{\@leftlabel@bgt{#1}{#2}}
			\expandafter\temp\expandafter{\overlay@bgt}
		\else
			\AtEndEnvNoExpand@bgt{\@leftlabel@bgt{#1}{#2}}
			\AtEndEnv@bgt{{\overlay@bgt}}
		\fi
	\else
		\def\temp{\@leftlabel@bgt{#1}{#2}}
		\expandafter\temp\expandafter{\overlay@bgt}
	\fi
}
\addoverlay@bgt{leftlabel}
%
\newif\iftop@baseline@bgt
\define@key{top@bgt}{color}{\colorlet{top@color@bgt}{#1}}
\define@key{top@bgt}{base line}[true]{\ifstreq@bgt{#1}{true}{\top@baseline@bgttrue}{\top@baseline@bgtfalse}}
\def\@toplabel@bgt#1#2#3{
	% #1: options
	% #2: label
	% #3: overlay
	% default options
	\ifnum\nplayers@i@bgt=1
		\colorlet{top@color@bgt}{xg-fg}
	\else
		\colorlet{top@color@bgt}{player2}
	\fi
	\ifcontrast@bgt\colorlet{top@color@bgt}{xg-fg}\fi
	\ifmatrix@verticalalign@baseline@bgt\top@baseline@bgttrue\else\top@baseline@bgtfalse\fi
	\setkeys{top@bgt}{#1}
	% store globally for \drawpayoffs
	\setsepchar{,}%
	\expandafter\greadlist\expandafter*\csname\matrix@name@bgt @playerii@bgt\endcsname{#2}%
	\ifnum\csname\matrix@name@bgt @playerii@bgtlen\endcsname>\pmtwilen
		\PackageError{xgames}{The argument of toplabel exceeds the number of columns}{}
	\else
		\ifnum\csname\matrix@name@bgt @playerii@bgtlen\endcsname<\pmtwilen
			\PackageWarning{xgames}{The argument of toplabel is shorter than the number of columns}{}
		\fi
	
    % get scale for depth and label placement
    \getscale@bgt%
	% place labels
	\iftop@baseline@bgt
		\foreach \i@bgt in {1, ..., \csname\matrix@name@bgt @playerii@bgtlen\endcsname} {%
			\expandafter\itemtomacro\csname\matrix@name@bgt @playerii@bgt\endcsname[\i@bgt]\cell@bgt
			% force math option
			\ifmatrix@forcemath@label@bgt
				\def\temp@bgt{\ensuremath{\cell@bgt}}
			\else
				\def\temp@bgt{\cell@bgt}
			\fi
			% measure label
			\settoheight{\labelheight@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
			\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
			\ifmatrix@debug@bgt
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
			\fi
			% place label
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt]\temp@w@bgt
				\ifnum\i@bgt>1
					\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt-1]}
				\fi
				\mat@visible@bgt{\node#3[font=\matrix@labelfont@bgt, top@color@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\labelheight@bgt - 0.5\labeldepth@bgt + 0.5\matrix@linewidth@bgt)$) {\temp@bgt};}
				\ifmatrix@debug@bgt
					\mat@visible@bgt{\draw#3[debug@bgt] ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) - 0.5*\invx@bgt*(\labelwidth@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\matrix@linewidth@bgt)$) rectangle ++(\invx@bgt\labelwidth@bgt, \invy@bgt\labelheight@bgt);}
				\fi
		}}
	\else
		\ifmatrix@debug@bgt
			\foreach \i@bgt in {1, ..., \csname\matrix@name@bgt @playerii@bgtlen\endcsname} {%
				\expandafter\itemtomacro\csname\matrix@name@bgt @playerii@bgt\endcsname[\i@bgt]\cell@bgt
				% force math option
				\ifmatrix@forcemath@label@bgt
					\def\temp@bgt{\ensuremath{\cell@bgt}}
				\else
					\def\temp@bgt{\cell@bgt}
				\fi
				\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@labelfont@bgt\temp@bgt}\endpgfinterruptpicture}
				% place label
				\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
					\recall@overlay@bgt{\c@bgt}
					\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt]\temp@w@bgt
					\ifnum\i@bgt>1
						\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt-1]}
					\fi
					\mat@visible@bgt{\node#3[font=\matrix@labelfont@bgt, top@color@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\matrix@Aheight@bgt + 0.5\matrix@linewidth@bgt)$) {\temp@bgt};}
					\mat@visible@bgt{\draw#3[debug@bgt] ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) - 0.5*\invx@bgt*(\labelwidth@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\matrix@linewidth@bgt)$) rectangle ++(\invx@bgt\labelwidth@bgt, \invy@bgt\matrix@Aheight@bgt);}
			}}
		\else
			\foreach \i@bgt in {1, ..., \csname\matrix@name@bgt @playerii@bgtlen\endcsname} {%
				\expandafter\itemtomacro\csname\matrix@name@bgt @playerii@bgt\endcsname[\i@bgt]\cell@bgt
				% place label
				\ifmatrix@forcemath@label@bgt
					\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
						\recall@overlay@bgt{\c@bgt}
						\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt]\temp@w@bgt
						\ifnum\i@bgt>1
							\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt-1]}
						\fi
						\mat@visible@bgt{\node#3[font=\matrix@labelfont@bgt, top@color@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\matrix@Aheight@bgt + 0.5\matrix@linewidth@bgt)$) {\ensuremath{\cell@bgt}};}
					}
				\else
					\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
						\recall@overlay@bgt{\c@bgt}
						\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt]\temp@w@bgt
						\ifnum\i@bgt>1
							\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[\i@bgt-1]}
						\fi
						\mat@visible@bgt{\node#3[font=\matrix@labelfont@bgt, top@color@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) + \invy@bgt*(0, \matrix@labelsep@bgt + 0.5\matrix@Aheight@bgt + 0.5\matrix@linewidth@bgt)$) {\cell@bgt};}
					}
				\fi
			}
		\fi
	\fi
\fi}
\newcommand{\toplabel@bgt}[2][]{
	\ifwithin@matrix@bgt
		\ifmatrix@immediate@text@bgt
			\def\temp{\@toplabel@bgt{#1}{#2}}
			\expandafter\temp\expandafter{\overlay@bgt}
		\else
			\AtEndEnvNoExpand@bgt{\@toplabel@bgt{#1}{#2}}
			\AtEndEnv@bgt{{\overlay@bgt}}
		\fi
	\else
		\def\temp{\@toplabel@bgt{#1}{#2}}
		\expandafter\temp\expandafter{\overlay@bgt}
	\fi
}
\addoverlay@bgt{toplabel}
%
% using pgffor appears marginally faster than listofitems
\newif\ifbottom@tight@bgt
\newif\ifbottom@baseline@bgt
\newif\ifbottom@forcemath@bgt
\define@key{bottom@bgt}{tight}[true]{\ifstreq@bgt{#1}{true}{\bottom@tight@bgttrue}{\bottom@tight@bgtfalse}}
\define@key{bottom@bgt}{color}{\colorlet{bottom@color@bgt}{#1}}
\define@key{bottom@bgt}{font}{\def\bottom@font@bgt{#1}}
\define@key{bottom@bgt}{base line}[true]{\ifstreq@bgt{#1}{true}{\bottom@baseline@bgttrue}{\bottom@baseline@bgtfalse}}
\define@key{bottom@bgt}{force math}[true]{\ifstreq@bgt{#1}{true}{\bottom@forcemath@bgttrue}{\bottom@baseline@bgtfalse}}
\def\@bottomlabel@bgt#1#2#3{
	% #1: options
	% #2: label
	% #3: overlay
	% Default options
	\begingroup
	\ifnum\nplayers@i@bgt>2
		\colorlet{bottom@color@bgt}{player3}
		\bottom@tight@bgttrue
	\else
		\colorlet{bottom@color@bgt}{xg-fg}
		\bottom@tight@bgtfalse
		\matrix@forcemath@label@bgtfalse
	\fi
	\ifcontrast@bgt\colorlet{bottom@color@bgt}{xg-fg}\fi
	\let\bottom@font@bgt\matrix@labelfont@bgt
	\let\bottom@baseline@bgt\matrix@baseline@bgt
	\ifmatrix@forcemath@label@bgt\bottom@forcemath@bgttrue\else\bottom@forcemath@bgtfalse\fi
	% process options
	\setkeys{bottom@bgt}{#1}
	% Place labels
	\ifbottom@tight@bgt
		\def\factor@bgt{1.1}
	\else
		\def\factor@bgt{1.4}
	\fi
	\foreach[count=\i@bgt] \item@bgt in {#2} {%
		\ifnum\i@bgt>\value{matrix@count@bgt}
			\PackageError{xgames}{The argument of bottomlabel exceeds the number of matrices}{}
		\else
			\ifmatrix@forcemath@label@bgt
				\def\temp@bgt{\ensuremath{\item@bgt}}
			\else
				\def\temp@bgt{\item@bgt}
			\fi
			\recall@overlay@bgt{\i@bgt}
			% measurements for strike
			\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\bottom@font@bgt\temp@bgt}\endpgfinterruptpicture}
			\expandafter\xdef\csname blabel@w\romannumeral\i@bgt\endcsname{\the\dimexpr\labelwidth@bgt+0.6\matrix@labelsep@bgt\relax}
			\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\bottom@font@bgt\temp@bgt}\endpgfinterruptpicture}
			\ifbottom@baseline@bgt
				% at the bottom, base line means setting height to \@Aheight
				\labelheight@bgt\@Aheight
			\else
				\settoheight{\labelheight@bgt}{\pgfinterruptpicture {\bottom@font@bgt\temp@bgt}\endpgfinterruptpicture}
			\fi
			\expandafter\xdef\csname blabel@h\romannumeral\i@bgt\endcsname{\the\dimexpr\labelheight@bgt+0.6\matrix@labelsep@bgt\relax}
			%
			\mat@visible@bgt{\node#3[font=\bottom@font@bgt, bottom@color@bgt] (pmt\i@bgt-b) at ($(pmt\i@bgt-tl) + 0.5*(\csname pmtotw\romannumeral\i@bgt\endcsname, 0) - (0, \csname pmtoth\romannumeral\i@bgt\endcsname) - (0, 0.5\labelheight@bgt + 0.5\labeldepth@bgt + \factor@bgt\matrix@labelsep@bgt)$) {\temp@bgt};}
			% node
			\ifmatrix@debug@bgt
				\mat@visible@bgt{\draw#3[debug@bgt] ($(pmt\i@bgt-tl) + 0.5*(\csname pmtotw\romannumeral\i@bgt\endcsname, 0) - (0, \csname pmtoth\romannumeral\i@bgt\endcsname) - (0.5\labelwidth@bgt, \factor@bgt\matrix@labelsep@bgt)$) rectangle ++(\labelwidth@bgt, -\labelheight@bgt);}
			\fi
		\fi
	}
	\endgroup
}
\newcommand{\bottomlabel@bgt}[2][]{
	\ifwithin@matrix@bgt
		\ifmatrix@immediate@text@bgt
			\def\temp{\@bottomlabel@bgt{#1}{#2}}
			\expandafter\temp\expandafter{\overlay@bgt}
		\else
			\AtEndEnvNoExpand@bgt{\@bottomlabel@bgt{#1}{#2}}
			\AtEndEnv@bgt{{\overlay@bgt}}
		\fi
	\else
		\def\temp{\@bottomlabel@bgt{#1}{#2}}
		\expandafter\temp\expandafter{\overlay@bgt}
	\fi
}
\addoverlay@bgt{bottomlabel}
%
% compute width and left offset only once
\ifcontrast@bgt
	\def\left@playercolor@bgt{xg-fg}
	\def\top@playercolor@bgt{xg-fg}
	\def\bottom@playercolor@bgt{xg-fg}
\else
	\def\left@playercolor@bgt{player1}
	\def\top@playercolor@bgt{player2}
	\def\bottom@playercolor@bgt{player3}
\fi
%
\newlength{\strike@offset}
\def\h@strike@bgt#1#2#3{
	% #1: matrix [optional]
	% #2: column
	% #3: overlay
	\ifnum#2>\pmthilen
		\PackageError{xgames}{The argument of strike exceeds the number of rows}{}
	\else
		\setlength{\strike@offset}{\dimexpr0.5\matrix@linewidth@bgt+1.9\matrix@labelsep@bgt+\left@maxwidth@bgt\relax}
		\ifstreq@bgt{#1}{}{
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				% compute x-coordinate
				\expandafter\itemtomacro\csname pmth\romannumeral\c@bgt\endcsname[#2]\temp@h@bgt
				\ifnum#2>1
					\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral\c@bgt\endcsname[#2-1]}
				\fi
				% output
				\mat@visible@bgt{\draw#3[line width=\matrix@strikewidth@bgt, \left@playercolor@bgt] ($(pmt\c@bgt-tl) - 0.5*(0, \temp@h@bgt) - (\strike@offset, 0)$) -- ++($(\csname pmtotw\romannumeral\c@bgt\endcsname, 0) + (\strike@offset + 0.5\matrix@linewidth@bgt, 0)$);}
			}
		}{
			% compute x-coordinate
			\expandafter\itemtomacro\csname pmth\romannumeral#1\endcsname[#2]\temp@h@bgt
			\ifnum#2>1
				\pgfmathsetmacro{\temp@h@bgt}{\temp@h@bgt + \csname pmth\romannumeral#1\endcsname[#2-1]}
			\fi
			% output
			\mat@visible@bgt{\draw#3[line width=\matrix@strikewidth@bgt, \left@playercolor@bgt] ($(pmt#1-tl) - 0.5*(0, \temp@h@bgt) - (\strike@offset, 0)$) -- ++($(\csname pmtotw\romannumeral#1\endcsname, 0) + (\strike@offset + 0.5\matrix@linewidth@bgt, 0)$);}
		}
	\fi
}
\def\v@strike@bgt#1#2#3{
	% #1: matrix [optional]
	% #2: column
	% #3: overlay
	\ifnum#2>\pmtwilen
		\PackageError{xgames}{The argument of strike exceeds the number of columns}{}
	\else
		\setlength{\strike@offset}{\dimexpr0.5\matrix@linewidth@bgt+1.8\matrix@labelsep@bgt+\matrix@Aheight@bgt\relax}
		\ifstreq@bgt{#1}{}{
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				% compute x-coordinate
				\expandafter\itemtomacro\csname pmtw\romannumeral\c@bgt\endcsname[#2]\temp@w@bgt
				\ifnum#2>1
					\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw\romannumeral\c@bgt\endcsname[#2-1]}
				\fi
				% output
				\mat@visible@bgt{\draw#3[line width=\matrix@strikewidth@bgt, \top@playercolor@bgt] ($(pmt\c@bgt-tl) + 0.5*(\temp@w@bgt, 0) + (0, \strike@offset)$) -- ++($(0, -\csname pmtoth\romannumeral\c@bgt\endcsname) - (0, \strike@offset + 0.5\matrix@linewidth@bgt)$);}%
			}
		}{
			% compute x-coordinate
			\expandafter\itemtomacro\csname pmtw\romannumeral#1\endcsname[#2]\temp@w@bgt
			\ifnum#2>1
				\pgfmathsetmacro{\temp@w@bgt}{\temp@w@bgt + \csname pmtw#1\c@bgt\endcsname[#2-1]}
			\fi
			% output
			\mat@visible@bgt{\draw#3[line width=\matrix@strikewidth@bgt, \top@playercolor@bgt] ($(pmt#1-tl) + 0.5*(\temp@w@bgt, 0) + (0, \strike@offset)$) -- ++($(0, -\csname pmtoth\romannumeral#1\endcsname) - (0, \strike@offset + 0.5\matrix@linewidth@bgt)$);}
		}
	\fi
}
%
\def\x@strike@bgt#1#2#3{
	% #1: non-sense argument
	% #2: matrix
	% #3: overlay
	\ifnum#2>\value{matrix@count@bgt}
		\PackageError{xgames}{The argument of strike exceeds the number of matrices}{}
	\else
		\recall@overlay@bgt{#2}
		\mat@visible@bgt{
		\draw#3[line width=\matrix@strikewidth@bgt, \bottom@playercolor@bgt] (pmt#2-tl) -- ++(\csname pmtotw\romannumeral#2\endcsname, -\csname pmtoth\romannumeral#2\endcsname);
		\draw#3[line width=\matrix@strikewidth@bgt, \bottom@playercolor@bgt] ($(pmt#2-tl) - (0, \csname pmtoth\romannumeral#2\endcsname)$) -- ++(\csname pmtotw\romannumeral#2\endcsname, \csname pmtoth\romannumeral#2\endcsname);
		\draw#3[line width=\matrix@strikewidth@bgt, \bottom@playercolor@bgt] ($(pmt#2-b) + 0.5*(-\csname blabel@w\romannumeral#2\endcsname, \csname blabel@h\romannumeral#2\endcsname)$) -- ++(\csname blabel@w\romannumeral#2\endcsname,-\csname blabel@h\romannumeral#2\endcsname);
		\draw#3[line width=\matrix@strikewidth@bgt, \bottom@playercolor@bgt] ($(pmt#2-b) + 0.5*(-\csname blabel@w\romannumeral#2\endcsname, -\csname blabel@h\romannumeral#2\endcsname)$) -- ++(\csname blabel@w\romannumeral#2\endcsname,\csname blabel@h\romannumeral#2\endcsname);
		}
	\fi
}
\def\@strike@bgt#1#2#3#4{
%	\ifexternal@bgt
%		\csname#1@strike@bgt\endcsname{#2}{#3}{#4}
%	\else
		\begin{pgfinterruptboundingbox}
		\csname#1@strike@bgt\endcsname{#2}{#3}{#4}
		\end{pgfinterruptboundingbox}
%	\fi
}
\def\strike@opt#1#2{
	\ifwithin@matrix@bgt
		\ifmatrix@delayedlabel@bgt\matrix@immediate@bgtfalse\fi%
		\ifmatrix@immediate@bgt
			\edef\temp{\noexpand\@strike@bgt{#1}{\option@bgt}{#2}{\overlay@bgt}}
			\temp
		\else
			\AtEndEnv@bgt{\noexpand\@strike@bgt{#1}{\option@bgt}{#2}{\overlay@bgt}}
		\fi
	\else
		\edef\temp{\noexpand\@strike@bgt{#1}{\option@bgt}{#2}{\overlay@bgt}}
		\temp
	\fi
}
\addoptions@bgt{strike}
\addoverlay@bgt{strike}
%
\def\addplayers{
	% measure player label
	\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@font@bgt\playernamei@bgt}\endpgfinterruptpicture}
	\settoheight{\labelheight@bgt}{\pgfinterruptpicture {\matrix@font@bgt\playernamei@bgt}\endpgfinterruptpicture}
	\ifmatrix@debug@bgt
		\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@font@bgt\playernamei@bgt}\endpgfinterruptpicture}
		\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
			\recall@overlay@bgt{\c@bgt}
			\mat@visible@bgt{\node[font=\matrix@font@bgt, \left@playercolor@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \csname pmtoth\romannumeral\c@bgt\endcsname) - (0.5\matrix@linewidth@bgt + \left@maxwidth@bgt + 2.8\matrix@labelsep@bgt + 0.5\labelheight@bgt - 0.5\labeldepth@bgt, 0)$) {\rotatebox{90}{\playernamei@bgt}};}
			\mat@visible@bgt{\draw[debug@bgt] ($(pmt\c@bgt-tl) - 0.5*(0, \csname pmtoth\romannumeral\c@bgt\endcsname) - (0.5\matrix@linewidth@bgt + \left@maxwidth@bgt + 2.8\matrix@labelsep@bgt - 0.5\labeldepth@bgt, -0.5\labelwidth@bgt)$) rectangle ++(-\labelheight@bgt, -\labelwidth@bgt);}
		}
	\else
		\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
			\recall@overlay@bgt{\c@bgt}
			\mat@visible@bgt{\node[font=\matrix@font@bgt, \left@playercolor@bgt] at ($(pmt\c@bgt-tl) - 0.5*(0, \csname pmtoth\romannumeral\c@bgt\endcsname) - (0.5\matrix@linewidth@bgt + \left@maxwidth@bgt + 2.8\matrix@labelsep@bgt + 0.5\labelheight@bgt - 0.5\labeldepth@bgt, 0)$) {\rotatebox{90}{\playernamei@bgt}};}
		}
	\fi
	% place player label
	\ifnum\nplayers@i@bgt>1
		\settodepth{\labeldepth@bgt}{\pgfinterruptpicture {\matrix@font@bgt\playernameii@bgt}\endpgfinterruptpicture}
		\ifmatrix@debug@bgt
			\settowidth{\labelwidth@bgt}{\pgfinterruptpicture {\matrix@font@bgt\playernameii@bgt}\endpgfinterruptpicture}
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				\mat@visible@bgt{\node[font=\matrix@font@bgt, \top@playercolor@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\csname pmtotw\romannumeral\c@bgt\endcsname, 0) + (0, 0.5\matrix@linewidth@bgt + 2.8\matrix@labelsep@bgt + 1.5\matrix@Aheight@bgt - 0.5\labeldepth@bgt)$) {\playernameii@bgt};}
				\mat@visible@bgt{\draw[debug@bgt] ($(pmt\c@bgt-tl) + 0.5*(\csname pmtotw\romannumeral\c@bgt\endcsname, 0) + (-0.5\labelwidth@bgt, 0.5\matrix@linewidth@bgt + 2.8\matrix@labelsep@bgt + \matrix@Aheight@bgt - 0.5\labeldepth@bgt)$) rectangle ++(\labelwidth@bgt, \matrix@Aheight@bgt);}
			}
		\else
			\foreach \c@bgt in {1, ..., \value{matrix@count@bgt}} {
				\recall@overlay@bgt{\c@bgt}
				\mat@visible@bgt{\node[font=\matrix@font@bgt, \top@playercolor@bgt] at ($(pmt\c@bgt-tl) + 0.5*(\csname pmtotw\romannumeral\c@bgt\endcsname, 0) + (0, 0.5\matrix@linewidth@bgt + 2.8\matrix@labelsep@bgt + 1.5\matrix@Aheight@bgt - 0.5\labeldepth@bgt)$) {\playernameii@bgt};}
			}
		\fi
	\fi
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		3.2 Drawing Payoff Set
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newif\ifpayoff@oneaxis@bgt
\newif\ifpayoff@drawn@bgt
\tikzset{payoff@axis@bgt/.style={line width=\payoff@linewidth@bgt, -latex}}
%
% Optional arguments
\define@bgts@family{payoff}{
	name, pmt;
	axis, 1.22;
	xscale, 1;
	yscale, 1;
	shift, {0, 0}
}{
	line width, \edgelinewidth@bgt % fine
}{}{
	labels, true
}{}{%
%	vertical align -> state
}{}
%
\define@key@thickness@bgts{payoff}
%
% Single-layer key system cannot use \define@key@scale since that affects @def
\define@key{payoff@bgt}{scale}{\def\payoff@xscale@bgt{#1}\def\payoff@yscale@bgt{#1}}
\define@key{payoff@bgt}{line width}{\setlength{\payoff@linewidth@bgt}{#1}\state@setlinewidth@bgt{def}{#1}}%
\define@key{payoff@bgt}{matrix}{\def\payoff@matrix@bgt{#1}}
\define@key{payoff@bgt}{force math}[true]{\ifstreq@bgt{#1}{true}{\matrix@forcemath@label@bgttrue}{\matrix@forcemath@label@bgtfalse}}
\define@key{payoff@bgt}{tikz nodes}[true]{\ifstreq@bgt{#1}{true}{\state@delay@deffalse}{\state@delay@deftrue}}
%\define@key{payoff@bgt}{vertical align}{\ifstreq@bgt{#1}{true}{\matrix@forcemath@label@bgttrue}{\matrix@forcemath@label@bgtfalse}}
%
\comment{% not currently used
\def\ignore@bgt<#1>#2{#2}
\def\ignoreoverlay@bgt{\futurelet\nextChar@bgt\idCheck@bgt}
\def\idCheck@bgt{%
	\ifx\nextChar@bgt<%
		\expandafter\ignore@bgt%
	\else%
		\expandafter\@firstofone%
	\fi%
}}
%
\def\payoff@arg@bgt{}
\newcommand{\drawpayoffs@bgt}[1][]{%
	\def\payoff@arg@bgt{#1}%
	\ifwithin@matrix@bgt%
		\ifmatrix@delayedlabel@bgt\matrix@immediate@bgtfalse\fi%
		\ifmatrix@immediate@bgt%
			\draw@payoffs@bgt%
		\else%
			\payoff@drawn@bgttrue%
		\fi%
	\else%
		\draw@payoffs@bgt%
	\fi%
}
\def\draw@payoffs@bgt{
	\begingroup
	\def\br##1{##1}
	\def\payoff@matrix@bgt{1}
	\expandafter\payoffsetoptions\expandafter{\payoff@arg@bgt}
	\expandafter\@ifundefined\expandafter{\payoff@name@bgt @playeri@bgtlen}{
		\ifstreq@bgt{\payoff@name@bgt}{pmt}{
			\PackageError{xgames}{Option name is required in drawpayoffs}{You need to set 'name = ...' to load your stored payoff matrix.}
		}{
			\PackageError{xgames}{Invalid name provided to drawpayoffs}{}
		}
	}{
	\ifmatrix@forcemath@label@bgt\else\ifwithin@matrix@bgt\else\PackageWarning{xgames}{If drawpayoffs is called within a separate tikzpicture environment, you need to re-issue the 'force math' option.}{}\fi\fi
	\expandafter\ifnum\csname nplayers@\romannumeral\payoff@matrix@bgt @bgt\endcsname=1\PackageError{xgames}{drawpayoffs requires two players}{}\else\expandafter\ifnum\csname nplayers@\romannumeral\payoff@matrix@bgt @bgt\endcsname=2\else\PackageError{xgames}{drawpayoffs requires two players. Payoffs of remaining players ignored}{}\fi\fi
	% initialize min and max within limits
	\def\payoff@xmin@bgt{16000}
	\def\payoff@xmax@bgt{-16000}
	\def\payoff@ymin@bgt{16000}
	\def\payoff@ymax@bgt{-16000}
	% Find maxima and minima
	\edef\payoff@tikzoptions@bgt{shift={(\payoff@shift@bgt)}, xscale=\payoff@xscale@bgt, yscale=\payoff@yscale@bgt}
	\def\temp{\begin{scope}[}
	\expandafter\temp\payoff@tikzoptions@bgt]
	\def\listofpoints@bgt{}
	% in order to compute payoff center
	\def\sum@x@bgt{0}
	\def\sum@y@bgt{0}
	\foreach \i@bgt in {1, ..., \csname\payoff@name@bgt @playeri@bgtlen\endcsname} {
		\foreach \j@bgt in {1, ..., \csname\payoff@name@bgt @playerii@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname\payoff@name@bgt @payoff@\romannumeral\payoff@matrix@bgt @bgt\endcsname[\i@bgt, \j@bgt, 1]\x@bgt
			\expandafter\itemtomacro\csname\payoff@name@bgt @payoff@\romannumeral\payoff@matrix@bgt @bgt\endcsname[\i@bgt, \j@bgt, 2]\y@bgt
			% store coordinates as a list of points for convex hull
			\ifstreq@bgt{\listofpoints@bgt}{}{
				\xdef\listofpoints@bgt{(\x@bgt, \y@bgt)}
			}{
				\xdef\listofpoints@bgt{\listofpoints@bgt, (\x@bgt, \y@bgt)}
			}
			% compute sum for payoff center
			\pgfmathparse{\sum@x@bgt + \x@bgt}
			\global\let\sum@x@bgt\pgfmathresult
			\pgfmathparse{\sum@y@bgt + \y@bgt}
			\global\let\sum@y@bgt\pgfmathresult
			% store maxima and minima
			\ifdim\x@bgt pt>\payoff@xmax@bgt pt
				\xdef\payoff@xmax@bgt{\x@bgt}
			\fi
			\ifdim\x@bgt pt<\payoff@xmin@bgt pt
				\xdef\payoff@xmin@bgt{\x@bgt}
			\fi
			\ifdim\y@bgt pt>\payoff@ymax@bgt pt
				\xdef\payoff@ymax@bgt{\y@bgt}
			\fi
			\ifdim\y@bgt pt<\payoff@ymin@bgt pt
				\xdef\payoff@ymin@bgt{\y@bgt}
			\fi
		}
	}
	\pgfmathsetmacro{\ratio@bgt}{1/\csname\payoff@name@bgt @playeri@bgtlen\endcsname/\csname\payoff@name@bgt @playerii@bgtlen\endcsname}
	\coordinate (payoff@center@bgt) at (\ratio@bgt*\sum@x@bgt, \ratio@bgt*\sum@y@bgt);
	% Axes
	\pgfmathsetmacro{\yaxis@bgt}{max(\payoff@xmin@bgt, 0)}
	\pgfmathsetmacro{\xaxis@bgt}{max(\payoff@ymin@bgt, 0)}
	\ifdim\payoff@xmin@bgt pt<0pt
		\payoff@oneaxis@bgtfalse
	\else
		\ifdim\payoff@ymin@bgt pt<0pt
			\payoff@oneaxis@bgtfalse
		\else
			\payoff@oneaxis@bgttrue
		\fi
	\fi
	\ifpayoff@oneaxis@bgt
		\expandafter\draw\overlay@bgt[payoff@axis@bgt, latex-latex] ($(\payoff@xmin@bgt, \payoff@ymin@bgt) + \payoff@axis@bgt*(0, \payoff@ymax@bgt-\payoff@ymin@bgt)$) -- (\payoff@xmin@bgt, \payoff@ymin@bgt) -- ++($\payoff@axis@bgt*(\payoff@xmax@bgt-\payoff@xmin@bgt, 0)$);
	\else
		\expandafter\draw\overlay@bgt[payoff@axis@bgt] (\payoff@xmin@bgt, \xaxis@bgt) -- ++($\payoff@axis@bgt*(\payoff@xmax@bgt-\payoff@xmin@bgt, 0)$);
		\expandafter\draw\overlay@bgt[payoff@axis@bgt] (\yaxis@bgt, \payoff@ymin@bgt) -- ++($\payoff@axis@bgt*(0, \payoff@ymax@bgt-\payoff@ymin@bgt)$);
	\fi
	% Convex hull
	\def\temp{\ConvexHull[coordinates=}
	\expandafter\temp\expandafter{\listofpoints@bgt}]
	\expandafter\draw\overlay@bgt[line width=\payoff@linewidth@bgt] plot[samples at=\outerPoints] (ConvexHullPoint-\x) -- cycle;
	% States
	\foreach \i@bgt in {1, ..., \csname\payoff@name@bgt @playeri@bgtlen\endcsname} {
		\expandafter\itemtomacro\csname\payoff@name@bgt @playeri@bgt\endcsname[\i@bgt]\actioni@bgt
		\foreach \j@bgt in {1, ..., \csname\payoff@name@bgt @playerii@bgtlen\endcsname} {
			\expandafter\itemtomacro\csname\payoff@name@bgt @playerii@bgt\endcsname[\j@bgt]\actionii@bgt
			% access first two coordinates. accessing [\i@bgt, \j@bgt] would result in 3d graph
			\expandafter\itemtomacro\csname\payoff@name@bgt @payoff@\romannumeral\payoff@matrix@bgt @bgt\endcsname[\i@bgt, \j@bgt, 1]\x@bgt
			\expandafter\itemtomacro\csname\payoff@name@bgt @payoff@\romannumeral\payoff@matrix@bgt @bgt\endcsname[\i@bgt, \j@bgt, 2]\y@bgt
			% Determine angle to place label
			\coordinate (\payoff@name@bgt @bgt-\i@bgt-\j@bgt) at (\x@bgt, \y@bgt);
			\pgfextractangle{\angle@bgt}{payoff@center@bgt}{\payoff@name@bgt @bgt-\i@bgt-\j@bgt}
			% Determine label
			\ifpayoff@labels@bgt
				\ifmatrix@forcemath@label@bgt
					\edef\payoff@label@bgt{\noexpand\contour{xg-bg}{\noexpand\ensuremath{\noexpand\ap{\actioni@bgt, \actionii@bgt}}}}
				\else
					\edef\payoff@label@bgt{\noexpand\contour{xg-bg}{\noexpand\ap[, ]{\actioni@bgt, \actionii@bgt}}}
			\fi\fi
			% Place state
			\begingroup
				\state@delay@deffalse
				\ifpayoff@labels@bgt
					\expandafter\state@bgt\overlay@bgt[base line=false, label=\angle@bgt] (\payoff@name@bgt @bgt-\i@bgt-\j@bgt) at (\payoff@name@bgt @bgt-\i@bgt-\j@bgt) {\payoff@label@bgt};
				\else
					\expandafter\state@bgt\overlay@bgt (\payoff@name@bgt @bgt-\i@bgt-\j@bgt) at (\payoff@name@bgt @bgt-\i@bgt-\j@bgt);
				\fi
			\endgroup
		}
	}
	\end{scope}
	}\ifpayoff@sticky@bgt%
		\endgroup%
		\expandafter\payoffsetoptions\expandafter{\payoff@arg@bgt}%
	\else%
		\endgroup%
	\fi%
	\def\payoff@arg@bgt{}%
}
\addoverlay@bgt{drawpayoffs}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		3.3 Half-Spaces
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newif\ifhs@normal@bgt
\newif\ifhs@dirprovided@bgt
\newif\ifhs@leftspecified@bgt
% Should inherit font and 
%
\define@bgt@family{halfspace}{
	label, 0;
	l, 2;
%	r, 2;
	w, 4;
	depth, 0.5;
	hatch, 1mm
}{}{}{
	contour, false
}{}{}{}{}
%
\define@key{halfspace@bgt}{label}{\def\halfspace@label@bgt{#1}\hs@dirprovided@bgttrue}
\directionkeys@bgt{halfspace}{state}{\hs@dirprovided@bgttrue}
%
\define@key{halfspace@def}{l}{\def\halfspace@l@def{#1}\hs@leftspecified@bgttrue}
\define@key{halfspace@bgt}{l}{\def\halfspace@l@bgt{#1}\hs@leftspecified@bgttrue}
\define@key{halfspace@def}{w}{\def\halfspace@w@def{#1}\ifhs@leftspecified@bgt\else\pgfmathsetmacro{\halfspace@l@def}{0.5*\halfspace@w@def}\fi}
\define@key{halfspace@bgt}{w}{\def\halfspace@w@bgt{#1}\ifhs@leftspecified@bgt\else\pgfmathsetmacro{\halfspace@l@bgt}{0.5*\halfspace@w@bgt}\fi}
%
\def\halfspace@opt#1at#2(#3)#4dir#5(#6)#7;{
% #1, #2, #4, #5: gobble space
% #3: coordinate
% #6: direction of normal vector
% #7: label of normal vector
	\hs@dirprovided@bgtfalse
	\hs@leftspecified@bgtfalse
	\ifpassoptionstotikz@bgt
		\parsekeyvalue@bgt{halfspace}{\option@bgt}
	\else
		\expandafter\halfspacesetoptions@bgt\expandafter{\option@bgt}
		\def\passtotikz@bgt{}
	\fi
	% read coordinate
	\setsepchar{$} %$
	\readlist*\coord@bgt{#3}
	\ifnum\coord@bgtlen>1
		\itemtomacro\coord@bgt[2]\compute@coord
	\else
		\def\compute@coord{(#3)}
	\fi
	% read normal vector
	\setsepchar{:}
	\readlist*\normal@bgt{#6}
	\itemtomacro\normal@bgt[1]\hs@dir@bgt
	% read label
	\let\label@overlay@bgt\overlay@bgt
	\ifempty@bgt{#7}{\def\labeltext@bgt{}}{
		\setsepchar{<||>}
		\readlist*\mandatorylist@bgt{#7}
		% parse and store label overlay
		\ifnum\mandatorylist@bgtlen>1
			\edef\label@overlay@bgt{<\mandatorylist@bgt[2]>}
			\itemtomacro\mandatorylist@bgt[3]\labeltext@bgt
		\else
			\def\labeltext@bgt{#7}
		\fi
	}
	% draw half space
	\edef\draw@hs{\noexpand\draw\overlay@bgt[line width=\state@linewidth@bgt] ($\compute@coord + (\hs@dir@bgt+90:\halfspace@l@bgt)$) -- ++(\hs@dir@bgt-90:\halfspace@w@bgt);}
	\draw@hs
	% hatch in a length invariant way
	\begin{scope}
		\pgfmathsetmacro{\hs@orth@bgt}{\hs@dir@bgt+90}
		\length@invariant@bgt{hatchstep@bgt}{\hs@orth@bgt:-\halfspace@hatch@bgt}
		\edef\draw@hs{\noexpand\clip ($\compute@coord + (\hs@orth@bgt:\halfspace@l@bgt)$) -- ++(\hs@orth@bgt:-\halfspace@w@bgt) -- ++(\hs@dir@bgt:-\halfspace@depth@bgt) -- ++(\hs@orth@bgt:\halfspace@w@bgt) -- cycle;}
		\draw@hs
		\pgfmathtruncatemacro{\hatchnr}{sqrt((\xscale@bgt*sin(\hs@dir@bgt))^2 + (\yscale@bgt*cos(\hs@dir@bgt))^2)*\halfspace@depth@bgt + sqrt((\xscale@bgt*sin(\hs@orth@bgt))^2 + (\yscale@bgt*cos(\hs@orth@bgt))^2)*\halfspace@w@bgt)/\halfspace@hatch@bgt}
		\foreach \i in {0, ..., \hatchnr} {
			\edef\draw@hs{\noexpand\draw\overlay@bgt ($\compute@coord + (\hs@orth@bgt:\halfspace@l@bgt) + \i*\@hatchstep@bgt$) -- ++(\hs@orth@bgt+45:1.42*\halfspace@depth@bgt);}
			\draw@hs
		}
	\end{scope}
	% draw normal vector if need be
	\ifnum\normal@bgtlen>1
		\hs@normal@bgttrue
	\else
		\ifstreq@bgt{\labeltext@bgt}{}{\hs@normal@bgtfalse}{\hs@normal@bgttrue}
	\fi
	\ifhs@normal@bgt
		\ifhs@dirprovided@bgt\else\let\halfspace@label@bgt\hs@dir@bgt\fi
		\length@invariant@bgt{normalvec@bgt}{#6}
		\expandafter\draw\label@overlay@bgt[edge, -latex] (#3) -- ++\normalvec@bgt;
		\begingroup
			% settings of last state are still active since this was called out of \state
			\setiftodefault@bgt{state@delay}
			\state@delaycontour@bgtfalse
			\ifhalfspace@contour@bgt\state@contour@bgttrue\else\state@contour@bgtfalse\fi
			\placelabel@bgt{\state@labelcolor@bgt}{$\compute@coord + \@normalvec@bgt$}{\halfspace@label@bgt}{\dimexpr\belief@innersep@bgt\relax}{\state@font@bgt}{\labeltext@bgt}{\overlay@bgt}{\label@overlay@bgt}%
		\endgroup
	\fi
}
\addoptions@bgt{halfspace}
\addoverlay@bgt{halfspace}
%
%%%%%%%%%%%%%%%%%%%%%%%%
%	    3.4 Zoom
%%%%%%%%%%%%%%%%%%%%%%%%
%
\define@key{@zoom}{l}{\def\lower@zoom{#1}}
\define@key{@zoom}{u}{\def\upper@zoom{#1}}
\define@key{@zoom}{scale}{\def\scale@zoom{#1}}
\define@key{@zoom}{shift}[0,0]{\def\shift@zoom{#1}}
%
\def\zoom@opt#1#2{
	% #1: canvas
	% #2: markup in zoomed image
	\begingroup\state@delay@deffalse
	\def\temp@a{\setkeys{@zoom}}
	\expandafter\temp@a\expandafter{\option@bgt}
	\coordinate (zoom@1) at (\lower@zoom);
	\coordinate (zoom@2) at (\lower@zoom |- \upper@zoom);
	\coordinate (zoom@3) at (\upper@zoom);
	\coordinate (zoom@4) at (\upper@zoom |- \lower@zoom);
	\let\zoom@overlay@bgt\overlay@bgt
	\pgfmathsetmacro{\f@bgt}{(1-\scale@zoom)/2}
	\foreach \i@zoom in {1, ..., 4} {
		\expandafter\draw\zoom@overlay@bgt[gray!25!, thin] (zoom@\i@zoom) -- ($\scale@zoom*(zoom@\i@zoom) + \f@bgt*(\lower@zoom) + \f@bgt*(\upper@zoom) + (\shift@zoom)$);
	}
	#1
	\expandafter\draw\zoom@overlay@bgt (\lower@zoom) rectangle (\upper@zoom);
	% technically, one should add the overlay instructions, but it requires collecting the argument
	\AtEndEnv@bgt{\noexpand\begin{scope}[shift={(\shift@zoom)}, scale=\scale@zoom] \noexpand\clip (\lower@zoom) rectangle (\upper@zoom);}
	\expandafter\alt\zoom@overlay@bgt{
	\begin{scope}[shift={($\f@bgt*(\lower@zoom) + \f@bgt*(\upper@zoom) + (\shift@zoom)$)}, scale=\scale@zoom]
		\expandafter\clip[draw] (\lower@zoom) rectangle (\upper@zoom);
		#1
		#2
	\end{scope}
	}{}
	\AtEndEnv@bgt{\noexpand\end{scope}}
	% reset coordinates without issuing draw commands to the end of the environment
	\begingroup
		\def\AtEndEnv@bgt##1{}
		\setbox0=\hbox{#1}
	\endgroup
	\endgroup
}
\addoptions@bgt{zoom}
\addoverlay@bgt{zoom}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	    4.0 Extensive-form games
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\def\process@direction#1{%
	\ifstreq@bgt{#1}{above}{\gdef#1{90}}{%
	\ifstreq@bgt{#1}{below}{\gdef#1{-90}}{%
	\ifstreq@bgt{#1}{left}{\gdef#1{180}}{%
	\ifstreq@bgt{#1}{right}{\gdef#1{0}}{%
	\ifstreq@bgt{#1}{above left}{\gdef#1{135}}{%
	\ifstreq@bgt{#1}{above right}{\gdef#1{45}}{%
	\ifstreq@bgt{#1}{below left}{\gdef#1{225}}{%
	\ifstreq@bgt{#1}{below right}{\gdef#1{315}}{%
	}}}}}}}}%
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%		4.1 Edges
%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Variables for edges
\newif\ifedge@readarg@bgt
\newif\ifedge@definesarc@bgt
\newif\ifprob@branch@bgt
\newif\ifterminal@dirprovided@bgt
\def\edge@labels@overlay@def{}
%
% Optional arguments of edges (the to[] options)
\define@bgt@family{edge}{
	font, \labelfontsize
%	payoffs, below % above, below, number etc. % global so it can be passed to \branch instead of \to?
}{
	line width, \edgelinewidth@bgt;
	alert width, 1.5\edgelinewidth@bgt;
	label sep, 0.6ex
}{}{
	debug, false;
	contour, false;
	delay contour, false;
	etc, false;
	open, false
}{
	label placement, center:box:simple;
	labels, outside:inside:none
}{%
	color, xg-fg;
	arc color, xg-fg!10!
}{}{
	\ifedge@sticky@bgt\else%
		\let\edge@labels@overlay@bgt\edge@labels@overlay@def%
	\fi%
}
%
\edge@labelplacement@box@deftrue
%
\define@key@thickness@bgt{edge}
%
\define@key{edge@def}{contour}[true]{\ifstreq@bgt{#1}{true}{\edge@contour@deftrue}{\ifstreq@bgt{#1}{delay}{\edge@contour@deftrue\edge@delaycontour@deftrue}{\edge@contour@deffalse\edge@delaycontour@deffalse}}}
\define@key{edge@bgt}{contour}[true]{\ifstreq@bgt{#1}{true}{\edge@contour@bgttrue}{\ifstreq@bgt{#1}{delay}{\edge@contour@bgttrue\edge@delaycontour@bgttrue}{\edge@contour@bgtfalse\edge@delaycontour@bgtfalse}}}
%
% Sticky keys
\define@key{edge@bgt}{v}{\gdef\edge@v@bgt{#1}}
\define@key{edge@bgt}{h}{\gdef\edge@h@bgt{#1}}
%
% Local keys
\define@key{edge@bgt}{payoffs}{\def\edge@payoffs@bgt{#1}\terminal@dirprovided@bgttrue}
\define@key{edge@bgt}{arc}{\def\edge@arc@bgt{#1}\edge@definesarc@bgttrue}
%
% Passing options to terminal nodes
\define@key{edge@bgt}{p}[true]{\tree@terminal@e@bgtfalse\tree@terminal@n@bgtfalse}
\define@key{edge@bgt}{n}[true]{\tree@terminal@e@bgtfalse\tree@terminal@n@bgttrue}
\define@key{edge@bgt}{e}[true]{\tree@terminal@e@bgttrue}
%
\define@key{edge@def}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\edge@debug@deftrue}{\edge@debug@deffalse}%
	\ifstreq@bgt{#1}{detail}{\edge@debug@deftrue\debug@detail@bgttrue}{}%
}
\define@key{edge@bgt}{debug}[true]{%
	\ifstreq@bgt{#1}{true}{\edge@debug@bgttrue}{\edge@debug@bgtfalse}%
	\ifstreq@bgt{#1}{detail}{\edge@debug@bgttrue\debug@detail@bgttrue}{}%
}
%
\define@key{edge@bgt}{labels}{% make the option overlay aware
	\setsepchar{<||>}%
	\readlist*\edge@labels@input@bgt{#1}%
	\ifnum\edge@labels@input@bgtlen=1%
		\let\edge@labels@overlay@bgt\edge@labels@overlay@def%
		\def\edge@labels@in@bgt{#1}%
	\else%
		\edef\edge@labels@overlay@bgt{<\edge@labels@input@bgt[2]>}%
		\itemtomacro\edge@labels@input@bgt[3]\edge@labels@in@bgt%
	\fi%
	\ifstreq@bgt{\edge@labels@in@bgt}{inside}{%
		\edge@labels@inside@bgttrue%
		\edge@labels@none@bgtfalse%
	}{%
		\ifstreq@bgt{\edge@labels@in@bgt}{none}{%
			\edge@labels@none@bgttrue%
			\edge@labels@inside@bgtfalse%
		}{%
			\ifstreq@bgt{\edge@labels@in@bgt}{outside}{%
				\edge@labels@none@bgtfalse%
				\edge@labels@inside@bgtfalse%
			}{}
}}}
%
\def\edge@defaultdirections@bgt@org#1#2{ % BB: this is all sorts of weird
	\pgfextractangle{\angle@bgt}{#1}{#2}%
	\iftree@vertical@bgt%
		\ifdim\angle@bgt pt<180pt%
			\ifdim\angle@bgt pt=0pt%
				\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}%
				\def\terminaldir@bgt{-90}%
				\gdef\labeldir@bgt{90}%
			\else%
				\def\terminaldir@bgt{90}%
				\gdef\labeldir@bgt{-90}%
				\ifdim\angle@bgt pt<90pt%
					\pgfmathtruncatemacro{\edge@labeldir@bgt}{-90}%
				\else%
					\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}%
			\fi\fi%
		\else%
			% payoffs
			\def\terminaldir@bgt{-90}%
			\gdef\labeldir@bgt{90}%
			% action labels
			\ifdim\angle@bgt pt>270pt%
				\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}%
			\else%
				\pgfmathtruncatemacro{\edge@labeldir@bgt}{-90}%
		\fi\fi%
	\else%
		\ifdim\angle@bgt pt>90pt%
			\ifdim\angle@bgt pt<270pt%
				% payoffs
				\def\terminaldir@bgt{180}%
				\gdef\labeldir@bgt{0}%
				% action labels
				\ifdim\angle@bgt pt>180pt%
					\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}%
				\else%
					\pgfmathtruncatemacro{\edge@labeldir@bgt}{-90}%
				\fi%
			\else%
				% payoffs
				\def\terminaldir@bgt{0}%
				\gdef\labeldir@bgt{180}%	
				% action labels
				\pgfmathtruncatemacro{\edge@labeldir@bgt}{-90}%
			\fi%
		\else%
			% payoffs
			\def\terminaldir@bgt{0}%
			\gdef\labeldir@bgt{180}%
			% action labels
			\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}%
	\fi\fi%
}
\def\edge@defaultdirections@bgt#1#2{
	\pgfextractangle{\angle@bgt}{#1}{#2}%
	\iftree@vertical@bgt%
		\ifdim\angle@bgt pt<180pt%
			\ifdim\angle@bgt pt=0pt%
				\gdef\edge@labeldir@bgt{90}%
				\gdef\terminaldir@bgt{-90}%
				\gdef\labeldir@bgt{90}%
			\else%
				\gdef\terminaldir@bgt{90}%
				\gdef\labeldir@bgt{-90}%
				\ifdim\angle@bgt pt<90pt%
					\gdef\edge@labeldir@bgt{-90}%
				\else%
					\gdef\edge@labeldir@bgt{90}%
			\fi\fi%
		\else%
			% payoffs
			\gdef\terminaldir@bgt{-90}%
			\gdef\labeldir@bgt{90}%
			% action labels
			\ifdim\angle@bgt pt>270pt%
				\gdef\edge@labeldir@bgt{90}%
			\else%
				\gdef\edge@labeldir@bgt{-90}%
		\fi\fi%
	\else%
		\ifdim\angle@bgt pt>90pt%
			\ifdim\angle@bgt pt<270pt%
				% payoffs
				\gdef\terminaldir@bgt{180}%
				\gdef\labeldir@bgt{0}%
				% action labels
				\ifdim\angle@bgt pt>180pt%
					\gdef\edge@labeldir@bgt{90}%
				\else%
					\gdef\edge@labeldir@bgt{-90}%
				\fi%
			\else%
				% payoffs
				\gdef\terminaldir@bgt{0}%
				\gdef\labeldir@bgt{180}%	
				% action labels
				\gdef\edge@labeldir@bgt{-90}%
			\fi%
		\else%
			% payoffs
			\gdef\terminaldir@bgt{0}%
			\gdef\labeldir@bgt{180}%
			% action labels
			\gdef\edge@labeldir@bgt{90}%
	\fi\fi%
}
\def\drawbranch@bgt#1#2#3{%
% #1: coordinate of parent
% #2: coordinate of child
% #3: child argument: A<3->[l, 0.66](2, 5)
% options from \branch[] and to[] have already been processed and stored
% active player has already been set
% overlay specifications from \branch has been stored in \overlay@bgt
	% read optional arguments
	\setsepchar{<||>/[||]/(||)/,}%
	\readlist*\branchopt@bgt{#3}%
	% determine standard direction of labels and payoffs
	\edge@defaultdirections@bgt{#1}{#2}
	% User-supplied direction of payoffs
	\ifterminal@dirprovided@bgt%
		\process@direction{\edge@payoffs@bgt}%
		\let\terminaldir@bgt\edge@payoffs@bgt%
	\fi%
	% if labels are supposed to be inside
	\ifedge@labels@inside@bgt%
		\pgfmathtruncatemacro{\edge@labeldir@bgt}{-\edge@labeldir@bgt}%
	\fi%
	% determine whether to process optional label arguents
	\pgfmathtruncatemacro{\labelargs@bgt}{\listlen\branchopt@bgt[\branchopt@bgtlen]}%
	\pgfmathtruncatemacro{\terminal@bgt}{\listlen\branchopt@bgt[\branchopt@bgtlen, \labelargs@bgt]}%
	\edge@readarg@bgtfalse%
	\ifedge@labels@none@bgt%
		\ifnum\terminal@bgt>1\relax%
			\edge@readarg@bgttrue%
		\else%
			\ifprob@branch@bgt%
				\edge@readarg@bgttrue%
			\fi%
		\fi%
	\else%
		\edge@readarg@bgttrue%
	\fi%
	\def\edge@prob@bgt{0}%
	% process optional label arguments
	\ifedge@readarg@bgt%
		\pgfmathsetmacro{\pos@bgt}{0.52}%
		% escape by default if the terminal label does not have a comma
		\ifnum\terminal@bgt>1\relax%
			\pgfmathtruncatemacro{\nplayers@bgt}{\listlen\branchopt@bgt[\branchopt@bgtlen,\labelargs@bgt,2]}%
			\ifnum\nplayers@bgt=1\relax%
				\tree@terminal@e@bgttrue%
		\fi\fi%
		% process user input
		\ifnum\labelargs@bgt>1\relax%
		  \foreachitem \item@bgt \in \branchopt@bgt[\branchopt@bgtlen,2,1]{%
			\ifstreq@bgt{\item@bgt}{l}{\pgfmathtruncatemacro{\edge@labeldir@bgt}{90}}{%
			  \ifstreq@bgt{\item@bgt}{r}{\pgfmathtruncatemacro{\edge@labeldir@bgt}{-90}}{%
				\ifstreq@bgt{\item@bgt}{e}{\tree@terminal@e@bgttrue}{%
				  \ifstreq@bgt{\item@bgt}{n}{\tree@terminal@n@bgttrue}{%
					\ifstreq@bgt{\item@bgt}{p}{\tree@terminal@e@bgtfalse\tree@terminal@n@bgtfalse}{
					  \ifstreq@bgt{\item@bgt}{etc}{\edge@etc@bgttrue}{
						\ifstreq@bgt{\item@bgt}{open}{\edge@open@bgttrue}{
						  \ifprob@branch@bgt
							\pgfmathsetmacro{\edge@prob@bgt}{\item@bgt}
						  \else
							\expandafter\ifdim\item@bgt pt>1pt
						      \xdef\terminaldir@bgt{\item@bgt}
							\else\expandafter\ifdim\item@bgt pt<0pt
						      \xdef\terminaldir@bgt{\item@bgt}
							\else\expandafter\ifdim\item@bgt pt=0pt
						      \xdef\terminaldir@bgt{\item@bgt}
							\else
							  \xdef\pos@bgt{\item@bgt}
							\fi\fi\fi
						  \fi%
			}}}}}}}}%
	\fi\fi%
	%
	\addto@kidlist@bgt{#1}{#2}
	%
	% read overlay specification for highlighting
	\ifdim\edge@prob@bgt pt>0pt
		% draw a regular or highlighted branch first
		% this is better than using \alt because \alt is based on \only
		\ifnum\branchopt@bgtlen>1%
			\edef\branch@overlay@bgt{<\branchopt@bgt[2]>}%
			\expandafter\alt\branch@overlay@bgt{%
				\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (#1) -- (#2);%
			}{%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- (#2);%
			}%
		\else%
			\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- (#2);%
		\fi%
		% read probability argument list
		\setsepchar{<||>}%
		\expandafter\readlist\expandafter*\expandafter\prob@list@bgt\expandafter{\total@prob@bgt}%
		\ifnum\prob@list@bgtlen=1%
			% if there is a single probability argument, draw prob branch
			\AtEndEnv@bgt{\noexpand\draw\overlay@bgt[\activecolor@bgt!80!black, fill=\activecolor@bgt] ($(#1.center) + (0, \edge@prob@bgt*\total@prob@bgt)$) -- (#1.center) -- (#2.center) -- ++(0, \edge@prob@bgt*\total@prob@bgt) -- cycle;}%
		\else%
			% draw all the prob branches with \alt
			\pgfmathtruncatemacro{\prob@len}{(\prob@list@bgtlen-1)/2}%
			\foreach \p@bgt in {1, ..., \prob@len}{%
				\edef\prob@overlay@bgt{<\prob@list@bgt[\numexpr2*\p@bgt\relax]>}%
				\itemtomacro\prob@list@bgt[\numexpr2*\p@bgt+1\relax]\prob@val@bgt%
				\AtEndEnv@bgt{\noexpand\visible\overlay@bgt{\noexpand\draw\prob@overlay@bgt[\activecolor@bgt!80!black, fill=\activecolor@bgt] ($(#1.center) + (0, \edge@prob@bgt*\prob@val@bgt)$) -- (#1.center) -- (#2.center) -- ++(0, \edge@prob@bgt*\prob@val@bgt) -- cycle;}}%
			}%
		\fi%
	\else%
		% draw a regular or highlighted branch
		\ifedge@etc@bgt%
			\pgfpointdiff{\pgfpointanchor{#1}{center}}{\pgfpointanchor{#2}{center}}%
			% divide and multiply by 100 to prevent overflow
			\pgfmathsetmacro{\dist@bgt}{100*sqrt((\pgf@x/100)^2+(\pgf@y/100)^2)}% removed \fpeval
			\pgfmathtruncatemacro{\centdist@bgt}{0.55*\dist@bgt/3+2};
			\pgfmathsetmacro{\endratio@bgt}{(1-\centdist@bgt*3/\dist@bgt)/2};
			\ifnum\branchopt@bgtlen>1%
				\edef\branch@overlay@bgt{<\branchopt@bgt[2]>}%
				\expandafter\alt\branch@overlay@bgt{%
					\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (#1) -- ($(#1)!\endratio@bgt!(#2)$);%
					\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt, dashed] ($(#1)!\endratio@bgt!(#2)$) -- ($(#2)!\endratio@bgt!(#1)$);%
					\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] ($(#2)!\endratio@bgt!(#1)$) -- (#2);%
				}{%
					\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- ($(#1)!\endratio@bgt!(#2)$);%
					\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt, dashed] ($(#1)!\endratio@bgt!(#2)$) -- ($(#2)!\endratio@bgt!(#1)$);%
					\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] ($(#2)!\endratio@bgt!(#1)$) -- (#2);%
				}%
			\else%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- ($(#1)!\endratio@bgt!(#2)$);%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt, dashed] ($(#1)!\endratio@bgt!(#2)$) -- ($(#2)!\endratio@bgt!(#1)$);%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] ($(#2)!\endratio@bgt!(#1)$) -- (#2);%
			\fi%
		\else\ifedge@open@bgt%
			\ifnum\branchopt@bgtlen>1%
				\edef\branch@overlay@bgt{<\branchopt@bgt[2]>}%
				\expandafter\alt\branch@overlay@bgt{%
					\iftree@path@arrow@bgt
						\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt, -latex] (#1) -- ($(#1)!0.525!(#2)$) ($(#1)!0.595!(#2)$) -- ($(#1)!0.74!(#2)$) ($(#1)!0.81!(#2)$) -- ($(#1)!0.89!(#2)$) ($(#1)!0.96!(#2)$) -- (#2);%
					\else
						\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (#1) -- ($(#1)!0.525!(#2)$) ($(#1)!0.595!(#2)$) -- ($(#1)!0.74!(#2)$) ($(#1)!0.81!(#2)$) -- ($(#1)!0.89!(#2)$) ($(#1)!0.96!(#2)$) -- (#2);%
					\fi
				}{%
					\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- ($(#1)!0.525!(#2)$) ($(#1)!0.595!(#2)$) -- ($(#1)!0.74!(#2)$) ($(#1)!0.81!(#2)$) -- ($(#1)!0.89!(#2)$) ($(#1)!0.96!(#2)$) -- (#2);%
				}%
			\else%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- ($(#1)!0.525!(#2)$) ($(#1)!0.595!(#2)$) -- ($(#1)!0.74!(#2)$) ($(#1)!0.81!(#2)$) -- ($(#1)!0.89!(#2)$) ($(#1)!0.96!(#2)$) -- (#2);%
			\fi%
		\else
			\ifnum\branchopt@bgtlen>1%
				\edef\branch@overlay@bgt{<\branchopt@bgt[2]>}%
				\expandafter\alt\branch@overlay@bgt{%
					\iftree@path@arrow@bgt
						\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt, -latex] (#1) -- (#2);%
					\else
						\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (#1) -- (#2);%
					\fi
				}{%
					\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- (#2);%
				}%
			\else%
				\expandafter\draw\overlay@bgt[line width=\edge@linewidth@bgt, edge@color@bgt] (#1) -- (#2);%
			\fi%
		\fi\fi%
	\fi%
	%
	\ifedge@readarg@bgt
		% place labels if needed
		\ifedge@labels@none@bgt\else
			\itemtomacro\branchopt@bgt[1,1,1]\labeltext@bgt
			\setlength{\templength@bgt}{\dimexpr0.5\edge@linewidth@bgt + \edge@labelsep@bgt\relax}
			\iftree@forcemath@bgt
				\edge@placelabel@bgt{\activecolor@bgt}{#1}{#2}{\pos@bgt}{\edge@labeldir@bgt}{\the\templength@bgt}{$\labeltext@bgt$}{\overlay@bgt}{\edge@labels@overlay@bgt}
			\else
				\edge@placelabel@bgt{\activecolor@bgt}{#1}{#2}{\pos@bgt}{\edge@labeldir@bgt}{\the\templength@bgt}{\labeltext@bgt}{\overlay@bgt}{\edge@labels@overlay@bgt}
			\fi
		\fi
		% terminal payoffs
		\ifnum\terminal@bgt>1
			\iftree@enablestrategies@bgt\addto@terminallist@bgt{#2}\fi
			\iftree@terminal@e@bgt
				\itemtomacro\branchopt@bgt[\branchopt@bgtlen,\labelargs@bgt,2]\payoff@bgt
			\else
				\iftree@terminal@n@bgt
					\edef\payoff@bgt{$\noexpand\apm{\branchopt@bgt[\branchopt@bgtlen,\labelargs@bgt,2]}$}
				\else
					\edef\payoff@bgt{$\noexpand\ap{\branchopt@bgt[\branchopt@bgtlen,\labelargs@bgt,2]}$}
			\fi\fi
					
			\ifstate@delay@bgt\def\temp@a{at (#2)}\else\def\temp@a{(#2) at (#2)}\fi
			\edef\@placeterminal{\noexpand\state@bgt[label color=xg-fg, label=\terminaldir@bgt, }
			\expandafter\expandafter\expandafter\@placeterminal\expandafter\tree@terminal@bgt\expandafter]\expandafter\temp@a\expandafter{\payoff@bgt};
		\fi
	\fi
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	   4.3 Game trees
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Variables for trees
\newif\iftree@defineroot@bgt
\newif\iftree@computeparent@bgt
\newif\iflabel@dirprovided@bgt
\newcounter{tree@children@bgt}
%
% Two-layer keys for nodes and labels defined manually because they are singular/plural at branch/tree level
\newif\iftree@nodes@rim@def
\newif\iftree@nodes@rim@bgt
\newif\iftree@nodes@empty@def
\newif\iftree@nodes@empty@bgt
\newif\iftree@nodes@naked@def
\newif\iftree@nodes@naked@bgt
\newif\iftree@resetlabels@bgt
\newif\ifinform@labelsuppress@bgt
\def\tree@label@def{}
\def\tree@label@bgt{}
%
\define@key{tree@def}{labels}{%
	\setsepchar{<||>}%
	\readlist*\tree@labels@input@bgt{#1}%
	\ifnum\tree@labels@input@bgtlen=1%
		\def\tree@label@overlay@def{}%
		\let\edge@labels@overlay@def\tree@label@overlay@def%
		\let\inform@label@overlay@def\tree@label@overlay@def%
		\def\tree@labels@in@bgt{#1}%
	\else%
		\edef\tree@label@overlay@def{<\tree@labels@input@bgt[2]>}%
		\let\edge@labels@overlay@def\tree@label@overlay@def%
		\let\inform@label@overlay@def\tree@label@overlay@def%
		\itemtomacro\tree@labels@input@bgt[3]\tree@labels@in@bgt%
	\fi%
	\ifstreq@bgt{\tree@labels@in@bgt}{short}{%
		\tree@labels@short@deftrue%
		\def\tree@label@def{}%
	}{%
		\ifstreq@bgt{\tree@labels@in@bgt}{none}{%
			\def\tree@label@def{none}%
			\inform@labelsuppress@bgttrue%
			\append@key@bgt{\tree@inform@def}{label=none}%
			% set edge labels switch to none
			\edge@labels@none@deftrue
			\edge@labels@inside@deffalse
			\tree@resetlabels@bgttrue%
		}{
			\ifstreq@bgt{\tree@labels@in@bgt}{long}{%%
				% long
				\tree@labels@short@deffalse%
				\def\tree@label@def{}%
			}{}
}}}
\define@key{tree@def}{node labels}{%
	\setsepchar{<||>}%
	\readlist*\tree@node@input@def{#1}%
	\ifnum\tree@node@input@deflen=1%
		\def\tree@label@overlay@def{}%
		\def\inform@label@overlay@def{}%
		\def\tree@node@in@def{#1}%
	\else%
		\edef\tree@label@overlay@def{<\tree@node@input@def[2]>}%
		\let\inform@label@overlay@def\tree@label@overlay@def%
		\itemtomacro\tree@node@input@def[3]\tree@node@in@def%
	\fi%
	\ifstreq@bgt{\tree@node@in@def}{short}{%
		\tree@labels@short@deftrue%
		\def\tree@label@def{}%
	}{%
		\ifstreq@bgt{\tree@node@in@def}{none}{%
			\def\tree@label@def{none}%
			\def\tree@inform@def{}%
		}{%
			\ifstreq@bgt{\tree@node@in@def}{long}{%
				% long
				\tree@labels@short@deffalse%
				\def\tree@label@def{}%
			}{}
}}}
\define@key{tree@def}{nodes}{%
	\setsepchar{<||>}%
	\readlist*\tree@nodes@input@bgt{#1}%
	\ifnum\tree@nodes@input@bgtlen=1%
		\def\tree@node@overlay@def{}%
		\def\tree@nodes@in@bgt{#1}%
	\else%
		\edef\tree@node@overlay@def{<\tree@nodes@input@bgt[2]>}%
		\itemtomacro\tree@nodes@input@bgt[3]\tree@nodes@in@bgt%
	\fi%
	\ifstreq@bgt{\tree@nodes@in@bgt}{empty}{%
		\tree@nodes@empty@deftrue%
		\tree@nodes@rim@deffalse%
		\tree@nodes@naked@deffalse%
		\def\tree@label@def{}%
	}{%
		\ifstreq@bgt{\tree@nodes@in@bgt}{hollow}{%
			\tree@nodes@empty@deftrue%
			\tree@nodes@rim@deftrue%
			\tree@nodes@naked@deffalse%
			\def\tree@label@def{}%
		}{%
			\ifstreq@bgt{\tree@nodes@in@bgt}{naked}{%
				\tree@nodes@empty@deftrue%
%				\tree@nodes@rim@deffalse%
				\tree@nodes@naked@deftrue%
				\def\tree@inform@def{}
				\ifnum\tree@nodes@input@bgtlen=1%
					\def\tree@label@def{none}%
				\fi%
			}{%
				\tree@nodes@empty@deffalse%
				\tree@nodes@naked@deffalse%
				\def\tree@label@def{}%
%				\def\tree@inform@def{label=center}%
				\ifstreq@bgt{\tree@nodes@in@bgt}{full}{%
					\tree@nodes@rim@deftrue%
				}{%
					\tree@nodes@rim@deffalse%
}}}}}
%
\define@key{tree@bgt}{label}{%
	% allows you to set <tree@label@overlay@bgt>tree@label@bgt:tree@labeltext@bgt
	\setsepchar{<||>/:}%
	\readlist*\tree@label@details@bgt{#1}%
	\ifnum\tree@label@details@bgtlen=1%
		\let\tree@label@overlay@bgt\tree@label@overlay@def%
	\else%
		\edef\tree@label@overlay@bgt{<\tree@label@details@bgt[2]>}%
	\fi%
	\expandafter\ifnum\listlen\tree@label@details@bgt[\tree@label@details@bgtlen]=1%
		\itemtomacro\tree@label@details@bgt[\tree@label@details@bgtlen]\tree@label@in@bgt%
		\ifstreq@bgt{\tree@label@in@bgt}{short}{\tree@labels@short@bgttrue\def\tree@label@bgt{}}{%
			\ifstreq@bgt{\tree@label@in@bgt}{long}{\tree@labels@short@bgtfalse\def\tree@label@bgt{}}{%
				\ifstreq@bgt{\tree@label@in@bgt}{}{}{%
				\def\tree@label@bgt{#1}%
				\label@dirprovided@bgttrue%
		}}}%
	\else%
		\itemtomacro\tree@label@details@bgt[1,1]\tree@label@bgt%
		\itemtomacro\tree@label@details@bgt[1,2]\tree@labeltext@bgt%
		\label@dirprovided@bgttrue%
	\fi%
}
%
\define@key{tree@bgt}{label text}{\def\tree@labeltext@bgt{#1}\ifstreq@bgt{\tree@label@bgt}{none}{\def\tree@label@bgt{}}}%
\define@key{tree@bgt}{node}{%
	\setsepchar{<||>}%
	\readlist*\tree@node@input@bgt{#1}%
	\ifnum\tree@node@input@bgtlen=1%
		\let\tree@node@overlay@bgt\tree@node@overlay@def%
		\def\tree@node@in@bgt{#1}%
	\else%
		\edef\tree@node@overlay@bgt{<\tree@node@input@bgt[2]>}%
		\itemtomacro\tree@node@input@bgt[3]\tree@node@in@bgt%
	\fi%
	\ifstreq@bgt{\tree@node@in@bgt}{empty}{%
		\tree@nodes@empty@bgttrue%
		\tree@nodes@rim@bgtfalse%
		\tree@nodes@naked@bgtfalse%
		\def\tree@label@bgt{}%
	}{%
		\ifstreq@bgt{\tree@node@in@bgt}{hollow}{%
			\tree@nodes@empty@bgttrue%
			\tree@nodes@rim@bgttrue%
			\tree@nodes@naked@bgtfalse%
			\def\tree@label@bgt{}%
		}{
			\ifstreq@bgt{\tree@node@in@bgt}{naked}{%
				\tree@nodes@empty@bgttrue%
%				\tree@nodes@rim@bgtfalse%
				\tree@nodes@naked@bgttrue%
				\ifnum\tree@node@input@bgtlen=1%
					\def\tree@label@bgt{none}%
				\fi%
			}{%
				\tree@nodes@empty@bgtfalse%
				\tree@nodes@naked@bgtfalse%
				\def\tree@label@bgt{}%
				\ifstreq@bgt{\tree@node@in@bgt}{full}{%
					\tree@nodes@rim@bgttrue%
				}{
					\tree@nodes@rim@bgtfalse%
}}}}}%
%
\def\tree@setnodesandlabelstodefault@bgt{%
	\iftree@sticky@bgt\else%
		% labels
		\iflabel@dirprovided@bgt\else%
			\let\tree@label@bgt\tree@label@def%
		\fi%
		% nodes
		\setiftodefault@bgt{tree@nodes@empty}%
		\setiftodefault@bgt{tree@nodes@rim}%
		\setiftodefault@bgt{tree@nodes@naked}%
		\setiftodefault@bgt{tree@labels@short}%
		% getting rid of contour
		\def\tree@node@bgt{font=\tree@font@bgt}%
	\fi%
}
\def\tree@label@overlay@def{}
\def\tree@node@overlay@def{}
\def\tree@terminal@def{}
\def\tree@terminal@bgt{}
%
% Two-layer keys of trees
\define@bgt@family{tree}{
	offset, {0,0};
	alt,
}{}{}{
	force math, false;
	vertical, true;
	root empty, false;
	enable strategies, true;
	very sticky, false
}{
%	nodes, full:empty:naked;
%	labels, long:short:none;
	index, number:action;
	path, line:arrow;
	terminal, p:n:e
}{}{
	label sep -> edge, node, terminal;
	node label sep -> node:label sep;
	terminal label sep -> terminal:label sep;
	edge label sep -> edge:label sep;
	node radius -> node:radius;
	terminal radius -> terminal:radius;
	edge labels -> edge:labels;
	node label placement -> node:label placement; % does this work?
	edge label placement -> edge:label placement; % or is the pass-through only for simple assignment options?
%	font -> node, terminal, edge, inform;
	payoffs -> edge;
	debug:true -> edge, node, terminal, inform, subgame;
	delay contour:true -> edge, node, inform;
	line width -> edge, node, terminal, inform;
	alert width -> edge
}{
	\select@activeplayer@bgt
	\state@debug@bgtfalse
	\let\tree@terminal@bgt\tree@terminal@def
	\label@dirprovided@bgtfalse%
	\terminal@dirprovided@bgtfalse%
	% overlays from branches etc
	\let\tree@label@overlay@bgt\tree@label@overlay@def%
	\let\tree@node@overlay@bgt\tree@node@overlay@def%
	% node and labels
	\iftree@resetlabels@bgt\tree@setnodesandlabelstodefault@bgt\fi
}
% only for reference in subgames
\let\tree@font@bgt\labelfontsize
% two levels of sticky
\define@key{tree@bgt}{very sticky}[true]{\ifstreq@bgt{#1}{true}{\tree@verysticky@bgttrue\tree@sticky@bgttrue}{\ifstreq@bgt{#1}{false}{\tree@verysticky@bgtfalse}{}}}
\define@key{tree@bgt}{sticky}[true]{\ifstreq@bgt{#1}{true}{\tree@sticky@bgttrue}{\ifstreq@bgt{#1}{false}{\tree@verysticky@bgtfalse\tree@sticky@bgtfalse}{}}}
\define@key{tree@def}{very sticky}[true]{\ifstreq@bgt{#1}{true}{\tree@verysticky@deftrue\tree@sticky@deftrue}{\ifstreq@bgt{#1}{false}{\tree@verysticky@deffalse}{}}}
\define@key{tree@def}{sticky}[true]{\ifstreq@bgt{#1}{true}{\tree@sticky@deftrue}{\ifstreq@bgt{#1}{false}{\tree@verysticky@deffalse\tree@sticky@deffalse}{}}}
%
% Change default to no parentheses
\tree@terminal@n@deftrue
\def\tree@terminal@def{label sep=0.7ex}
\define@key{tree@def}{font}{\let\tree@font@def#1\append@key@bgt{\tree@inform@def}{font=#1}\append@key@bgt{\tree@node@def}{font=#1}\append@key@bgt{\tree@edge@def}{font=#1}\append@key@bgt{\tree@terminal@def}{font=#1}}
\define@key{tree@bgt}{font}{\let\tree@font@bgt#1\append@key@bgt{\tree@node@bgt}{font=#1}\append@key@bgt{\tree@edge@bgt}{font=#1}\append@key@bgt{\tree@terminal@bgt}{font=#1}}
%
% Complementary keys
\define@key{tree@bgt}{horizontal}[true]{\ifstreq@bgt{#1}{true}{\tree@vertical@bgtfalse}{\tree@vertical@bgttrue}}
\define@key{tree@def}{horizontal}[true]{\ifstreq@bgt{#1}{true}{\tree@vertical@deffalse}{\tree@vertical@deftrue}}
%
% Environment-only keys
\define@key{tree@def}{tikz nodes}[true]{\ifstreq@bgt{#1}{true}{\state@delay@deffalse}{\state@delay@deftrue}}
%\def\tree@name@def{gt}
%\define@key{tree@def}{name}{\def\tree@name@def{#1}}
\define@key{tree@def}{player names}{%
	\setplayernames{#1}%
	% the following two lines correspond to labels=long
	\tree@labels@short@deffalse%
	\def\tree@label@def{}%
}
\define@key@scale{tree}
%
% Externalize
\newif\iftree@externalize@def
\def\tree@external@def{}
\define@key{tree@def}{external}{\def\tree@external@def{#1}\tree@externalize@deftrue}
%
% Branch-only keys
\def\tree@root@bgt{gt}
\define@key{tree@bgt}{root}{\def\tree@root@bgt{#1}\tree@defineroot@bgttrue}
\define@key{tree@bgt}{contour}[true]{\append@key@bgt{\tree@node@bgt}{contour=#1}}
%\define@key{tree@bgt}{contour}[true]{\ifstreq@bgt{#1}{true}{\state@contour@bgttrue}{\ifstreq@bgt{#1}{delay}{\state@contour@bgttrue\state@delaycontour@bgttrue}{\state@contour@bgtfalse\state@delaycontour@bgtfalse}}}
\define@key{tree@bgt}{player}{%
	\setcounter{activeplayer@bgt}{#1}%
	\inform@selectplayer@bgt%
	\iftree@verysticky@bgt\else%
		\iftree@sticky@bgt%
			\tree@sticky@bgtfalse%
			\tree@setnodesandlabelstodefault@bgt%
			\tree@sticky@bgttrue%
		\else%
			\tree@setnodesandlabelstodefault@bgt%
	\fi\fi%
}
\define@key{tree@bgt}{prob}{\def\total@prob@bgt{#1}\prob@branch@bgttrue}
%
% Information sets
\define@key{tree@def}{inform}{\append@key@bgt{\tree@inform@def}{#1}}
\define@key{tree@def}{inform radius}{\def\tree@informradius@def{#1}}
\define@key{tree@def}{edge}{\append@key@bgt{\tree@edge@def}{#1}}
\def\tree@strategy@def{}
\define@key{tree@def}{strategy}{\append@key@bgt{\tree@strategy@def}{#1}}
\def\tree@subgame@def{}
\define@key{tree@def}{subgame}{\append@key@bgt{\tree@subgame@def}{#1}}
%
% default values
\def\tree@inform@def{label=center}
\@ifclassloaded{beamer}{
	\def\tree@node@def{label sep=0.8ex}
	\def\tree@informradius@def{2.4mm}
	\def\tree@edgelabelsep@def{1.5pt}
}{
	\def\tree@node@def{label sep=1ex}
	\def\tree@informradius@def{2.8mm}
}
%
% Sticky keys
\define@key{tree@def}{edge label placement}{\ifstreq@bgt{#1}{simple}{\edge@labelplacement@simple@deftrue\edge@labelplacement@box@deffalse}{\edge@labelplacement@simple@deffalse\ifstreq@bgt{#1}{box}{\edge@labelplacement@box@deftrue}{\edge@labelplacement@box@deffalse}}}
\define@key{tree@def}{node label placement}{\ifstreq@bgt{#1}{simple}{\state@labelplacement@simple@deftrue\state@labelplacement@box@deffalse}{\state@labelplacement@simple@deffalse\ifstreq@bgt{#1}{box}{\state@labelplacement@box@deftrue}{\state@labelplacement@box@deffalse}}}
%
\def\parseoffset@bgt#1,#2;{\def\tree@x@offset@bgt{#1}\def\tree@y@offset@bgt{#2}}% BB1
\newif\ifnextcontour@bgt
%
\def\branch@opt#1from#2to#3;{%
% #1: simply gobbles a space
% #2: coordinate of parent
% #3: optional argument for edges as well as children
	\tree@defineroot@bgtfalse%
	\edge@definesarc@bgtfalse%
	\prob@branch@bgtfalse%
	\def\tree@labeltext@bgt{\activename@bgt}%
	\iftree@sticky@bgt\else%
		\label@dirprovided@bgtfalse%
		\terminal@dirprovided@bgtfalse%
	\fi%
	% process options
	\expandafter\treesetoptions@bgt\expandafter{\option@bgt}%
	% read parent and ensure that (\tree@root@bgt) is defined
	\setsepchar{(||)/$} %$%
	\readlist*\parentinput@bgt{#2}%
	\pgfmathtruncatemacro{\computeparent@bgt}{\listlen\parentinput@bgt[2]}%
	\ifnum\computeparent@bgt>1\relax%
		% this way of parsing seems complicated, but guarantees that both (a) nodes with explicit computation and (b) computations arising in a \foreach construct are handled correctly
		\setsepchar{$} %$%
		\readlist*\parsecoord@bgt{#2}%
		\itemtomacro\parsecoord@bgt[2]\parent@bgt%
		% Computation of node allowed only with root option (to ensure counter of children works correctly)
		\coordinate (\tree@root@bgt) at ($\parent@bgt$);%
		\global\let\parent@bgt\tree@root@bgt
	\else%
		\itemtomacro\parentinput@bgt[2]\parent@bgt%
		\iftree@defineroot@bgt%
			\coordinate (\tree@root@bgt) at (\parent@bgt);%
			\global\let\parent@bgt\tree@root@bgt%
	\fi\fi%
	% Reset counter for number of children
	\iftree@defineroot@bgt%
		\setcounter{tree@children@bgt}{0}%
		\iftree@rootempty@bgt%
			\tree@nodes@empty@bgttrue%
		\fi%
	\else%
		\ifx\parent@bgt\last@parent@bgt%
			\relax%
		\else%
			\setcounter{tree@children@bgt}{0}%
	\fi\fi%
	% add to coordinate list in a game tree
	\iftree@enablestrategies@bgt
		\ifwithin@beliefspace@bgt\else
			\expandafter\addto@coordlist@bgt\expandafter{\parent@bgt}
			\expandafter\xdef\csname strat@overlay@\parent@bgt @bgt\endcsname{\overlay@bgt}
	\fi\fi
	% if this is not the first brach from this parent, suppress the label
	\ifcontainedinlist@bgt
		\def\tree@label@bgt{none}
	\fi
	% read children
	\setsepchar{[||]/;}%
	\readlist*\childlist@bgt{#3}%
	\pgfmathtruncatemacro{\numchildren@bgt}{\listlen\childlist@bgt[\childlist@bgtlen]}%
	\ifnum\childlist@bgtlen>1%
		\itemtomacro\childlist@bgt[2]\childoptions@bgt%
		\expandafter\expandafter\expandafter\edgesetoptions@bgt\expandafter\expandafter\expandafter{\expandafter\tree@edge@bgt\expandafter,\childoptions@bgt}%
	\else
		\expandafter\edgesetoptions@bgt\expandafter{\tree@edge@bgt}%
	\fi%
	% continuous branch
	\ifedge@definesarc@bgt%
		\edge@contour@bgttrue%
		% draw arc
		\setsepchar{:}%
		\expandafter\readlist\expandafter*\expandafter\arcspec@bgt\expandafter{\edge@arc@bgt}%
		\itemtomacro\arcspec@bgt[3]\arclen@bgt%
		\expandafter\fill\overlay@bgt[edge@arccolor@bgt] (\parent@bgt) -- ++(\arcspec@bgt[1]:\arclen@bgt) arc(\edge@arc@bgt) -- cycle;%
		% iterate over list of children
		\foreach \i@bgt in {1, ..., \numchildren@bgt}{%
			\itemtomacro\childlist@bgt[\childlist@bgtlen,\i@bgt]\childdetails@bgt%
			\setsepchar{:/<||>/[||]/(||)}%
			\readlist*\details@bgt{\childdetails@bgt}%
			% define label \thischild@bgt
			\iftree@index@action@bgt%
				\def\thischild@bgt{\parent@bgt\details@bgt[\details@bgtlen,1,1,1]}%
			\else%
				\pgfmathtruncatemacro{\j@bgt}{\i@bgt + \value{tree@children@bgt}}%
				\edef\thischild@bgt{\parent@bgt\j@bgt}%
			\fi%
			% find coordinate of (\thischild@bgt)
			\ifnum\details@bgtlen>2%
				\coordinate (\thischild@bgt) at ($(\parent@bgt) + (\details@bgt[1]:\details@bgt[2])$);%
				\itemtomacro\details@bgt[3]\childdetails@bgt%
			\else%
				\coordinate (\thischild@bgt) at ($(\parent@bgt) + (\details@bgt[1]:\arclen@bgt)$);%
				\itemtomacro\details@bgt[2]\childdetails@bgt%
			\fi%
			% draw individual branches
			\drawbranch@bgt{\parent@bgt}{\thischild@bgt}{\childdetails@bgt}%
		}%
	\else%
		\def\def@coord@bgt{\coordinate (\thischild@bgt) at (}
		% iterate over list of children
		\ifnum\numchildren@bgt=1\relax%
			\itemtomacro\childlist@bgt[\childlist@bgtlen,1]\childdetails@bgt%
			\iftree@index@action@bgt%
				\setsepchar{<||>/[||]/(||)}%
				\readlist*\details@bgt{\childdetails@bgt}%
				\edef\thischild@bgt{\parent@bgt\details@bgt[1,1,1]}%
			\else%
				\pgfmathtruncatemacro{\j@bgt}{1 + \value{tree@children@bgt}}%
				\edef\thischild@bgt{\parent@bgt\j@bgt}%
			\fi%
			\expandafter\def@coord@bgt\expandafter$(\parent@bgt) + (\tree@offset@bgt) + (\edge@h@bgt, \edge@v@bgt)$);%
			\drawbranch@bgt{\parent@bgt}{\thischild@bgt}{\childdetails@bgt}%
		\else%
			\setsepchar{,}%
			\readlist*\hsteplist@bgt{\edge@h@bgt}%
			\readlist*\vsteplist@bgt{\edge@v@bgt}%
			% find offset
			\iftree@vertical@bgt%
				\pgfmathsetmacro{\totalwidth@bgt}{0}%
				\foreach \i@bgt in {2, ..., \numchildren@bgt}{%
					\pgfmathtruncatemacro{\temp@bgt}{Mod(\i@bgt-1,\hsteplist@bgtlen)+1}%
					\pgfmathsetmacro{\totalwidth@bgt}{\totalwidth@bgt + \hsteplist@bgt[\temp@bgt]}%
					\global\let\totalwidth@bgt=\totalwidth@bgt%
				}%
			\else%
				\pgfmathsetmacro{\totalheight@bgt}{0}%
				\foreach \i@bgt in {2, ..., \numchildren@bgt}{%
					\pgfmathtruncatemacro{\temp@bgt}{Mod(\i@bgt-1,\vsteplist@bgtlen)+1}%
					\pgfmathsetmacro{\totalheight@bgt}{\totalheight@bgt + \vsteplist@bgt[\temp@bgt]}%
					\global\let\totalheight@bgt=\totalheight@bgt%
				}%
			\fi%
			% parse individual branches
			\pgfmathsetmacro{\totalstep@bgt}{0}%
			\foreach \i@bgt in {1, ..., \numchildren@bgt}{%
				\itemtomacro\childlist@bgt[\childlist@bgtlen,\i@bgt]\childdetails@bgt%
				% define label \thischild@bgt
				\iftree@index@action@bgt%
					\setsepchar{<||>/[||]/(||)}%
					\readlist*\details@bgt{\childdetails@bgt}%
					\edef\thischild@bgt{\parent@bgt\details@bgt[1,1,1]}%
				\else%
					\pgfmathtruncatemacro{\j@bgt}{\i@bgt + \value{tree@children@bgt}}
					\edef\thischild@bgt{\parent@bgt\j@bgt}
				\fi%
				% find coordinate of (\thischild@bgt)
				\pgfmathtruncatemacro{\htemp@bgt}{Mod(\i@bgt-1,\hsteplist@bgtlen)+1}%
				\pgfmathtruncatemacro{\vtemp@bgt}{Mod(\i@bgt-1,\vsteplist@bgtlen)+1}%
				\iftree@vertical@bgt%
					\expandafter\def@coord@bgt\expandafter$(\parent@bgt) + (\tree@offset@bgt) - 0.5*(\totalwidth@bgt, 0) + (\totalstep@bgt, -\vsteplist@bgt[\vtemp@bgt])$);%
					\pgfmathsetmacro{\totalstep@bgt}{\totalstep@bgt + \hsteplist@bgt[\htemp@bgt]}%
				\else%
					\expandafter\def@coord@bgt\expandafter$(\parent@bgt) + (\tree@offset@bgt) + 0.5*(0, \totalheight@bgt) + (\hsteplist@bgt[\htemp@bgt], -\totalstep@bgt)$);%
					\pgfmathsetmacro{\totalstep@bgt}{\totalstep@bgt + \vsteplist@bgt[\vtemp@bgt]}%
				\fi
				% draw individual branches
				\drawbranch@bgt{\parent@bgt}{\thischild@bgt}{\childdetails@bgt}%
				\global\let\totalstep@bgt=\totalstep@bgt%
			}%
	\fi\fi%
	% parent
	\iftree@nodes@empty@bgt%
		\def\parent@fillcolor@bgt{xg-bg}%
	\else%
		\let\parent@fillcolor@bgt\activefillnode@bgt%
	\fi%
	\iftree@nodes@rim@bgt%
		\let\parent@rimcolor@bgt\activecolor@bgt%
	\else%
		\def\parent@rimcolor@bgt{xg-fg}%
	\fi%
	\ifstreq@bgt{\tree@label@bgt}{none}{%
		\def\temp{\state@bgt[line color=\parent@rimcolor@bgt, fill=\parent@fillcolor@bgt,}% overlay is processed in state@bgt
		\expandafter\temp\tree@node@bgt] (\parent@bgt) at (\parent@bgt) {};%
	}{%
		\iflabel@dirprovided@bgt\else%
			\let\tree@label@bgt\labeldir@bgt%
		\fi%
		\ifnextcontour@bgt
			\def\temp{\state@bgt[line color=\parent@rimcolor@bgt, fill=\parent@fillcolor@bgt, label=\tree@label@bgt, contour,}
			\nextcontour@bgtfalse
		\else
			\def\temp{\state@bgt[line color=\parent@rimcolor@bgt, fill=\parent@fillcolor@bgt, label=\tree@label@bgt,}
		\fi
		\ifstate@delay@bgt%
			\def\temptwo{\expandafter\temp\tree@node@bgt] at (\parent@bgt) }%
		\else%
			\def\temptwo{\expandafter\temp\tree@node@bgt] (\parent@bgt) at (\parent@bgt) }%
		\fi%
		\expandafter\alt\tree@node@overlay@bgt{%
			\expandafter\temptwo\tree@label@overlay@bgt{\iftree@nodes@naked@bgt\else\tree@labeltext@bgt\fi};
		}{%
			\let\parent@fillcolor@bgt\activefillnode@bgt%
			\expandafter\temptwo\tree@label@overlay@bgt{\tree@labeltext@bgt};%
		}%
	}%
	\ifstreq@bgt{\tree@alt@bgt}{}{}{
		\ifstreq@bgt{\tree@alt@bgt}{()}{
			\def\@placeterminal{\state[label color=xg-fg, }
			\expandafter\alt\overlay@bgt{}{\expandafter\@placeterminal\tree@terminal@bgt] at (\parent@bgt) {};}
		}{
			\setsepchar{(||)}
			\expandafter\readlist\expandafter*\expandafter\tree@alt@input@bgt\expandafter{\tree@alt@bgt}
		
			\iftree@terminal@e@bgt
				\itemtomacro\tree@alt@input@bgt[2]\payoff@bgt
			\else
				\iftree@terminal@n@bgt
					\edef\payoff@bgt{$\noexpand\apm{\tree@alt@input@bgt[2]}$}
				\else
					\edef\payoff@bgt{$\noexpand\ap{\tree@alt@input@bgt[2]}$}
			\fi\fi
				
			\ifstate@delay@bgt\def\temp@a{at (\parent@bgt)}\else\def\temp@a{(\parent@bgt) at (\parent@bgt)}\fi
			\edef\@placeterminal{\noexpand\state[label color=xg-fg, label=\terminaldir@bgt, }
			\expandafter\alt\overlay@bgt{}{\expandafter\expandafter\expandafter\@placeterminal\expandafter\tree@terminal@bgt\expandafter]\expandafter\temp@a\expandafter{\payoff@bgt};}
	}}
	% prepare for future branches
	\ifedge@definesarc@bgt\global\nextcontour@bgttrue\fi
	\let\last@parent@bgt\parent@bgt%
	\addtocounter{tree@children@bgt}{\numchildren@bgt}%
}
\addoptions@bgt{branch}
\addoverlay@bgt{branch}
%
\def\gametree@bgtbegin#1{%
	\treesetoptions{#1}%
	\expandafter\strategysetoptions\expandafter{\tree@strategy@def}%
	\expandafter\subgamesetoptions\expandafter{\tree@subgame@def}%
	\informsetradius{\tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def, \tree@informradius@def}%
	\tree@setnodesandlabelstodefault@bgt%
	\within@tree@bgttrue%
}
\def\gametree@bgtend{%
%	\setcounter{activeplayer@bgt}{0}%
	\within@tree@bgtfalse%
	\ignorespacesafterend
}
\ifexternal@bgt
	\NewEnviron{gametree}[1][]{%
		\gametree@bgtbegin{#1}%
		\iftree@externalize@def%
			\expandafter\externalize\expandafter{\tree@external@def}%
		\fi%
		\begin{tikzpicture}[xscale=\tree@xscale@def, yscale=\tree@yscale@def]
		\BODY
		\end{tikzpicture}%
	}{\gametree@bgtend}
\else
	\newenvironment{gametree}[1][]{%
		\gametree@bgtbegin{#1}%
		\begin{tikzpicture}[xscale=\tree@xscale@def, yscale=\tree@yscale@def]
	}{
		\end{tikzpicture}%
		\gametree@bgtend
	}
\fi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	    4.4 Subgames
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newif\ifsubgame@dirprovided@bgt
\def\sub@lw@bgt{0.6} % used to be 0.5625
\def\sub@rw@bgt{0.6}
%
\define@bgt@family{subgame}{
	lw, 0.6;
	rw, 0.6;
	line, dashed;
	font, \labelfontsize;
	color, xg-fg;
	label, 135;
	dir, -90
}{
	inner sep, 3ex;
	top sep, 3ex;
	label sep, 1ex;
	depth, 2.8ex;
	line width, \edgelinewidth@bgt%0.5pt
}{}{
	bezier, true;
	debug, false
}{}{}{}{%
%	\setbox0=\hbox{\tree@font@bgt A,}%
%	\setlength{\subgame@depth@def}{\dimexpr\ht0+\state@radius@bgt+0.5\state@linewidth@bgt+0.85ex\relax}%
	\iftree@vertical@bgt\def\subgame@dir@bgt{-90}\else\def\subgame@dir@bgt{0}\fi%
}
%
\define@key@thickness@bgt{subgame}
% inner sep sets both inner sep and top sep
\define@key{subgame@def}{inner sep}{\setlength{\subgame@innersep@def}{#1}\setlength{\subgame@topsep@def}{#1}}
\define@key{subgame@bgt}{inner sep}{\setlength{\subgame@innersep@bgt}{#1}\setlength{\subgame@topsep@bgt}{#1}}
%
\define@key{subgame@def}{debug}[true]{\ifstreq@bgt{#1}{false}{\subgame@debug@deffalse}{\subgame@debug@deftrue}}
\define@key{subgame@bgt}{debug}[true]{\ifstreq@bgt{#1}{false}{\subgame@debug@bgtfalse}{\subgame@debug@bgttrue}}
\define@key{subgame@bgt}{dir}{\def\subgame@dir@bgt{#1}\subgame@dirprovided@bgttrue}
\define@key{subgame@bgt}{w}{\setsepchar{,}\readlist*\sub@wlist@bgt{#1}\ifnum\sub@wlist@bgtlen=1\relax\def\subgame@lw@bgt{#1}\def\subgame@rw@bgt{#1}\else\edef\subgame@lw@bgt{\sub@wlist@bgt[1]}\edef\subgame@rw@bgt{\sub@wlist@bgt[2]}\fi}
\define@key{subgame@def}{w}{\setsepchar{,}\readlist*\sub@wlist@def{#1}\ifnum\sub@wlist@deflen=1\relax\def\subgame@lw@def{#1}\def\subgame@rw@def{#1}\else\edef\subgame@lw@def{\sub@wlist@def[1]}\edef\subgame@rw@def{\sub@wlist@def[2]}\fi}
%
\def\addto@kidlist@bgt#1#2{% easy because coordinate names are expandable
	% #1: name of parent
	% #2: name of child
	\ifnum\terminal@bgt>1\relax%
		\edef\sub@append@bgt{#2:\terminaldir@bgt}%
	\else%
		\edef\sub@append@bgt{#2}%
	\fi%
	\@ifundefined{sub@#1@bgt}{\expandafter\xdef\csname sub@#1@bgt\endcsname{\sub@append@bgt}}{%
		\expandafter\xdef\csname sub@#1@bgt\endcsname{\csname sub@#1@bgt\endcsname, \sub@append@bgt}%
	}%
}
%
\def\clear@kidlist@bgt{%
	\@ifundefined{tree@coordlist@bgt}{}{%
		\setsepchar{,||:}%
		\expandafter\readlist\expandafter*\expandafter\sub@nodelist@bgt\expandafter{\tree@coordlist@bgt}%
		\foreachitem \kid@bgt \in \sub@nodelist@bgt {%
			\expandafter\global\expandafter\let\csname sub@\kid@bgt @bgt\endcsname\undefined%
		}%
	}%
}
%
\newif\ifsub@terminate@bgt
\def\subgame@bezier@getleaf@bgt#1#2{
	% #1: apex
	% #2: 'l' or 'r'
	\ifstreq@bgt{#2}{l}{\def\exti@bgt{1}\def\angle@check@bgt{\ifdim\thisangle@bgt pt<\extangle@bgt pt\relax\global\let\extangle@bgt\thisangle@bgt\xdef\exti@bgt{\i@bgt}\fi}}{\def\exti@bgt{\kids@bgtlen}\def\angle@check@bgt{\ifdim\thisangle@bgt pt>\extangle@bgt pt\relax\global\let\extangle@bgt\thisangle@bgt\xdef\exti@bgt{\i@bgt}\fi}}
	% find point in tree
	\sub@terminate@bgtfalse
	\def\curr@coord@bgt{#1}
	\begingroup%
		\pgfmathloop%
		\ifsub@terminate@bgt
		\else%
			\setsepchar{,/:}
			\expandafter\readlist\expandafter*\expandafter\kids@bgt\expandafter{\csname sub@\curr@coord@bgt @bgt\endcsname}
			\def\extangle@bgt{0}
			\foreach \i@bgt in {1, ..., \kids@bgtlen} {
				\pgfextractangle{\beta@bgt}{\curr@coord@bgt}{\kids@bgt[\i@bgt,1]}
				\pgfmathsetmacro{\phaseshift@bgt}{180-\subgame@dir@bgt}
				\pgfmathsetmacro{\thisangle@bgt}{mod(\beta@bgt+\phaseshift@bgt, 360)-\phaseshift@bgt-\subgame@dir@bgt}
				\angle@check@bgt
			}
			\xdef\curr@coord@bgt{\kids@bgt[\exti@bgt,1]}
			\@ifundefined{sub@\curr@coord@bgt @bgt}{% search terminates
				\global\sub@terminate@bgttrue
				\expandafter\xdef\csname sub@#2tdir@bgt\endcsname{\kids@bgt[\exti@bgt,2]}
			}{}%
		\repeatpgfmathloop%
	\endgroup%
	\expandafter\global\expandafter\let\csname sub@#2@bgt\endcsname\curr@coord@bgt%
}
%
\def\subgame@bezier@tangentialangle@bgt#1#2{%
	% #1: apex
	% #2: 'l' or 'r'
	% (A@bgt), \angle@bgt, \sub@l@bgt, and \sub@r@bgt have been defined already
	% Parametrize \sub@#1#@bgt in direction of \angle@bgt as (+-x, -y)
	\pgfextractangle{\alpha@bgt}{#1}{\csname sub@#2@bgt\endcsname}
	\tikz@scan@one@point\pgfutil@firstofone($(\csname sub@#2@bgt\endcsname)-(#1)$)\relax
	\pgfmathsetmacro{\sub@dist@bgt}{100*sqrt((\the\pgf@x/100)^2 + (\the\pgf@y/100)^2)}
	\pgfmathsetmacro{\sub@x@bgt}{abs(sin(180-abs(\angle@bgt-\alpha@bgt)))*\sub@dist@bgt}
	\pgfmathsetmacro{\sub@y@bgt}{abs(cos(180-abs(\angle@bgt-\alpha@bgt)))*\sub@dist@bgt}
	% Approximate tangential angle using \sqrt(x(x-1)} ~= x - 0.5
	\pgfmathsetmacro{\sub@a@bgt}{(\sub@x@bgt + \subgame@innersep@bgt)*(1 - \csname subgame@#2w@bgt\endcsname)}
	\pgfmathsetmacro{\sub@b@bgt}{\sub@y@bgt + \subgame@innersep@bgt}
	\pgfmathsetmacro{\sub@c@bgt}{\csname subgame@#2w@bgt\endcsname*\subgame@innersep@bgt - 0.5*\sub@x@bgt*(1 - \csname subgame@#2w@bgt\endcsname)}
	\pgfmathsetmacro{\sub@sec@bgt}{0.5*(100*sqrt((\sub@b@bgt/100)^2-4/10000*\sub@a@bgt*\sub@c@bgt)+\sub@b@bgt)/\sub@a@bgt}
	\ifdim\sub@sec@bgt pt<1pt
		\PackageWarning{xgames}{approximation of tangential angle of subgame inaccurate}
		\expandafter\gdef\csname#2@alpha@bgt\endcsname{1}
	\else
		\pgfmathparse{acos(1/\sub@sec@bgt)}
		\expandafter\global\expandafter\let\csname#2@alpha@bgt\endcsname\pgfmathresult
	\fi
}
%
\newif\ifsub@error@bgt
\def\subgame@bezier@bgt#1#2{%
	% #1 : apex
	% #2 : label
	% check whether the coordinate is a terminal node
	\sub@error@bgtfalse
	\foreach \coord@bgt in \tree@terminallist@bgt {
		\ifstreq@bgt{\coord@bgt}{#1}{\global\sub@error@bgttrue}{}
	}
	\ifsub@error@bgt
		\PackageError{xgames}{Subgame cannot start at a terminal node}{}
	\else
		% find points in tree
		\subgame@bezier@getleaf@bgt{#1}{l}
		\subgame@bezier@getleaf@bgt{#1}{r}
		% make sure that the angles satisfy: rtdir < angle < ltdir
		\ifdim\sub@rtdir@bgt pt<\sub@ltdir@bgt pt\else
			\pgfmathsetmacro{\sub@ltdir@bgt}{\sub@ltdir@bgt+360}
		\fi
		\ifsubgame@dirprovided@bgt
			\pgfmathsetmacro{\angle@bgt}{\subgame@dir@bgt+180}
			\ifdim\angle@bgt pt<\sub@ltdir@bgt pt\else
				\pgfmathsetmacro{\angle@bgt}{\subgame@dir@bgt-180}
			\fi
		\else
%			\pgfmathsetmacro{\angle@bgt}{0.5*(\sub@ltdir@bgt+\sub@rtdir@bgt)}
			\pgfextractangle{\l@beta@bgt}{#1}{\sub@l@bgt}
			\pgfextractangle{\r@beta@bgt}{#1}{\sub@r@bgt}
			\ifdim\r@beta@bgt pt<\l@beta@bgt pt\else
				\pgfmathsetmacro{\r@beta@bgt}{\r@beta@bgt-360}
			\fi
			\pgfmathsetmacro{\angle@bgt}{0.25*(\sub@ltdir@bgt+\sub@rtdir@bgt+\l@beta@bgt+\r@beta@bgt)}
		\fi
		% get scale factors and define apex
		\getscale@bgt
		\coordinate (A@bgt) at ($(#1)+(\angle@bgt:\invx@bgt\subgame@topsep@bgt\space and \invy@bgt\subgame@topsep@bgt)$);
		\foreach \i@bgt in {l, r} {
			% find approximate tangential angle and define point
			\subgame@bezier@tangentialangle@bgt{#1}{\i@bgt}
			\ifstreq@bgt{\i@bgt}{l}{\def\pm@bgt{+}}{\def\pm@bgt{-}}
			\coordinate (\i@bgt @bgt) at ($(\csname sub@\i@bgt @bgt\endcsname)+(\angle@bgt\pm@bgt\csname\i@bgt @alpha@bgt\endcsname:\invx@bgt\subgame@innersep@bgt\space and \invy@bgt\subgame@innersep@bgt)$);
			% find "magnets"
			\pgfextractangle{\alpha@bgt}{#1}{\i@bgt @bgt}
			\tikz@scan@one@point\pgfutil@firstofone($(\i@bgt @bgt)-(#1)$)\relax
			\pgfmathsetmacro{\sub@dist@bgt}{100*sqrt((\the\pgf@x/100)^2 + (\the\pgf@y/100)^2)}
			\pgfmathsetmacro{\sub@x@bgt}{abs(sin(180-abs(\angle@bgt-\alpha@bgt)))*\sub@dist@bgt}
			\pgfmathsetmacro{\subx@x@bgt}{\invx@bgt*\sub@x@bgt}
			\pgfmathsetmacro{\suby@x@bgt}{\invy@bgt*\sub@x@bgt}
			\coordinate (A\i@bgt @bgt) at ($(A@bgt) + 0.8*\csname subgame@\i@bgt w@bgt\endcsname*(\angle@bgt\pm@bgt90:\subx@x@bgt\space pt and \suby@x@bgt\space pt)$);
			\coordinate (\i@bgt 1@bgt) at ($0.5*(A@bgt) + 0.5*(\i@bgt @bgt)+0.5*\csname subgame@\i@bgt w@bgt\endcsname*(\angle@bgt\pm@bgt90:\subx@x@bgt\space pt and \suby@x@bgt\space pt)$);
		}
		\bezier@bgt{l@bgt}{l1@bgt}{Al@bgt}{A@bgt}{Ar@bgt}{r1@bgt}{r@bgt}
		% debug
		\begingroup
			\ifsubgame@debug@bgt
				\edef\draw@bgt{%
					\noexpand\draw\overlay@bgt[debug@bgt] (#1) ellipse (\the\dimexpr\invx@bgt\subgame@innersep@bgt\relax\space and \the\dimexpr\invy@bgt\subgame@innersep@bgt\relax);%
					\noexpand\draw\overlay@bgt[debug@bgt] (\sub@l@bgt) ellipse (\the\dimexpr\invx@bgt\subgame@innersep@bgt\relax\space and \the\dimexpr\invy@bgt\subgame@innersep@bgt\relax);%
					\noexpand\draw\overlay@bgt[debug@bgt] (\sub@r@bgt) ellipse (\the\dimexpr\invx@bgt\subgame@innersep@bgt\relax\space and \the\dimexpr\invy@bgt\subgame@innersep@bgt\relax);%
				}
				\draw@bgt%
				\state@debug@bgttrue
			\fi
			\ifstreq@bgt{#2}{}{}{
				\placelabel@bgt{\subgame@color@bgt}{A@bgt}{\subgame@label@bgt}{\dimexpr\subgame@labelsep@bgt+0.5\subgame@linewidth@bgt\relax}{\subgame@font@bgt}{#2}{\overlay@bgt}{\subgame@label@overlay@bgt}
			}
		\endgroup
	\fi
}
%
\def\subgame@bezier@getseq@bgt#1#2{
	% #1: apex
	% #2: 'l' or 'r'
	\ifstreq@bgt{#2}{l}{\def\exti@bgt{1}\def\angle@check@bgt{\ifdim\thisangle@bgt pt<\extangle@bgt pt\relax\global\let\extangle@bgt\thisangle@bgt\xdef\exti@bgt{\i@bgt}\fi}}{\def\exti@bgt{\kids@bgtlen}\def\angle@check@bgt{\ifdim\thisangle@bgt pt>\extangle@bgt pt\relax\global\let\extangle@bgt\thisangle@bgt\xdef\exti@bgt{\i@bgt}\fi}}
	% find point in tree
	\sub@terminate@bgtfalse
	\def\curr@coord@bgt{#1}
	\begingroup%
		\pgfmathloop%
		\ifsub@terminate@bgt
		\else%
			\setsepchar{,/:}
			\expandafter\readlist\expandafter*\expandafter\kids@bgt\expandafter{\csname sub@\curr@coord@bgt @bgt\endcsname}
			\def\extangle@bgt{0}
			\foreach \i@bgt in {1, ..., \kids@bgtlen} {
				\pgfextractangle{\beta@bgt}{\curr@coord@bgt}{\kids@bgt[\i@bgt,1]}
				\pgfmathsetmacro{\phaseshift@bgt}{180-\subgame@dir@bgt}
				\pgfmathsetmacro{\thisangle@bgt}{mod(\beta@bgt+\phaseshift@bgt, 360)-\phaseshift@bgt-\subgame@dir@bgt}
				\angle@check@bgt
			}
			\xdef\curr@coord@bgt{\kids@bgt[\exti@bgt,1]}
			\ifstreq@bgt{#2}{l}{
				\xdef\sub@lcoord@bgt{\sub@lcoord@bgt -- (\curr@coord@bgt)}
			}{
				\xdef\sub@rcoord@bgt{ -- (\curr@coord@bgt)\sub@rcoord@bgt}
			}
			\@ifundefined{sub@\curr@coord@bgt @bgt}{% search terminates
				\global\sub@terminate@bgttrue
				\expandafter\xdef\csname sub@#2tdir@bgt\endcsname{\kids@bgt[\exti@bgt,2]}
			}{}%
		\repeatpgfmathloop%
	\endgroup%
	\expandafter\global\expandafter\let\csname sub@#2@bgt\endcsname\curr@coord@bgt%
}
%
\def\subgame@convhull@bgt#1#2{%
	% #1 : apex
	% #2 : label
	% check whether the coordinate is a terminal node
	\sub@error@bgtfalse
	\foreach \coord@bgt in \tree@terminallist@bgt {
		\ifstreq@bgt{\coord@bgt}{#1}{\global\sub@error@bgttrue}{}
	}
	\ifsub@error@bgt
		\PackageError{xgames}{Subgame cannot start at a terminal node}{}
	\else
		% find points in tree
		\def\sub@lcoord@bgt{}
		\def\sub@rcoord@bgt{}
		\subgame@bezier@getseq@bgt{#1}{l}
		\subgame@bezier@getseq@bgt{#1}{r}
		%
		\edef\draw@bgt{\noexpand\informset[line=\subgame@line@bgt, line width=\subgame@linewidth@bgt, color=\subgame@color@bgt] (#1) \sub@lcoord@bgt \sub@rcoord@bgt #2;}
		\draw@bgt
	\fi
}
%
\def\subgame@opt#1at#2(#3)#4;{%
	% #1, #2 : gobbles space
	% #3 : coordinate
	% #4 : label
	% Process options
	\def\subgame@label@overlay@bgt{}% BB Xmas
	\subgame@dirprovided@bgtfalse%
	\expandafter\subgamesetoptions@bgt\expandafter{\option@bgt}%
	\ifsubgame@bezier@bgt%
		\ifempty@bgt{#4}{\subgame@bezier@bgt{#3}{}}{\subgame@bezier@bgt{#3}{\@firstofone#4}}%
	\else%
		\subgame@convhull@bgt{#3}{#4}%
	\fi%
}
\addoptions@bgt{subgame}
\addoverlay@bgt{subgame}
%
\def\bezier@bgt#1#2#3#4#5#6#7{
	\tikz@scan@one@point\pgfutil@firstofone(#4)\relax
	\edef\px@four{\the\pgf@x}
	\edef\py@four{\the\pgf@y}
	\tikz@scan@one@point\pgfutil@firstofone(#1)\relax
	\edef\px@one{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@one{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\tikz@scan@one@point\pgfutil@firstofone(#2)\relax
	\edef\px@two{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@two{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\tikz@scan@one@point\pgfutil@firstofone(#3)\relax
	\edef\px@three{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@three{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\tikz@scan@one@point\pgfutil@firstofone(#5)\relax
	\edef\px@five{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@five{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\tikz@scan@one@point\pgfutil@firstofone(#6)\relax
	\edef\px@six{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@six{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\tikz@scan@one@point\pgfutil@firstofone(#7)\relax
	\edef\px@seven{\expandafter\the\dimexpr\pgf@x - \px@four\relax}
	\edef\py@seven{\expandafter\the\dimexpr\pgf@y - \py@four\relax}
	\def\tp{max(\noexpand\x, 0)}
	\def\tn{min(\noexpand\x, 0)}
	\begin{scope}[shift={(\px@four, \py@four)}]
		\pgfmathsetmacro{\l@ext@bgt}{\subgame@depth@bgt/sin(\l@alpha@bgt)+\subgame@innersep@bgt/tan(\l@alpha@bgt)}
		\pgfmathsetmacro{\r@ext@bgt}{\subgame@depth@bgt/sin(\r@alpha@bgt)+\subgame@innersep@bgt/tan(\r@alpha@bgt)}
%		\pgfmathsetmacro{\l@ext@bgt}{\subgame@depth@bgt*cos(\angle@bgt+\l@alpha@bgt+90-\sub@ltdir@bgt)}
%		\pgfmathsetmacro{\r@ext@bgt}{\subgame@depth@bgt*cos(\r@alpha@bgt+90-\angle@bgt+\sub@rtdir@bgt)}
%		\pgfmathsetmacro{\l@ext@bgt}{\subgame@depth@bgt/cos(\angle@bgt+\l@alpha@bgt+90-\sub@ltdir@bgt)}
%		\pgfmathsetmacro{\r@ext@bgt}{\subgame@depth@bgt/cos(\r@alpha@bgt+90-\angle@bgt+\sub@rtdir@bgt)}
		\clip (\angle@bgt:2pt) -- (\px@three, \py@three) -- (\px@two, \py@two) -- ($(\px@one, \py@one) + (\sub@ltdir@bgt-90:2pt)$) -- ++(\angle@bgt+\l@alpha@bgt+90:\l@ext@bgt\space pt) -- ++(\sub@ltdir@bgt+90:5pt) -- ($(\px@seven, \py@seven) + (\angle@bgt-\r@alpha@bgt-90:\r@ext@bgt\space pt) + (\sub@rtdir@bgt-90:3pt)$) -- ++(\sub@rtdir@bgt+90:5pt) -- ($(\px@seven, \py@seven) + (\sub@rtdir@bgt+90:2pt)$) -- (\px@six, \py@six) -- (\px@five, \py@five) -- cycle;
		\edef\draw@bgt{\noexpand\draw\overlay@bgt[smooth, \subgame@line@bgt, line width=\subgame@linewidth@bgt, \subgame@color@bgt] plot[domain=-2:2] ({-\tn^3*\px@one+3*\tn^2*(1+\tn)*\px@two-3*\tn*(1+\tn)^2*\px@three + 3*\tp*(1-\tp)^2*\px@five+3*\tp^2*(1-\tp)*\px@six+\tp^3*\px@seven}, {-\tn^3*\py@one+3*\tn^2*(1+\tn)*\py@two-3*\tn*(1+\tn)^2*\py@three + 3*\tp*(1-\tp)^2*\py@five+3*\tp^2*(1-\tp)*\py@six+\tp^3*\py@seven});}
		\draw@bgt
	\end{scope}
	\ifsubgame@debug@bgt
		\expandafter\draw\overlay@bgt[thin, debug@bgt] (#1) -- (#2) (#3) -- (#5) (#6) -- (#7);
		\edef\draw@bgt{%
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] (#1) ellipse (\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \the\dimexpr\invy@bgt\state@radius@bgt\relax);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] (#4) ellipse (\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \the\dimexpr\invy@bgt\state@radius@bgt\relax);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] (#7) ellipse (\the\dimexpr\invx@bgt\state@radius@bgt\relax\space and \the\dimexpr\invy@bgt\state@radius@bgt\relax);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] ($(#2)-(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$) rectangle ($(#2)+(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] ($(#3)-(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$) rectangle ($(#3)+(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] ($(#5)-(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$) rectangle ($(#5)+(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$);
			\noexpand\draw\overlay@bgt[debug@bgt, fill=xg-bg] ($(#6)-(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$) rectangle ($(#6)+(\the\dimexpr\invx@bgt\state@radius@bgt\relax, \the\dimexpr\invy@bgt\state@radius@bgt\relax)$);
		}
		\draw@bgt
	\fi
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	   4.5 Strategies
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newcounter{strat@bgt}
\newif\ifnature@hasmoves@bgt
%
% keys for show prob
\newif\ifsp@frac@bgt
\newif\ifsp@color@bgt
\newif\ifsp@path@bgt
%
% keys for show terminal
\newif\ifst@frac@bgt
\newif\ifst@path@bgt
%
\define@bgt@family{strategy}{
	root, \tree@root@bgt;
	prob, 0
}{}{}{
	positive only, false;
	show prob, false;
	show terminal, false
}{}{}{}{%
	\global\sp@frac@bgtfalse%
	\global\sp@path@bgtfalse%
	\global\st@frac@bgtfalse%
	\global\st@path@bgtfalse%
}
%
\define@key{strategy@bgt}{show terminal}[true]{%
	\ifstreq@bgt{#1}{false}{\strategy@showterminal@bgtfalse}{%
		\strategy@showterminal@bgttrue%
		\ifstreq@bgt{#1}{true}{}{%
			% can't use \setkeys within \define@key
			\setsepchar{<||>/,}%
			\readlist*\st@options@bgt{#1}%
			\ifnum\st@options@bgtlen>1%
				\edef\terminal@overlay@bgt{<\st@options@bgt[2]>}%
				\foreachitem \item@bgt \in \st@options@bgt[3] {
					\ifstreq@bgt{\item@bgt}{frac}{\global\st@frac@bgttrue}{%
						\ifstreq@bgt{\item@bgt}{path}{\global\st@path@bgttrue}{%
							\edef\temp@a{Key '\item@bgt' unknown to 'show terminal'.}
							\def\temp@b{\PackageWarning{xgames}}
							\expandafter\temp@b\expandafter{\temp@a}{}
					}}
				}
			\else%
				\foreachitem \item@bgt \in \st@options@bgt[1] {
					\ifstreq@bgt{\item@bgt}{frac}{\global\st@frac@bgttrue}{%
						\ifstreq@bgt{\item@bgt}{path}{\global\st@path@bgttrue}{%
							\edef\temp@a{Key '\item@bgt' unknown to 'show terminal'.}
							\def\temp@b{\PackageWarning{xgames}}
							\expandafter\temp@b\expandafter{\temp@a}{}
					}}
				}
			\fi
}}}
\define@key{strategy@bgt}{show prob}[true]{%
	\ifstreq@bgt{#1}{false}{\strategy@showprob@bgtfalse}{%
		\strategy@showprob@bgttrue%
		\ifstreq@bgt{#1}{true}{}{%
			% can't use \setkeys within \define@key
			\setsepchar{<||>/,}%
			\readlist*\sp@options@bgt{#1}%
			\ifnum\sp@options@bgtlen>1%
				\edef\label@overlay@bgt{<\sp@options@bgt[2]>}%
				\foreachitem \item@bgt \in \sp@options@bgt[3] {
					\ifstreq@bgt{\item@bgt}{frac}{\global\sp@frac@bgttrue}{%
						\ifstreq@bgt{\item@bgt}{path}{\global\sp@path@bgttrue}{%
							\ifstreq@bgt{\item@bgt}{color}{\global\sp@color@bgttrue}{%
								\edef\temp@a{Key '\item@bgt' unknown to 'show prob'.}
								\def\temp@b{\PackageWarning{xgames}}
								\expandafter\temp@b\expandafter{\temp@a}{}
					}}}
				}
			\else%
				\foreachitem \item@bgt \in \sp@options@bgt[1] {
					\ifstreq@bgt{\item@bgt}{frac}{\global\sp@frac@bgttrue}{%
						\ifstreq@bgt{\item@bgt}{path}{\global\sp@path@bgttrue}{%
							\ifstreq@bgt{\item@bgt}{color}{\global\sp@color@bgttrue}{%
								\edef\temp@a{Key '\item@bgt' unknown to 'show prob'.}
								\def\temp@b{\PackageWarning{xgames}}
								\expandafter\temp@b\expandafter{\temp@a}{}
					}}}
				}
			\fi
}}}
%
\def\strategy@opt#1{
	\iftree@enablestrategies@bgt
	\addtocounter{strat@bgt}{1}
	% default values
	\let\terminal@overlay@bgt\overlay@bgt
	\let\label@overlay@bgt\overlay@bgt
	\expandafter\strategysetoptions@bgt\expandafter{\option@bgt}
	% read input
	\setsepchar{&/;/,}
	\readlist*\strat@bgt{#1}
	% in case \strategy@root@bgt does not coincide with \parent@bgt
	\expandafter\gdef\csname strat\roman{strat@bgt}@prob@\tree@root@bgt @bgt\endcsname{0}
	% for player-wise input
	\ifnum\strat@bgtlen>1
		\foreach \pl@bgt in {1, ..., \strat@bgtlen} {
			\expandafter\gdef\csname player\romannumeral\pl@bgt @ctr\endcsname{0}
		}
	\fi
	% read coordinate list
	\setsepchar{,/:}
	\expandafter\readlist\expandafter*\expandafter\active@nodes@bgt\expandafter{\tree@coordlist@bgt}
	% iterate over player list
	\def\temp{\foreach[count=\c@bgt] \pl@bgt in}
	\expandafter\temp\expandafter{\tree@playerlist@bgt} {
		% set player color
		\setcounter{activeplayer@bgt}{\pl@bgt}
		\select@activeplayer@bgt
		\ifnum\strat@bgtlen=1
			% for is-wise input
			\pgfmathtruncatemacro{\nactions@bgt}{\listlen\strat@bgt[1, \c@bgt]}
		\else
			% for player-wise input
			\ifnature@hasmoves@bgt
				% indexing in listofitems starts at 1
				\pgfmathtruncatemacro{\pl@bgt}{\pl@bgt+1}
			\fi
			% advance counter and let it to \i@bgt for ease of reference
			\pgfmathtruncatemacro{\i@bgt}{\csname player\romannumeral\pl@bgt @ctr\endcsname+1}
			\expandafter\global\expandafter\let\csname player\romannumeral\pl@bgt @ctr\endcsname\i@bgt
			\pgfmathtruncatemacro{\nactions@bgt}{\listlen\strat@bgt[\pl@bgt, \i@bgt]}
		\fi
		\def\total@prob{0}
		\foreach \j@bgt in {1, ..., \nactions@bgt}{
			% calculate total probability
			\ifnum\strat@bgtlen=1
				% for is-wise input
				\itemtomacro\strat@bgt[1, \c@bgt, \j@bgt]\curr@prob
			\else
				% for player-wise input
				\itemtomacro\strat@bgt[\pl@bgt, \i@bgt, \j@bgt]\curr@prob
			\fi
			\pgfmathparse{\fpeval{\total@prob+\curr@prob}}
			\global\let\total@prob\pgfmathresult
			% for each node in the information set
			\foreachitem \n@bgt \in \active@nodes@bgt[\c@bgt] {
				% define probabilities iteratively
				\expandafter\xdef\csname strat\roman{strat@bgt}@prob@\n@bgt\j@bgt @bgt\endcsname{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@\n@bgt @bgt\endcsname*\curr@prob}{\overlay@bgt}
				% treat the case leading up to a subgame separately
				\ifstreq@bgt{\strategy@root@bgt}{\n@bgt\j@bgt}{
					% edge leading up to subgame lies outside even if curr@prob > 0
					\ifstrategy@positiveonly@bgt\else\ifdim\curr@prob pt>0pt
						\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (\n@bgt) -- (\n@bgt\j@bgt);
					\fi\fi
				}{
					% postpone drawing until all probabilities have been defined
					\draw@prob@sheet{\n@bgt}{\n@bgt\j@bgt}{\fpeval{\curr@prob}}{\overlay@bgt}
				}
			}
		}
		% calculate complementary probability
		\ifnum\strat@bgtlen=1
			% for is-wise input
			\pgfmathtruncatemacro{\j@bgt}{\listlen\strat@bgt[1, \c@bgt]+1}
		\else
			% for player-wise input
			\pgfmathtruncatemacro{\j@bgt}{\listlen\strat@bgt[\pl@bgt, \i@bgt]+1}
		\fi
		\pgfmathsetmacro{\last@prob}{\fpeval{1 - \total@prob}}
		% for each node in the information set
		\foreachitem \n@bgt \in \active@nodes@bgt[\c@bgt] {
			% define probabilities iteratively
			\expandafter\xdef\csname strat\roman{strat@bgt}@prob@\n@bgt\j@bgt @bgt\endcsname{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@\n@bgt @bgt\endcsname*\last@prob}
			% treat the case leading up to a subgame separately
			\ifstreq@bgt{\strategy@root@bgt}{\n@bgt\j@bgt}{
				% edge leading up to subgame lies outside even if last@prob > 0
				\ifstrategy@positiveonly@bgt\else\ifdim\last@prob pt>0pt
					\expandafter\draw\overlay@bgt[line width=\edge@alertwidth@bgt, \activecolor@bgt] (\n@bgt) -- (\n@bgt\j@bgt);
				\fi\fi
			}{
				% postpone drawing until all probabilities have been defined iteratively
				\draw@prob@sheet{\n@bgt}{\n@bgt\j@bgt}{\last@prob}{\overlay@bgt}
			}
		}
	}
	\expandafter\gdef\csname strat\roman{strat@bgt}@prob@\strategy@root@bgt @bgt\endcsname{1} % BB Xmas
	\ifstrategy@showterminal@bgt
		\foreach \coord@bgt in \tree@terminallist@bgt {
			\ifst@frac@bgt
				\def\output@bgt{\noexpand\pgfmathprintnumber[frac]{\noexpand\st@temp@prob}}
			\else
				\def\output@bgt{\noexpand\pgfmathprintnumber[fixed, precision=2]{\noexpand\st@temp@prob}}
			\fi
			\AtEndEnvNoExpand@bgt{\pgfmathsetmacro{\st@temp@prob}}
			\AtEndEnv@bgt{%
				% completely expand the probability
				{\noexpand\fpeval{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@\coord@bgt @bgt\endcsname}}%
				\noexpand\def\noexpand\state@labelcolor@bgt{xg-fg}
				\noexpand\state@placelabel@bgt[]{\coord@bgt}{below}{\output@bgt}{\overlay@bgt}{\terminal@overlay@bgt}
			}
		}
	\fi
	\else
		\PackageWarning{xgames}{Use the key `enable strategies` for this functionality}{}
	\fi
}
\addoptions@bgt{strategy}
\addoverlay@bgt{strategy}
%
\def\draw@prob@sheet#1#2#3#4{
	% #1: parent
	% #2: child
	% #3: current probability
	% #4: overlay
	\pgfmathsetmacro{\curr@prob}{#3} % parsing fractional input
	\expandafter\let\expandafter\st@branch@overlay@bgt\csname strat@overlay@#1@bgt\endcsname
	\expandafter\ifdim\curr@prob pt>0pt%
		% only draw a sheet if the action chosen with positive probability
		\ifstrategy@positiveonly@bgt
			\def\positiveonly@bgt{}
		\else%
			\def\positiveonly@bgt{\noexpand\visible\st@branch@overlay@bgt{\noexpand\draw#4[line width=\edge@alertwidth@bgt, \activecolor@bgt] (#1) -- (#2);}}
		\fi%
		% should add a counter by the number of times strategy was called
		\AtEndEnvNoExpand@bgt{\pgfmathsetmacro{\st@temp@prob}}
		\AtEndEnv@bgt{%
			% completely expand the probability
			{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@#2@bgt\endcsname*\noexpand\strategy@prob@bgt}%
			\noexpand\ifdim\noexpand\st@temp@prob pt>0pt%
				% draw a sheet only if parent is reached with positive probability
				\noexpand\visible\st@branch@overlay@bgt{\noexpand\draw#4[\activefill@bgt!80!black, fill=\activefill@bgt] ($(#1.center) + (0, \noexpand\st@temp@prob)$) -- (#1.center) -- (#2.center) -- ++(0, \noexpand\st@temp@prob) -- cycle;}%
			\noexpand\else%
				% otherwise, highlight action normally
				\positiveonly@bgt%
			\noexpand\fi%
		}%
	\fi%
	% output if needed
	\ifstrategy@showprob@bgt%
		% format output
		\ifsp@frac@bgt
			\def\output@bgt{\noexpand\pgfmathprintnumber[frac]{#3}}
		\else
			\def\output@bgt{\noexpand\pgfmathprintnumber[fixed, precision=2]{#3}}
		\fi
		\settodepth{\labeldepth@bgt}{\pgfinterruptpicture{\edge@font@bgt\output@bgt}\endpgfinterruptpicture}%
		% get direction of label
		\edge@defaultdirections@bgt{#1}{#2}%
		\pgfmathsetmacro{\label@angle@bgt}{\angle@bgt+\edge@labeldir@bgt}
		% output
		\ifsp@color@bgt
			\let\sp@color@bgt\activecolor@bgt
		\else
			\def\sp@color@bgt{xg-fg}
		\fi
		\ifsp@path@bgt
			\LateEndEnv@bgt{%
				\noexpand\pgfmathsetmacro{\noexpand\prob@bgt}{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@#2@bgt\endcsname*\noexpand\strategy@prob@bgt}%
				\noexpand\expandafter\noexpand\ifdim\noexpand\prob@bgt pt>0pt\noexpand\relax%
					\noexpand\label@placement@simple@bgtfalse%
					\noexpand\label@placement@box@bgttrue%
					\noexpand\visible\st@branch@overlay@bgt{\noexpand\placelabel@bgt{\sp@color@bgt}{$(#1.center)!0.5!(#2.center)+(0, \noexpand\prob@bgt)+(0, \the\labeldepth@bgt)$}{\label@angle@bgt}{\the\edge@labelsep@bgt}{\noexpand\edge@font@bgt}{\noexpand\contour{xg-bg}{$\output@bgt$}}{#4}{\label@overlay@bgt}}%
				\noexpand\fi%
			}%
		\else
			\LateEndEnv@bgt{%
				\noexpand\pgfmathsetmacro{\noexpand\prob@bgt}{\expandafter\noexpand\csname strat\roman{strat@bgt}@prob@#2@bgt\endcsname*\noexpand\strategy@prob@bgt}%		
				\noexpand\label@placement@simple@bgtfalse%
				\noexpand\label@placement@box@bgttrue%
				\noexpand\visible\st@branch@overlay@bgt{\noexpand\placelabel@bgt{\sp@color@bgt}{$(#1.center)!0.5!(#2.center)+(0, \noexpand\prob@bgt)+(0, \the\labeldepth@bgt)$}{\label@angle@bgt}{\the\edge@labelsep@bgt}{\noexpand\edge@font@bgt}{\noexpand\contour{xg-bg}{$\output@bgt$}}{#4}{\label@overlay@bgt}}%
			}%
		\fi
	\fi%
}
%
\newif\ifcontainedinlist@bgt
\def\reset@strategy@bgt{%
	\clear@kidlist@bgt%
	\foreach \i@bgt in {0, ..., 9} {%
		\expandafter\global\expandafter\let\csname tree@coord\romannumeral\i@bgt @bgt\endcsname\undefined%
	}%
	\let\tree@coordlist@bgt\undefined%
	\let\tree@playerlist@bgt\undefined%
	\let\tree@terminallist@bgt\undefined%
	\setcounter{strat@bgt}{0}
	\nature@hasmoves@bgtfalse%
}
\def\addto@coordlist@bgt#1{
	% #1: coordinate name to add
	\ifnum\value{activeplayer@bgt}=0
		\global\nature@hasmoves@bgttrue
	\fi
	% active player has been set
	\@ifundefined{tree@coordlist@bgt}{
		% if the list is undefined, we define it through its first element
		\xdef\tree@coordlist@bgt{#1}
		\xdef\tree@playerlist@bgt{\theactiveplayer@bgt}
		\global\containedinlist@bgtfalse
	}{
		% check whether the coordinate is already in the list
		\global\containedinlist@bgtfalse % making it global allows you to use it in \branch
		\def\temp{\foreach \item@bgt in}
		\expandafter\temp\expandafter{\tree@coordlist@bgt} {
			\ifstreq@bgt{\item@bgt}{#1}{\global\containedinlist@bgttrue}{}
		}
		% add it to the list if it is not already there
		\ifcontainedinlist@bgt\else
			\xdef\tree@coordlist@bgt{\tree@coordlist@bgt, #1}
			\xdef\tree@playerlist@bgt{\tree@playerlist@bgt, \theactiveplayer@bgt}
		\fi
	}
}
\def\addto@terminallist@bgt#1{
	% #1: coordinate name to add
	\@ifundefined{tree@terminallist@bgt}{
		% if the list is undefined, we define it through its first element
		\xdef\tree@terminallist@bgt{#1}
	}{
		% otherwise add it to the list
		\xdef\tree@terminallist@bgt{\tree@terminallist@bgt, #1}
	}
}
%
\newif\iffirstoflist@bgt
\def\combine@coordlist@bgt{
	% #1: player number
	% #2: coordinate name to add
	% \nodelist@bgt is parsed in \informset@opt
	\@ifundefined{tree@coordlist@bgt}{}{
		\firstoflist@bgttrue
		\def\templist@bgt{}
		\def\templayerlist@bgt{}
		\setsepchar{,}
		\expandafter\readlist\expandafter*\expandafter\player@list@bgt\expandafter{\tree@playerlist@bgt}
		\def\temp{\foreach[count=\j@bgt] \item@bgt in}
		\expandafter\temp\expandafter{\tree@coordlist@bgt} {
			\containedinlist@bgtfalse
			\foreach \i@bgt in {1, ..., \nodelist@bgtlen} {
				% strip parentheses (and potential labels)
				\itemtomacro\nodelist@bgt[\i@bgt]\currentcoord@bgt
				\ifstreq@bgt{\item@bgt}{\currentcoord@bgt}{\global\containedinlist@bgttrue}{}
			}
			
			\ifcontainedinlist@bgt
				\iffirstoflist@bgt
					% replace \item@bgt with list of nodes w1:w2:w3
					\itemtomacro\nodelist@bgt[1]\currentcoord@bgt
					\edef\item@bgt{\currentcoord@bgt}
					\ifnum\nodelist@bgtlen>1
						\foreach \i@bgt in {2, ..., \nodelist@bgtlen} {
							% strip parentheses (and potential labels)
							\itemtomacro\nodelist@bgt[\i@bgt]\currentcoord@bgt
							\xdef\item@bgt{\item@bgt:\currentcoord@bgt}
						}
					\fi
					% add it to the list
					\ifstreq@bgt{\templist@bgt}{}{
						\xdef\templist@bgt{\item@bgt}
						\xdef\templayer@bgt{\player@list@bgt[\j@bgt]}
					}{
						\xdef\templist@bgt{\templist@bgt, \item@bgt}
						\xdef\templayerlist@bgt{\templayerlist@bgt, \player@list@bgt[\j@bgt]}
					}
					\global\firstoflist@bgtfalse
				\fi
			\else
				% add it to the list
				\ifstreq@bgt{\templist@bgt}{}{
					\xdef\templist@bgt{\item@bgt}
					\xdef\templayerlist@bgt{\player@list@bgt[\j@bgt]}
				}{
					\xdef\templist@bgt{\templist@bgt, \item@bgt}
					\xdef\templayerlist@bgt{\templayerlist@bgt, \player@list@bgt[\j@bgt]}
				}
			\fi
		}
		\global\let\tree@coordlist@bgt\templist@bgt
		\global\let\tree@playerlist@bgt\templayerlist@bgt
	}
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	   5.1 Core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\usetikzlibrary{patterns}
\define@bgts@family{imput}{%
	font, \labelfontsize;
	vN, 1;
	xscale, 1;
	yscale, 1
}{%
	line width, \nodelinewidth@bgt;
	label sep, 0.6ex
}{}{
	integer, true
}{
	pattern, all:core:none
}{}{}{}
%
\def\imput@IRi@bgt{0}
\def\imput@IRii@bgt{0}
\def\imput@IRiii@bgt{0}
\define@key{imput@bgt}{IR}{\setsepchar{,}\readlist*\temp@bgt{#1}\itemtomacro\temp@bgt[1]\imput@IRi@bgt\itemtomacro\temp@bgt[2]\imput@IRii@bgt\itemtomacro\temp@bgt[3]\imput@IRiii@bgt}
%
\define@key@thickness@bgts{imput}
\define@key{imput@bgt}{scale}{\def\imput@xscale@bgt{#1}\def\imput@yscale@bgt{#1}}
% externalization
\newif\ifimput@externalize@bgt
\def\imput@external@bgt{}
\define@key{imput@bgt}{external}{\def\imput@external@bgt{#1}\imput@externalize@bgttrue}
%
\def\core@opt#1{
	\setsepchar{,/--}%/<||>}
	\readlist*\core@in@bgt{#1}
	\foreach \i@bgt in {1, 2, 3} {
		\ifnum\listlen\core@in@bgt[\i@bgt]=1
			\itemtomacro\core@in@bgt[\i@bgt]\core@from@bgt
			\itemtomacro\core@in@bgt[\i@bgt]\core@to@bgt
		\else
			\itemtomacro\core@in@bgt[\i@bgt, 1]\core@from@bgt
			\itemtomacro\core@in@bgt[\i@bgt, 2]\core@to@bgt
		\fi
		\ifnum\i@bgt=1
%			\ifimput@pattern@all@bgt
				\fill[pattern=north west lines, pattern color=player1] (\core@from@bgt, \imput@IRii@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRii@bgt) -- (\core@from@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRiii@bgt, \imput@IRiii@bgt) -- (\core@to@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRiii@bgt, \imput@IRiii@bgt) -- (\core@to@bgt, \imput@IRii@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRii@bgt) -- cycle;
%			\fi
			\draw[line width=\imput@linewidth@bgt, player1] (\core@from@bgt, \imput@IRii@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRii@bgt) -- (\core@from@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRiii@bgt, \imput@IRiii@bgt);
			\draw[line width=\imput@linewidth@bgt, player1] (\core@to@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRiii@bgt, \imput@IRiii@bgt) -- (\core@to@bgt, \imput@IRii@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRii@bgt);
		\else\ifnum\i@bgt=2
%			\ifimput@pattern@all@bgt
				\fill[pattern=north west lines, pattern color=player2] (\imput@IRi@bgt, \core@from@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRi@bgt) -- (\imput@vN@bgt-\core@from@bgt-\imput@IRiii@bgt, \core@from@bgt, \imput@IRiii@bgt) -- (\imput@vN@bgt-\core@to@bgt-\imput@IRiii@bgt, \core@to@bgt, \imput@IRiii@bgt) -- (\imput@IRi@bgt, \core@to@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRi@bgt) -- cycle;
%			\fi
			\draw[line width=\imput@linewidth@bgt, player2] (\imput@IRi@bgt, \core@from@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRi@bgt) -- (\imput@vN@bgt-\core@from@bgt-\imput@IRiii@bgt, \core@from@bgt, \imput@IRiii@bgt);
			\draw[line width=\imput@linewidth@bgt, player2] (\imput@vN@bgt-\core@to@bgt-\imput@IRiii@bgt, \core@to@bgt, \imput@IRiii@bgt) -- (\imput@IRi@bgt, \core@to@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRi@bgt);
		\else
%			\ifimput@pattern@all@bgt
				\fill[pattern=north west lines, pattern color=player3] (\imput@IRi@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRi@bgt, \core@from@bgt) -- (\imput@vN@bgt-\core@from@bgt-\imput@IRii@bgt, \imput@IRii@bgt, \core@from@bgt) -- (\imput@vN@bgt-\core@to@bgt-\imput@IRii@bgt, \imput@IRii@bgt, \core@to@bgt) -- (\imput@IRi@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRi@bgt, \core@to@bgt) -- cycle;
%			\fi
			\draw[line width=\imput@linewidth@bgt, player3] (\imput@IRi@bgt, \imput@vN@bgt-\core@from@bgt-\imput@IRi@bgt, \core@from@bgt) -- (\imput@vN@bgt-\core@from@bgt-\imput@IRii@bgt, \imput@IRii@bgt, \core@from@bgt);
			\draw[line width=\imput@linewidth@bgt, player3] (\imput@vN@bgt-\core@to@bgt-\imput@IRii@bgt, \imput@IRii@bgt, \core@to@bgt) -- (\imput@IRi@bgt, \imput@vN@bgt-\core@to@bgt-\imput@IRi@bgt, \core@to@bgt);
		\fi\fi
	}
}
\addoptions@bgt{core}
\addoverlay@bgt{core}
%
\def\imputations@bgt{%
	\ifimput@integer@bgt
		\pgfmathtruncatemacro{\ki@bgt}{\imput@vN@bgt-\imput@IRii@bgt-\imput@IRiii@bgt}
		\pgfmathtruncatemacro{\kii@bgt}{\imput@vN@bgt-\imput@IRi@bgt-\imput@IRiii@bgt}
		\pgfmathtruncatemacro{\kiii@bgt}{\imput@vN@bgt-\imput@IRi@bgt-\imput@IRii@bgt}
	\else
		\pgfmathsetmacro{\ki@bgt}{\imput@vN@bgt-\imput@IRii@bgt-\imput@IRiii@bgt}
		\pgfmathsetmacro{\kii@bgt}{\imput@vN@bgt-\imput@IRi@bgt-\imput@IRiii@bgt}
		\pgfmathsetmacro{\kiii@bgt}{\imput@vN@bgt-\imput@IRi@bgt-\imput@IRii@bgt}
	\fi
	\coordinate (x@1) at (\ki@bgt, \imput@IRii@bgt, \imput@IRiii@bgt);
	\placelabel@bgt{}{x@1}{-30}{\imput@labelsep@bgt}{\imput@font@bgt}{$\ap{\ki@bgt, \imput@IRii@bgt, \imput@IRiii@bgt}$}{}{}
	\coordinate (x@2) at (\imput@IRi@bgt, \kii@bgt, \imput@IRiii@bgt);
	\placelabel@bgt{}{x@2}{-150}{\imput@labelsep@bgt}{\imput@font@bgt}{$\ap{\imput@IRi@bgt, \kii@bgt, \imput@IRiii@bgt}$}{}{}
	\coordinate (x@3) at (\imput@IRi@bgt, \imput@IRii@bgt, \kiii@bgt);
	\placelabel@bgt{}{x@3}{90}{\imput@labelsep@bgt}{\imput@font@bgt}{$\ap{\imput@IRi@bgt, \imput@IRii@bgt, \kiii@bgt}$}{}{}
	\draw[line width=\imput@linewidth@bgt] (x@1) -- (x@2) -- (x@3) -- cycle;
}
%
\ifexternal@bgt
	\NewEnviron{imputations}[1][]{%
		\imputsetoptions{#1}%
		\ifimput@externalize@bgt%
			\expandafter\externalize\expandafter{\imput@external@bgt}%
		\fi%
		\begin{tikzpicture}[xscale=\imput@xscale@bgt, yscale=\imput@yscale@bgt, x={(-30:0.8)}, y={(-1, -0.8)}, z={(-1, -1)}, every node/.style={font=\imput@font@bgt}]
		\imputations@bgt
		\BODY
		\end{tikzpicture}%
	}{}
\else
	\newenvironment{imputations}[1][]{%
		\imputsetoptions{#1}%
		\begin{tikzpicture}[xscale=\imput@xscale@bgt, yscale=\imput@yscale@bgt, x={(-30:0.8)}, y={(-1, -0.8)}, z={(-1, -1)}, every node/.style={font=\imput@font@bgt}]
		\imputations@bgt
	}{
		\end{tikzpicture}%
	}
\fi
% Shapley value
\def\Sh{\mathrm{Sh}}
%
\setcounter{activeplayer@bgt}{0}
\makeatother